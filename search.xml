<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>HTTP状态码</title>
    <url>/2020/05/13/HTTP%E7%8A%B6%E6%80%81%E7%A0%81/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍返回结果的HTTP状态码。</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h1 id="1-状态码告知从服务器端返回的请求结果"><a href="#1-状态码告知从服务器端返回的请求结果" class="headerlink" title="1 状态码告知从服务器端返回的请求结果"></a>1 状态码告知从服务器端返回的请求结果</h1><p>状态码的职责是当客户端向服务器端发送请求时，描述返回的请求结果。借助状态码，用户可以知道服务器端是正常处理了请求，还是出现了错误  </p>
<p><img src="https://photos.alitaalice.cn/image/20200513120418.png" alt=""></p>
<p>状态码如 200 OK，以 3 位数字和原因短语组成。<br>数字中的第一位指定了响应类别，后两位无分类。响应类别有以下 5 种  </p>
<p><img src="https://photos.alitaalice.cn/image/20200513120523.png" alt=""></p>
<h2 id="2XX-成功"><a href="#2XX-成功" class="headerlink" title="2XX 成功"></a>2XX 成功</h2><h3 id="2-1-200-OK"><a href="#2-1-200-OK" class="headerlink" title="2.1 200 OK"></a>2.1 200 OK</h3><p><img src="https://photos.alitaalice.cn/image/20200513120936.png" alt=""></p>
<p>表示从客户端发来的请求在服务器端被正常处理了。<br>在响应报文内，随状态码一起返回的信息会因方法的不同而发生改变。比如，使用 GET 方法时，对应请求资源的实体会作为响应返回；而使用 HEAD 方法时，对应请求资源的实体首部不随报文主体作为响应返回（即在响应中只返回首部，不会返回实体的主体部分）  </p>
<h3 id="2-2-204-NOT-Content"><a href="#2-2-204-NOT-Content" class="headerlink" title="2.2 204 NOT Content"></a>2.2 204 NOT Content</h3><p><img src="https://photos.alitaalice.cn/image/20200513121124.png" alt=""></p>
<p>该状态码代表服务器接收的请求已成功处理，但在返回的响应报文中不含实体的主体部分。另外，也不允许返回任何实体的主体。比如，当从浏览器发出请求处理后，返回 204 响应，那么浏览器显示的页面不发生更新。<br>一般在只需要从客户端往服务器发送信息，而对客户端不需要发送新信息内容的情况下使用。  </p>
<h3 id="2-3-206-Partial-Content"><a href="#2-3-206-Partial-Content" class="headerlink" title="2.3 206 Partial Content"></a>2.3 206 Partial Content</h3><p><img src="https://photos.alitaalice.cn/image/20200513121229.png" alt=""></p>
<p>该状态码表示客户端进行了范围请求，而服务器成功执行了这部分的 GET 请求。响应报文中包含由Content-Range 指定范围的实体内容。  </p>
<h2 id="3-3XX-重定向"><a href="#3-3XX-重定向" class="headerlink" title="3 3XX 重定向"></a>3 3XX 重定向</h2><p>3XX 响应结果表明浏览器需要执行某些特殊的处理以正确处理请求。  </p>
<h3 id="3-1-301-Moved-Permanently"><a href="#3-1-301-Moved-Permanently" class="headerlink" title="3.1 301 Moved Permanently"></a>3.1 301 Moved Permanently</h3><p><img src="https://photos.alitaalice.cn/image/20200513121404.png" alt=""></p>
<p>永久性重定向。该状态码表示请求的资源已被分配了新的 URI，以后应使用资源现在所指的 URI。也就是说，如果已经把资源对应的 URI 保存为书签了，这时应该按 Location 首部字段提示的 URI 重新保存。像下方给出的请求 URI，当指定资源路径的最后忘记添加斜杠“/”，就会产生 301 状态码。  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;example.com&#x2F;sample</span><br></pre></td></tr></table></figure>

<h3 id="3-2-302-Found"><a href="#3-2-302-Found" class="headerlink" title="3.2 302 Found"></a>3.2 302 Found</h3><p><img src="https://photos.alitaalice.cn/image/20200513121815.png" alt=""></p>
<h3 id="3-3-303-See-Other"><a href="#3-3-303-See-Other" class="headerlink" title="3.3  303 See Other"></a>3.3  303 See Other</h3><p><img src="https://photos.alitaalice.cn/image/20200513122022.png" alt=""></p>
<p>该状态码表示由于请求对应的资源存在着另一个 URI，应使用 GET 方法定向获取请求的资源。<br>303 状态码和 302 Found 状态码有着相同的功能，但 303 状态码明确表示客户端应当采用 GET 方法获取资源，这点与 302 状态码有区别。<br>比如，当使用 POST 方法访问 CGI 程序，其执行后的处理结果是希望客户端能以 GET 方法重定向到另一个 URI 上去时，返回 303 状态码。虽然 302 Found 状态码也可以实现相同的功能，但这里使用 303 状态码是最理想的。  </p>
<h3 id="3-4-304-Not-Modified"><a href="#3-4-304-Not-Modified" class="headerlink" title="3.4 304 Not Modified"></a>3.4 304 Not Modified</h3><p><img src="C:%5CUsers%5C16508%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200513122317593.png" alt="image-20200513122317593"></p>
<p>该状态码表示客户端发送附带条件的请求 2 时，服务器端允许请求访问资源，但未满足条件的情况。304状态码返回时，不包含任何响应的主体部分。304 虽然被划分在 3XX 类别中，但是和重定向没有关系。  </p>
<h3 id="3-5-307-Temporary-Redirect"><a href="#3-5-307-Temporary-Redirect" class="headerlink" title="3.5 307 Temporary Redirect"></a>3.5 307 Temporary Redirect</h3><p>临时重定向。该状态码与 302 Found 有着相同的含义。尽管 302 标准禁止 POST 变换成 GET，但实际使用时大家并不遵守。<br>307 会遵照浏览器标准，不会从 POST 变成 GET。但是，对于处理响应时的行为，每种浏览器有可能出现不同的情况。</p>
<h2 id="4-4XX客户端错误"><a href="#4-4XX客户端错误" class="headerlink" title="4 4XX客户端错误"></a>4 4XX客户端错误</h2><h3 id="4-1-400-Bad-Request"><a href="#4-1-400-Bad-Request" class="headerlink" title="4.1 400 Bad Request"></a>4.1 400 Bad Request</h3><p><img src="https://photos.alitaalice.cn/image/20200513122701.png" alt=""></p>
<p>该状态码表示请求报文中存在语法错误。当错误发生时，需修改请求的内容后再次发送请求。另外，浏览器会像 200 OK 一样对待该状态码。  </p>
<h3 id="4-2-401-Unauthorized"><a href="#4-2-401-Unauthorized" class="headerlink" title="4.2 401 Unauthorized"></a>4.2 401 Unauthorized</h3><p>-+<img src="https://photos.alitaalice.cn/image/20200513122941.png" alt=""></p>
<p>该状态码表示发送的请求需要有通过 HTTP 认证（BASIC 认证、DIGEST 认证）的认证信息。另外若之前已进行过 1 次请求，则表示用户认证失败。  </p>
<h3 id="4-3-403-Forbidden"><a href="#4-3-403-Forbidden" class="headerlink" title="4.3 403 Forbidden"></a>4.3 403 Forbidden</h3><p><img src="https://photos.alitaalice.cn/image/20200513123055.png" alt=""></p>
<p>该状态码表明对请求资源的访问被服务器拒绝了。服务器端没有必要给出拒绝的详细理由，但如果想作说明的话，可以在实体的主体部分对原因进行描述，这样就能让用户看到了。<br>未获得文件系统的访问授权，访问权限出现某些问题（从未授权的发送源 IP 地址试图访问）等列举的情况都可能是发生 403 的原因。  </p>
<h3 id="4-4-404-Not-Found"><a href="#4-4-404-Not-Found" class="headerlink" title="4.4 404 Not Found"></a>4.4 404 Not Found</h3><p><img src="https://photos.alitaalice.cn/image/20200513123152.png" alt=""></p>
<p>该状态码表明服务器上无法找到请求的资源。除此之外，也可以在服务器端拒绝请求且不想说明理由时使用。  </p>
<h2 id="5-5XX-服务器错误"><a href="#5-5XX-服务器错误" class="headerlink" title="5 5XX 服务器错误"></a>5 5XX 服务器错误</h2><p>5XX 的响应结果表明服务器本身发生错误。  </p>
<h3 id="5-1-500-Internal-Server-Error"><a href="#5-1-500-Internal-Server-Error" class="headerlink" title="5.1 500 Internal Server Error"></a>5.1 500 Internal Server Error</h3><p>该状态码表明服务器端在执行请求时发生了错误。也有可能是 Web 应用存在的 bug 或某些临时的故障。  <img src="C:%5CUsers%5C16508%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200513123521561.png" alt="image-20200513123521561"></p>
<h3 id="5-2-503-Service-Unavailable"><a href="#5-2-503-Service-Unavailable" class="headerlink" title="5.2 503 Service Unavailable"></a>5.2 503 Service Unavailable</h3><p><img src="https://photos.alitaalice.cn/image/20200513123558.png" alt=""></p>
<p>该状态码表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。如果事先得知解除以上状况需要的时间，最好写入 RetryAfter 首部字段再返回给客户端。  </p>
]]></content>
      <categories>
        <category>计网</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP协议</title>
    <url>/2020/05/18/HTTP%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍HTTP协议</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="1-HTTP-协议用于客户端和服务器端之间的通信"><a href="#1-HTTP-协议用于客户端和服务器端之间的通信" class="headerlink" title="1 HTTP 协议用于客户端和服务器端之间的通信"></a>1 HTTP 协议用于客户端和服务器端之间的通信</h3><p>HTTP 协议能够明确区分哪端是客户端，哪端是服务器端  </p>
<h3 id="2-通过请求和响应的交换达成通信"><a href="#2-通过请求和响应的交换达成通信" class="headerlink" title="2 通过请求和响应的交换达成通信"></a>2 通过请求和响应的交换达成通信</h3><p>HTTP 协议规定，请求从客户端发出，最后服务器端响应该请求并返回  </p>
<p><img src="https://photos.alitaalice.cn/image/20200518114122.png" alt=""></p>
<p>起始行开头的GET表示请求访问服务器的类型，称为方法（method）。随后的字符串 /index.htm 指明了请求访问的资源对象，也叫做请求 URI（request-URI）。最后的 HTTP/1.1，即 HTTP 的版本号，用来提示客户端使用的 HTTP 协议功能  .</p>
<p>请求首部字段及内容实体稍后会作详细说明。接下来，我们继续讲解。接收到请求的服务器，会将请求内容的处理结果以响应的形式返回。  </p>
<p><img src="https://photos.alitaalice.cn/image/20200518114432.png" alt=""></p>
<p><img src="https://photos.alitaalice.cn/image/20200518114521.png" alt=""></p>
<h3 id="3-HTTP-是不保存状态的协议"><a href="#3-HTTP-是不保存状态的协议" class="headerlink" title="3 HTTP 是不保存状态的协议"></a>3 HTTP 是不保存状态的协议</h3><p>HTTP 是一种不保存状态，即无状态（stateless）协议。HTTP 协议自身不对请求和响应之间的通信状态进行保存。也就是说在 HTTP 这个级别，协议对于发送过的请求或响应都不做持久化处理。  </p>
<p><img src="https://photos.alitaalice.cn/image/20200518114709.png" alt=""></p>
<h3 id="4-请求URI定位资源"><a href="#4-请求URI定位资源" class="headerlink" title="4 请求URI定位资源"></a>4 请求URI定位资源</h3><p><img src="https://photos.alitaalice.cn/image/20200518115112.png" alt=""></p>
<h3 id="5-HTTP方法"><a href="#5-HTTP方法" class="headerlink" title="5 HTTP方法"></a>5 HTTP方法</h3><p><img src="https://photos.alitaalice.cn/image/20200518164346.png" alt=""></p>
<h3 id="6-持久连接"><a href="#6-持久连接" class="headerlink" title="6 持久连接"></a>6 持久连接</h3><p>持久连接的特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态，持久连接旨在建立 1 次 TCP 连接后进行多次请求和响应的交互。</p>
<h3 id="7-管线化"><a href="#7-管线化" class="headerlink" title="7 管线化"></a>7 管线化</h3><p>持久连接使得多数请求以管线化（pipelining）方式发送成为可能。从前发送请求后需等待并收到响应，才能发送下一个请求。管线化技术出现后，不用等待响应亦可直接发送下一个请求。<br>这样就能够做到同时并行发送多个请求，而不需要一个接一个地等待响应了。  </p>
<p><img src="https://photos.alitaalice.cn/image/20200518164857.png" alt=""></p>
<h3 id="8-使用Cookie的状态管理"><a href="#8-使用Cookie的状态管理" class="headerlink" title="8 使用Cookie的状态管理"></a>8 使用Cookie的状态管理</h3><p><img src="https://photos.alitaalice.cn/image/20200518165228.png" alt=""></p>
<h3 id="各层对应的协议"><a href="#各层对应的协议" class="headerlink" title="各层对应的协议"></a>各层对应的协议</h3><h3 id="OSI七层对各层协议"><a href="#OSI七层对各层协议" class="headerlink" title="OSI七层对各层协议"></a>OSI七层对各层协议</h3>]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>ArrayList和LinkedList</title>
    <url>/2020/05/07/ArrayList%E5%92%8CLinkedList/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>List集合包括List接口和List接口所有的实现类</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h2 id="List接口定义的方法"><a href="#List接口定义的方法" class="headerlink" title="List接口定义的方法"></a>List接口定义的方法</h2><p>除了继承Collection外，List接口还有俩个重要的方法。</p>
<table>
<thead>
<tr>
<th>get(int index)</th>
<th>获得指定索引位置的元素</th>
</tr>
</thead>
<tbody><tr>
<td>set(int index,Object obj)</td>
<td>将集合中指定索引位置的对象修改为指定的对象</td>
</tr>
</tbody></table>
<h2 id="List接口的实现类"><a href="#List接口的实现类" class="headerlink" title="List接口的实现类"></a>List接口的实现类</h2><ul>
<li><p>ArrayList</p>
<p>实现了可变的数组，允许保存所有元素包括null .并且可以根据索引的位置对集合进行快速的随机访问，缺点是向指向的索引位置插入对象或删除对象时的速度较慢</p>
</li>
<li><p>LinkedList </p>
<p>采用链表的结构保存对象。优点是便于向集合中插入和删除对象</p>
<p>分别用ArrayList 和LinkedList来实例化集合</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;E&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">List&lt;E&gt; list=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p>E是合法的JAVA数据类型，也可以是字符串String</p>
</li>
</ul>
]]></content>
      <categories>
        <category>JAVA集合</category>
      </categories>
      <tags>
        <tag>JAVA集合</tag>
      </tags>
  </entry>
  <entry>
    <title>HashMap默认加载因子为什么选择0.75</title>
    <url>/2020/05/13/HashMap%E9%BB%98%E8%AE%A4%E5%8A%A0%E8%BD%BD%E5%9B%A0%E5%AD%90%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A90.75/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍HashMap加载因子和初始容量</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>转载自<a href="https://www.cnblogs.com/aspirant/p/11470928.html" target="_blank" rel="noopener">https://www.cnblogs.com/aspirant/p/11470928.html</a></p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>JAVA源码</tag>
      </tags>
  </entry>
  <entry>
    <title>HashSet和TreeSet和LinkedHashSet</title>
    <url>/2020/05/08/HashSet%E5%92%8CTreeSet%E5%92%8CLinkedHashSet/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍Set</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p><strong>SET:注重独一无二的性质，该体系集合知道某物是否已经存在于集合中，不会存储重复的元素。</strong></p>
<p>用于存储无序（存入和取出的顺序不一定相同）元素，值不能重复</p>
<p>Set集合继承了Collection接口。</p>
<h2 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h2><p>哈希表里面存放的是哈希值。HashSet存储元素的顺序并不是按照存入时的顺序（和List 显然不同）是按照哈希值来存，所以取也是按照哈希值来取得。</p>
<p><strong>元素的哈希值是通过元素的hashcode方法来获取的，HashSet首先判断俩个元素的哈希值，如果哈希值一样，那么接着比较equals方法，如果equals结果为true。HashSet就会视作同一个元素。如果equals为false 就不是同一个元素。</strong></p>
<h3 id="哈希值相同equals为flase的元素是怎么存储的呢？"><a href="#哈希值相同equals为flase的元素是怎么存储的呢？" class="headerlink" title="哈希值相同equals为flase的元素是怎么存储的呢？"></a>哈希值相同equals为flase的元素是怎么存储的呢？</h3><p>就是在同样的哈希值下顺延。也就是哈希值一样的存一列。</p>
<p>HashTable</p>
<p><img src="hashtable.png" alt=""></p>
<p>图1：hashCode值不相同的情况</p>
<p>图2：hashCode值相同，但equals不相同的情况。</p>
<h3 id="HashSet到底是如何判断俩个元素重复"><a href="#HashSet到底是如何判断俩个元素重复" class="headerlink" title="HashSet到底是如何判断俩个元素重复"></a>HashSet到底是如何判断俩个元素重复</h3><p>通过hashCode方法和equals方法来保证元素的唯一性，add()返回的是boolean类型</p>
<p>判断两个元素是否相同，先要判断元素的hashCode值是否一致，只有在该值一致的情况下，才会判断equals方法，如果存储在HashSet中的两个对象hashCode方法的值相同equals方法返回的结果是true，那么HashSet认为这两个元素是相同元素，只存储一个（重复元素无法存入）。</p>
<p>注意：HashSet集合在判断元素是否相同先判断hashCode方法，如果相同才会判断equals。如果不相同，是不会调用equals方法的。</p>
<h3 id="HashSet-和ArrayList集合都有判断元素是否相同的方法"><a href="#HashSet-和ArrayList集合都有判断元素是否相同的方法" class="headerlink" title="HashSet 和ArrayList集合都有判断元素是否相同的方法"></a>HashSet 和ArrayList集合都有判断元素是否相同的方法</h3><p>boolean contains(Object o)</p>
<p>HashSet使用hashCode和equals方法，ArrayList使用了equals方法</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Set hs=<span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        hs.add(<span class="string">"jack"</span>);</span><br><span class="line">        hs.add(<span class="string">"rose"</span>);</span><br><span class="line">        hs.add(<span class="string">"2020"</span>);</span><br><span class="line">        hs.add(<span class="string">"trip"</span>);</span><br><span class="line">        System.out.println(hs.size());</span><br><span class="line">        <span class="keyword">boolean</span> add=hs.add(<span class="string">"jack"</span>); <span class="comment">/* 如果set尚未包含指定元素，那么 返回true 此时返回false; */</span></span><br><span class="line">        System.out.println(add);</span><br><span class="line">        Iterator it=hs.iterator();</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext())</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(it.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This program demonstrates</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Alita Alice</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: Created in 21:13 2020/5/8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HashSet hs = <span class="keyword">new</span> HashSet();</span><br><span class="line">        hs.add(<span class="keyword">new</span> Person(<span class="string">"jack"</span>, <span class="number">20</span>));</span><br><span class="line">        hs.add(<span class="keyword">new</span> Person(<span class="string">"rose"</span>,<span class="number">20</span>));</span><br><span class="line">        hs.add(<span class="keyword">new</span> Person(<span class="string">"rose"</span>,<span class="number">20</span>));</span><br><span class="line">        Iterator it= hs.iterator();</span><br><span class="line">        <span class="keyword">while</span>(it.hasNext())</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(it.next());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    Person()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name,<span class="keyword">int</span> age)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age=age;</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Person)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Person person = (Person) o;</span><br><span class="line">        <span class="keyword">return</span> getAge() == person.getAge() &amp;&amp;</span><br><span class="line">                getName().equals(person.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(getName(), getAge());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>其中在HashSet中存储自定义的对象，并尝试添加重复元素，需要override hashCode()和equls()方法。</strong></p>
<h2 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h2><p>现在有一批数据，要求不能重复存储元素，而且要排序。</p>
<p>ArrayList ，LinkList不能去除重复数据，HashSet可以去除重复，但是无序。</p>
<p>示例：使用TreeSet集合存储字符串元素，并且遍历。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo5</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TreeSet treeSet=<span class="keyword">new</span> TreeSet();</span><br><span class="line">        treeSet.add(<span class="string">"aaa"</span>);</span><br><span class="line">        treeSet.add(<span class="string">"bbb"</span>);</span><br><span class="line">        treeSet.add(<span class="string">"ccc"</span>);</span><br><span class="line">        treeSet.add(<span class="string">"ddd"</span>);</span><br><span class="line">        System.out.println(treeSet);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 输出</span></span><br><span class="line"><span class="comment">[aaa, bbb, ccc, ddd]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="俩种比较器接口"><a href="#俩种比较器接口" class="headerlink" title="俩种比较器接口"></a>俩种比较器接口</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Comparable </span><br><span class="line">         compareTo(Object o)  元素自身具备比较性</span><br><span class="line">Comparator</span><br><span class="line">         compare(Object o1,Object o2) 给容器传入比较器</span><br></pre></td></tr></table></figure>

<h3 id="TreeSet集合排序的俩种方式"><a href="#TreeSet集合排序的俩种方式" class="headerlink" title="TreeSet集合排序的俩种方式"></a>TreeSet集合排序的俩种方式</h3><ul>
<li><p>让元素自身具备比较性</p>
<p>元素需要实现Comparable接口，覆盖compareTo(Object o) 方法</p>
<p>这种方式也被称为元素的自然排序，也可以称为默认排序</p>
<p>年龄按照首要条件，年龄相同再比姓名</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sun.reflect.generics.tree.Tree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"><span class="keyword">import</span> java.util.TreeSet;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This program demonstrates</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Alita Alice</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: Created in 10:23 2020/5/9</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TreeSet ts=<span class="keyword">new</span> TreeSet();</span><br><span class="line">        ts.add(<span class="keyword">new</span> Person(<span class="string">"aa"</span>, <span class="number">20</span>, <span class="string">"男"</span>));</span><br><span class="line">        ts.add(<span class="keyword">new</span> Person(<span class="string">"bb"</span>, <span class="number">18</span>, <span class="string">"女"</span>));</span><br><span class="line">        ts.add(<span class="keyword">new</span> Person(<span class="string">"cc"</span>, <span class="number">17</span>, <span class="string">"男"</span>));</span><br><span class="line">        ts.add(<span class="keyword">new</span> Person(<span class="string">"dd"</span>, <span class="number">17</span>, <span class="string">"女"</span>));</span><br><span class="line">        ts.add(<span class="keyword">new</span> Person(<span class="string">"dd"</span>, <span class="number">15</span>, <span class="string">"女"</span>));</span><br><span class="line">        ts.add(<span class="keyword">new</span> Person(<span class="string">"dd"</span>, <span class="number">15</span>, <span class="string">"女"</span>));</span><br><span class="line">        System.out.println(ts);</span><br><span class="line">        System.out.println(ts.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Comparable</span></span></span><br><span class="line"><span class="class"> </span>&#123;</span><br><span class="line">     <span class="keyword">private</span> String name;</span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">     <span class="keyword">private</span> String gender;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age, String gender)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">this</span>.name = name;</span><br><span class="line">         <span class="keyword">this</span>.age = age;</span><br><span class="line">         <span class="keyword">this</span>.gender = gender;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> name;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">this</span>.name = name;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> age;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">this</span>.age = age;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> String <span class="title">getGender</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> gender;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setGender</span><span class="params">(String gender)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">this</span>.gender = gender;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="string">"Person&#123;"</span> +</span><br><span class="line">                 <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                 <span class="string">", age="</span> + age +</span><br><span class="line">                 <span class="string">", gender='"</span> + gender + <span class="string">'\''</span> +</span><br><span class="line">                 <span class="string">'&#125;'</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">         <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Person)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">         Person person = (Person) o;</span><br><span class="line">         <span class="keyword">return</span> getAge() == person.getAge() &amp;&amp;</span><br><span class="line">                 getName().equals(person.getName()) &amp;&amp;</span><br><span class="line">                 getGender().equals(person.getGender());</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> Objects.hash(getName(), getAge(), getGender());</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">         Person p = (Person) o;</span><br><span class="line">         System.out.println(<span class="keyword">this</span> + <span class="string">"compareTo:"</span> + p);</span><br><span class="line">         <span class="keyword">if</span> (<span class="keyword">this</span>.age &gt; p.age) &#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> (<span class="keyword">this</span>.age &lt; p.age) &#123;</span><br><span class="line">             <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">this</span>.name.compareTo(p.name);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">/* out</span></span><br><span class="line"><span class="comment">Person&#123;name='aa', age=20, gender='男'&#125;compareTo:Person&#123;name='aa', age=20, gender='男'&#125;</span></span><br><span class="line"><span class="comment">Person&#123;name='bb', age=18, gender='女'&#125;compareTo:Person&#123;name='aa', age=20, gender='男'&#125;</span></span><br><span class="line"><span class="comment">Person&#123;name='cc', age=17, gender='男'&#125;compareTo:Person&#123;name='aa', age=20, gender='男'&#125;</span></span><br><span class="line"><span class="comment">Person&#123;name='cc', age=17, gender='男'&#125;compareTo:Person&#123;name='bb', age=18, gender='女'&#125;</span></span><br><span class="line"><span class="comment">Person&#123;name='dd', age=17, gender='女'&#125;compareTo:Person&#123;name='bb', age=18, gender='女'&#125;</span></span><br><span class="line"><span class="comment">Person&#123;name='dd', age=17, gender='女'&#125;compareTo:Person&#123;name='cc', age=17, gender='男'&#125;</span></span><br><span class="line"><span class="comment">Person&#123;name='dd', age=15, gender='女'&#125;compareTo:Person&#123;name='bb', age=18, gender='女'&#125;</span></span><br><span class="line"><span class="comment">Person&#123;name='dd', age=15, gender='女'&#125;compareTo:Person&#123;name='cc', age=17, gender='男'&#125;</span></span><br><span class="line"><span class="comment">Person&#123;name='dd', age=15, gender='女'&#125;compareTo:Person&#123;name='bb', age=18, gender='女'&#125;</span></span><br><span class="line"><span class="comment">Person&#123;name='dd', age=15, gender='女'&#125;compareTo:Person&#123;name='cc', age=17, gender='男'&#125;</span></span><br><span class="line"><span class="comment">Person&#123;name='dd', age=15, gender='女'&#125;compareTo:Person&#123;name='dd', age=15, gender='女'&#125;</span></span><br><span class="line"><span class="comment">[Person&#123;name='dd', age=15, gender='女'&#125;, Person&#123;name='cc', age=17, gender='男'&#125;, Person&#123;name='dd', age=17, gender='女'&#125;, Person&#123;name='bb', age=18, gender='女'&#125;, Person&#123;name='aa', age=20, gender='男'&#125;]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="二-让容器自身具备比较性，自定义比较器"><a href="#二-让容器自身具备比较性，自定义比较器" class="headerlink" title="二 让容器自身具备比较性，自定义比较器"></a>二 让容器自身具备比较性，自定义比较器</h3><p>需求：当元素自身不具备比较性，或者元素自身具备的比较性不是所需。</p>
<p>那么这时只能让容器自身具备</p>
<p>定义一个类实现Comparetor接口，覆盖compare方法</p>
<p>并将该接口的子类对象作为参数传递给TreeSet集合的构造函数。</p>
<p>当Comparable 比较方式及Comparator比较方式同时存在， 以Com[arator比较方式为主。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"><span class="keyword">import</span> java.util.TreeSet;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This program demonstrates</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Alita Alice</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: Created in 10:54 2020/5/9</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo6</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TreeSet ts=<span class="keyword">new</span> TreeSet(<span class="keyword">new</span> MyComparator());</span><br><span class="line">        ts.add(<span class="keyword">new</span> Book(<span class="string">"think in java"</span>, <span class="number">100</span>));</span><br><span class="line">        ts.add(<span class="keyword">new</span> Book(<span class="string">"java 核心技术"</span>, <span class="number">75</span>));</span><br><span class="line">        ts.add(<span class="keyword">new</span> Book(<span class="string">"现代操作系统"</span>, <span class="number">50</span>));</span><br><span class="line">        ts.add(<span class="keyword">new</span> Book(<span class="string">"java就业教程"</span>, <span class="number">35</span>));</span><br><span class="line">        ts.add(<span class="keyword">new</span> Book(<span class="string">"think in java"</span>, <span class="number">100</span>));</span><br><span class="line">        ts.add(<span class="keyword">new</span> Book(<span class="string">"ccc in java"</span>, <span class="number">100</span>));</span><br><span class="line"></span><br><span class="line">        System.out.println(ts);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Object o1, Object o2)</span> </span>&#123;</span><br><span class="line">                    Book b1=(Book) o1;</span><br><span class="line">                    Book b2=(Book) o2;</span><br><span class="line">        System.out.println(b1+<span class="string">"comparator"</span>+b2);</span><br><span class="line">        <span class="keyword">if</span>(b1.getPrice()&gt;b2.getPrice())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(b1.getPrice()&lt;b2.getPrice())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b1.getName().compareTo(b2.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> price;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Book</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Book</span><span class="params">(String name, <span class="keyword">double</span> price)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPrice</span><span class="params">(<span class="keyword">double</span> price)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Book)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Book book = (Book) o;</span><br><span class="line">        <span class="keyword">return</span> Double.compare(book.getPrice(), getPrice()) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                getName().equals(book.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(getName(), getPrice());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Book&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", price="</span> + price +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* out</span></span><br><span class="line"><span class="comment">Book&#123;name='think in java', price=100.0&#125;comparatorBook&#123;name='think in java', price=100.0&#125;</span></span><br><span class="line"><span class="comment">Book&#123;name='java 核心技术', price=75.0&#125;comparatorBook&#123;name='think in java', price=100.0&#125;</span></span><br><span class="line"><span class="comment">Book&#123;name='现代操作系统', price=50.0&#125;comparatorBook&#123;name='think in java', price=100.0&#125;</span></span><br><span class="line"><span class="comment">Book&#123;name='现代操作系统', price=50.0&#125;comparatorBook&#123;name='java 核心技术', price=75.0&#125;</span></span><br><span class="line"><span class="comment">Book&#123;name='java就业教程', price=35.0&#125;comparatorBook&#123;name='java 核心技术', price=75.0&#125;</span></span><br><span class="line"><span class="comment">Book&#123;name='java就业教程', price=35.0&#125;comparatorBook&#123;name='现代操作系统', price=50.0&#125;</span></span><br><span class="line"><span class="comment">Book&#123;name='think in java', price=100.0&#125;comparatorBook&#123;name='java 核心技术', price=75.0&#125;</span></span><br><span class="line"><span class="comment">Book&#123;name='think in java', price=100.0&#125;comparatorBook&#123;name='think in java', price=100.0&#125;</span></span><br><span class="line"><span class="comment">Book&#123;name='ccc in java', price=100.0&#125;comparatorBook&#123;name='java 核心技术', price=75.0&#125;</span></span><br><span class="line"><span class="comment">Book&#123;name='ccc in java', price=100.0&#125;comparatorBook&#123;name='think in java', price=100.0&#125;</span></span><br><span class="line"><span class="comment">[Book&#123;name='java就业教程', price=35.0&#125;, Book&#123;name='现代操作系统', price=50.0&#125;, Book&#123;name='java 核心技术', price=75.0&#125;, Book&#123;name='ccc in java', price=100.0&#125;, Book&#123;name='think in java', price=100.0&#125;]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="4-LinkedHashSet"><a href="#4-LinkedHashSet" class="headerlink" title="4.LinkedHashSet"></a>4.LinkedHashSet</h3><p>会保存插入的顺序</p>
<p>看到array，就要想到角标</p>
<p>看到link ，就要想到first,last</p>
<p>看到hash,就要想到hashCode，equals</p>
<p>看到tree，就要想到俩个接口。Comparable,Comparator </p>
</li>
</ul>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>JAVA集合</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA_String_API</title>
    <url>/2020/05/06/JAVA-String-API/</url>
    <content><![CDATA[<p>String API</p>
<ul>
<li>append()</li>
</ul>
<p>  在由许多小段的字符串构建一个字符串时，则使用StringBuilder类（字符串构造器）</p>
<p>  首先构造一个空的字符串构造器：<br>  <a id="more"></a></p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StringBuilder builder =<span class="keyword">new</span> StringBuilder();</span><br></pre></td></tr></table></figure>

<p>  当需要添加一部分内容时，调用append()方法</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">builder.append(ch);</span><br><span class="line">builder.append(str);</span><br><span class="line">String completedString=builder.toString(); <span class="comment">/*调用toString()方法，得到String对象。*/</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>char charAt(int index)</p>
<p>返回给定位置的代码单元。</p>
</li>
<li><p>int length()</p>
</li>
</ul>
<p>​         返回字符串代码单元的个数</p>
<ul>
<li><p>String repeat(int count)</p>
<p>返回一个字符串，将当前字符重复count次</p>
</li>
<li><p>boolean equals() </p>
<p>用来检测俩个字符串是否相等</p>
<p>boolean equalsIgnoreCase() </p>
<p>用来检测俩个字符串是否相等（不区分大小写）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="string">"hello"</span>.equals(greeting);</span><br><span class="line"><span class="string">"HELLO"</span>.equalsIgnoreCase(<span class="string">"hello"</span>); <span class="comment">/* 不区分大小写 */</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>注意：</p>
<p><strong>不要用==运算符检测是否相等。</strong></p>
<p><strong>这个运算符只能够确定俩个字符串是否存放在同一个位置上。</strong>当然如果字符串存放在同一个位置上，它们必然相等，但是完全有可能把内容相同的多个字符串副本放置在不同的位置上。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String greeting=<span class="string">"Hello"</span>;</span><br><span class="line"><span class="keyword">if</span>(greeting ==<span class="string">"Hello"</span>)</span><br><span class="line">  -- <span class="keyword">true</span></span><br><span class="line"> <span class="keyword">if</span>(greeting.substring(<span class="number">0</span>,<span class="number">3</span>)==<span class="string">"Hel"</span>)</span><br><span class="line">  --<span class="keyword">false</span></span><br></pre></td></tr></table></figure>

<p>实际上只有字符串字面量共享，而+或者substring操作得到的字符串并不共享。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>JAVASE</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA中this和super的用法总结</title>
    <url>/2020/05/09/JAVA%E4%B8%ADthis%E5%92%8Csuper%E7%9A%84%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍这几天看到类在继承时会用到<strong>this</strong>和<strong>super</strong>，这里就做了一点总结，与各位共同交流，有错误请各位指正~</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p><strong>this</strong></p>
<p>this是自身的一个对象，代表对象本身，可以理解为：指向对象本身的一个指针。</p>
<h2 id="this的用法在java中大体可以分为3种："><a href="#this的用法在java中大体可以分为3种：" class="headerlink" title="this的用法在java中大体可以分为3种："></a>this的用法在java中大体可以分为3种：</h2><p><strong>1.普通的直接引用</strong></p>
<p>这种就不用讲了，this相当于是指向当前对象本身。</p>
<p><strong>2.形参与成员名字重名，用this来区分：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age = <span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"初始化年龄："</span>+age);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">GetAge</span><span class="params">(<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person Harry = <span class="keyword">new</span> Person();</span><br><span class="line">        System.out.println(<span class="string">"Harry's age is "</span>+Harry.GetAge(<span class="number">12</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果：</strong></p>
<p><strong>初始化年龄：10</strong><br><strong>Harry’s age is 12</strong></p>
<p>可以看到，这里age是GetAge成员方法的形参，this.age是Person类的成员变量。</p>
<p><strong>3.引用构造函数</strong></p>
<p>这个和super放在一起讲，见下面。</p>
<h2 id="super"><a href="#super" class="headerlink" title="super"></a><strong>super</strong></h2><p>super可以理解为是指向自己超（父）类对象的一个指针，而这个超类指的是离自己最近的一个父类。</p>
<h3 id="super也有三种用法："><a href="#super也有三种用法：" class="headerlink" title="super也有三种用法："></a>super也有三种用法：</h3><p>1.普通的直接引用</p>
<p>与this类似，super相当于是指向当前对象的父类，这样就可以用super.xxx来引用父类的成员。</p>
<p>2.子类中的成员变量或方法与父类中的成员变量或方法同名</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Country</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       name = <span class="string">"China"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">City</span> <span class="keyword">extends</span> <span class="title">Country</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    name = <span class="string">"Shanghai"</span>;</span><br><span class="line">    <span class="keyword">super</span>.value();      <span class="comment">//调用父类的方法</span></span><br><span class="line">    System.out.println(name);</span><br><span class="line">    System.out.println(<span class="keyword">super</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       City c=<span class="keyword">new</span> City();</span><br><span class="line">       c.value();</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果：</strong></p>
<p><strong>Shanghai</strong><br><strong>China</strong></p>
<p>可以看到，这里既调用了父类的方法，也调用了父类的变量。若不调用父类方法value()，只调用父类变量name的话，则父类name值为默认值null。</p>
<p>3.引用构造函数</p>
<p>super（参数）：调用父类中的某一个构造函数（应该为构造函数中的第一条语句）。</p>
<p>this（参数）：调用本类中另一种形式的构造函数（应该为构造函数中的第一条语句）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prt</span><span class="params">(String s)</span> </span>&#123; </span><br><span class="line">       System.out.println(s); </span><br><span class="line">    &#125; </span><br><span class="line">   </span><br><span class="line">    Person() &#123; </span><br><span class="line">       prt(<span class="string">"父类·无参数构造方法： "</span>+<span class="string">"A Person."</span>); </span><br><span class="line">    &#125;<span class="comment">//构造方法(1) </span></span><br><span class="line">    </span><br><span class="line">    Person(String name) &#123; </span><br><span class="line">       prt(<span class="string">"父类·含一个参数的构造方法： "</span>+<span class="string">"A person's name is "</span> + name); </span><br><span class="line">    &#125;<span class="comment">//构造方法(2) </span></span><br><span class="line">&#125; </span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Chinese</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123; </span><br><span class="line">    Chinese() &#123; </span><br><span class="line">       <span class="keyword">super</span>(); <span class="comment">// 调用父类构造方法（1） </span></span><br><span class="line">       prt(<span class="string">"子类·调用父类”无参数构造方法“： "</span>+<span class="string">"A chinese coder."</span>); </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    Chinese(String name) &#123; </span><br><span class="line">       <span class="keyword">super</span>(name);<span class="comment">// 调用父类具有相同形参的构造方法（2） </span></span><br><span class="line">       prt(<span class="string">"子类·调用父类”含一个参数的构造方法“： "</span>+<span class="string">"his name is "</span> + name); </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    Chinese(String name, <span class="keyword">int</span> age) &#123; </span><br><span class="line">       <span class="keyword">this</span>(name);<span class="comment">// 调用具有相同形参的构造方法（3） </span></span><br><span class="line">       prt(<span class="string">"子类：调用子类具有相同形参的构造方法：his age is "</span> + age); </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">       Chinese cn = <span class="keyword">new</span> Chinese(); </span><br><span class="line">       cn = <span class="keyword">new</span> Chinese(<span class="string">"codersai"</span>); </span><br><span class="line">       cn = <span class="keyword">new</span> Chinese(<span class="string">"codersai"</span>, <span class="number">18</span>); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果：</strong></p>
<p><strong>父类·无参数构造方法： A Person.</strong><br><strong>子类·调用父类”无参数构造方法“： A chinese coder.</strong><br><strong>父类·含一个参数的构造方法： A person’s name is codersai</strong><br><strong>子类·调用父类”含一个参数的构造方法“： his name is codersai</strong><br><strong>父类·含一个参数的构造方法： A person’s name is codersai</strong><br><strong>子类·调用父类”含一个参数的构造方法“： his name is codersai</strong><br><strong>子类：调用子类具有相同形参的构造方法：his age is 18</strong></p>
<p>从本例可以看到，可以用super和this分别调用父类的构造方法和本类中其他形式的构造方法。</p>
<p>例子中Chinese类第三种构造方法调用的是本类中第二种构造方法，而第二种构造方法是调用父类的，因此也要先调用父类的构造方法，再调用本类中第二种，最后是重写第三种构造方法。</p>
<p><strong>super和this的异同：</strong></p>
<ul>
<li>super（参数）：调用基类中的某一个构造函数（应该为构造函数中的第一条语句） </li>
<li>this（参数）：调用本类中另一种形成的构造函数（应该为构造函数中的第一条语句）</li>
<li>super:　它引用当前对象的直接父类中的成员（用来访问直接父类中被隐藏的父类中成员数据或函数，基类与派生类中有相同成员定义时如：super.变量名  super.成员函数据名（实参）</li>
<li>this：它代表当前对象名（在程序中易产生二义性之处，应使用this来指明当前对象；如果函数的形参与类中的成员数据同名，这时需用this来指明成员变量名）</li>
<li>调用super()必须写在子类构造方法的第一行，否则编译不通过。每个子类构造方法的第一条语句，都是隐含地调用super()，如果父类没有这种形式的构造函数，那么在编译的时候就会报错。</li>
<li>super()和this()类似,区别是，super()从子类中调用父类的构造方法，this()在同一类内调用其它方法。</li>
<li>super()和this()均需放在构造方法内第一行。</li>
<li>尽管可以用this调用一个构造器，但却不能调用两个。</li>
<li>this和super不能同时出现在一个构造函数里面，因为this必然会调用其它的构造函数，其它的构造函数必然也会有super语句的存在，所以在同一个构造函数里面有相同的语句，就失去了语句的意义，编译器也不会通过。</li>
<li>this()和super()都指的是对象，所以，均不可以在static环境中使用。包括：static变量,static方法，static语句块。</li>
<li>从本质上讲，this是一个指向本对象的指针, 然而super是一个Java关键字。</li>
</ul>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>JAVASE</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA中的输入与输出</title>
    <url>/2020/05/06/JAVA%E4%B8%AD%E7%9A%84%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA/</url>
    <content><![CDATA[<h1 id="JAVA中的输入"><a href="#JAVA中的输入" class="headerlink" title="JAVA中的输入"></a>JAVA中的输入</h1><h2 id="读取输入"><a href="#读取输入" class="headerlink" title="读取输入"></a>读取输入</h2><p>  要想通过输入台进行输入，首先需要构造一个与“标准输入流”System.in关联的Scanner对象。<br>  <a id="more"></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Scanner scanner=<span class="keyword">new</span> Scanner(System.in);</span><br></pre></td></tr></table></figure>

<p>Scanner类中的方法：</p>
<p>API  JAVA.util.Scanner</p>
<table>
<thead>
<tr>
<th>String nextLine()</th>
<th>读取输入的下一行内容  以enter作为结束符  能得到带空格的字符串</th>
</tr>
</thead>
<tbody><tr>
<td>String next()</td>
<td>读取输入的下一个单词（以空格作为分隔符）空格视而不见</td>
</tr>
<tr>
<td>int nextInt()</td>
<td>只读取int值</td>
</tr>
<tr>
<td>double nextDouble()</td>
<td>只读取double值</td>
</tr>
<tr>
<td>boolean hasNext()</td>
<td>检测输入中是否还有其他的单词</td>
</tr>
<tr>
<td>boolean hasNextInt()</td>
<td>检测输入中是否还有表示整数</td>
</tr>
<tr>
<td>boolean hasNextDouble()</td>
<td>检测输入中是否还有表示浮点数</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>JAVASE</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA内存区域与内存溢出异常</title>
    <url>/2020/05/15/JAVA%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍JAVA内存区域与内存溢出异常</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>类文件(<code>.class</code>文件扩展名)是包含Java字节码 <code>ByteCode</code>的文件，可以在Java虚拟机上执行，每个类文件包含了一个类，接口或者模块（Java 9）的定义.Java程序（<code>.java</code> 文件）可以通过 Java compiler 生成字节码文件，其他基于JVM的语言也都可以通过自己的编译器生成字节码文件，例如Scala，Groovy等JVM是与平台无关的，类文件可以在多个平台上执行，这使得相应的语言也与平台无关.</p>
<h2 id="JVM的内存布局"><a href="#JVM的内存布局" class="headerlink" title="JVM的内存布局"></a>JVM的内存布局</h2><p>虚拟机中，Java 内存区域可以划分为 6 个部分，程序计数器、虚拟机栈、本地方法栈（以上三个是线程私有的）、堆和方法区（里面有常量池，方法区与堆是线程共享的 )、直接内存（不受 JVM GC 管理）。除了直接内存，其他都是运行时数据区。</p>
<p><img src="https://photos.alitaalice.cn/image/20200517164736.png" alt=""></p>
<h2 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h2><p><img src="https://photos.alitaalice.cn/image/20200517165000.png" alt=""></p>
<p><img src="https://photos.alitaalice.cn/image/20200517165050.png" alt=""></p>
<h2 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h2><p><img src="https://photos.alitaalice.cn/image/20200517164220.png" alt=""></p>
<p><img src="https://photos.alitaalice.cn/image/20200517165147.png" alt=""></p>
<p><img src="https://photos.alitaalice.cn/image/20200517165221.png" alt=""></p>
<p><img src="https://photos.alitaalice.cn/image/20200517165249.png" alt=""></p>
<p><img src="https://photos.alitaalice.cn/image/20200517165303.png" alt=""></p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA和C++的区别</title>
    <url>/2020/05/11/JAVA%E5%92%8CC++%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍JAVA和C++的区别</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h2 id="JAVA和C-的区别"><a href="#JAVA和C-的区别" class="headerlink" title="JAVA和C++的区别"></a>JAVA和C++的区别</h2><ul>
<li>都是面向对象的语言，并且都支持封装，继承和多态</li>
<li>指针：JAVA不提供指针来直接访问内存，程序更加安全。</li>
<li>继承：JAVA中的类是单继承的，但是C++允许多继承，JAVA中允许一个类实现多个接口来实现C++中的多冲继承。</li>
<li>内存：JAVA有自动内存管理机制，不需要程序员手动释放无用内存。</li>
</ul>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>JAVASE</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA多态</title>
    <url>/2020/05/06/JAVA%E5%A4%9A%E6%80%81/</url>
    <content><![CDATA[<h1 id="JAVA多态"><a href="#JAVA多态" class="headerlink" title="JAVA多态"></a>JAVA多态</h1><p>JAVA的三大特性为：</p>
<ul>
<li><p>封装</p>
</li>
<li><p>继承</p>
</li>
<li><p>多态</p>
<p>今天我们就来说一说到底什么是多态，以及多态到底有什么用。</p>
<a id="more"></a>

<h2 id="多态的定义"><a href="#多态的定义" class="headerlink" title="多态的定义"></a>多态的定义</h2><p>定义： <strong>事物的不同形态。</strong>多态多应用在向上转型。</p>
<p>多态的用处：在实际开发中，如果发现某个类的方法可以做出改进，但工程已经交付给用户使用，但是不想影响其他部分对于该方法的调用。那么通过创建子类对象，对于父类方法进行<strong>重写</strong>（Override）。<strong>但是此时父类的其他成员方法和成员属性却不能进行利用</strong>。此时就需要用到<strong>向上转型</strong>，将子类向上转换为父类，此时程序的相应方法做出了改进，程序的其他地方也不会受此影响。</p>
</li>
</ul>
<h2 id="多态的三个前提："><a href="#多态的三个前提：" class="headerlink" title="多态的三个前提："></a>多态的三个前提：</h2><ul>
<li><p>存在继承关系，子类继承父类</p>
</li>
<li><p>子类要重写父类的方法 </p>
<p>子类重写父类的成员方法。</p>
</li>
<li><p>父类数据类型的引用要指向子类对象 （向上转型）</p>
<p>如 Animal am=new Cat();</p>
<h2 id="多态的弊端"><a href="#多态的弊端" class="headerlink" title="多态的弊端"></a>多态的弊端</h2><p>向上转型之后，<strong>不能够引用子类特有的成员属性和子类特有的成员方法</strong>。</p>
</li>
</ul>
<p>  <strong>注意：静态方法不能被重写，所以也不存在多态，即使向上转型，子类重写了父类的静态方法，子类调用父类的静态方法，输出依然是父类静态方法中的值。</strong></p>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>JAVASE</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA容器分类andCollection</title>
    <url>/2020/05/06/JAVA%E5%AE%B9%E5%99%A8%E5%88%86%E7%B1%BBandCollection/</url>
    <content><![CDATA[<h2 id="Java容器可分为两大类："><a href="#Java容器可分为两大类：" class="headerlink" title="Java容器可分为两大类："></a>Java容器可分为两大类：</h2><ul>
<li><p>Collection接口 继承JAVA.lang.Object</p>
<ul>
<li>List接口<ul>
<li><strong>ArrayList</strong></li>
<li>LinkedList<a id="more"></a></li>
<li>Vector(了解，已过时)</li>
</ul>
</li>
<li>Set接口<ul>
<li>HashSet<ul>
<li>LinkedHashSet</li>
</ul>
</li>
<li>TreeSet</li>
</ul>
</li>
</ul>
</li>
<li><p>Map接口  继承JAVA.lang.Object</p>
<ul>
<li><p><strong>HashMap</strong></p>
<ul>
<li>LinkedHashMap</li>
</ul>
</li>
<li><p>TreeMap</p>
</li>
<li><p>ConcurrentHashMap</p>
</li>
<li><p>Hashtable(了解，，已过时)</p>
</li>
</ul>
</li>
</ul>
<h2 id="Collection接口："><a href="#Collection接口：" class="headerlink" title="Collection接口："></a>Collection接口：</h2><ul>
<li><p>Collection接口的常用方法</p>
</li>
<li><p>添加功能</p>
<ul>
<li><table>
<thead>
<tr>
<th>boolean add(Object obj)</th>
<th>添加一个元素</th>
</tr>
</thead>
<tbody><tr>
<td>boolean  addAll(Collection c)</td>
<td>添加一个集合的元素</td>
</tr>
</tbody></table>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">static</span> Collection c = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"add:"</span>+c.add(<span class="string">"hello"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/* 输出为 add:true */</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<p>​             </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> Collection c1 = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    <span class="keyword">static</span> Collection c2 = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        c1.add(<span class="string">"xxxx"</span>);</span><br><span class="line">        System.out.println(<span class="string">"add:"</span> + c1.add(<span class="string">"hello"</span>));</span><br><span class="line">        System.out.println(<span class="string">"addAll:"</span> + c2.addAll(c1));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/* 输出add:true</span></span><br><span class="line"><span class="comment">addAll:true */</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>删除功能</p>
<ul>
<li><table>
<thead>
<tr>
<th>void clear()</th>
<th>移除所有元素</th>
</tr>
</thead>
<tbody><tr>
<td>boolean remove(Object o)</td>
<td>移除一个元素</td>
</tr>
<tr>
<td>boolean removeAll(Object o)</td>
<td>移除一个集合的所有元素</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>判断功能</p>
<ul>
<li><table>
<thead>
<tr>
<th>boolean contains(Object o)</th>
<th>判断集合中是否包含指定的元素</th>
</tr>
</thead>
<tbody><tr>
<td>boolean containsAll(Object o)</td>
<td>判断集合中是否包含指定的集合元素（一个集合中的所有元素</td>
</tr>
<tr>
<td>boolean isEmpty()</td>
<td>判断集合是否为空</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p><strong>获取功能</strong></p>
<p>重点：迭代器（Iterator） 下一篇中我们详细解释。</p>
<p>itetator()   返回在此 Collection 的元素上进行迭代的迭代器。用于遍历集合中的对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Muster</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Collection&lt;String&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">"a"</span>);</span><br><span class="line">        list.add(<span class="string">"b"</span>);</span><br><span class="line">        list.add(<span class="string">"c"</span>);</span><br><span class="line">        Iterator&lt;String&gt; it=list.iterator();</span><br><span class="line">        <span class="keyword">while</span>(it.hasNext())</span><br><span class="line">        &#123;</span><br><span class="line">            String str=(String) it.next();</span><br><span class="line">            System.out.println(str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>JAVA集合</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA注解</title>
    <url>/2020/05/11/JAVA%E6%B3%A8%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍 JAVA注解</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h2 id="1-注解的概述"><a href="#1-注解的概述" class="headerlink" title="1.注解的概述"></a>1.注解的概述</h2><p>注解的语法： @注解名称</p>
<p>注解的作用:  替代xml配置文件</p>
<p>我们以前总是要写一些配置文件，如web.xml 里面要写<servlet> 和<sevlet-mapping></p>
<p>tomcat用来读取配置文件</p>
<p>而在servlet3.0中可以使用注解来代替配置文件，@WebServlet 用来代替该配置文件</p>
<h2 id="2-JAVA中的注解"><a href="#2-JAVA中的注解" class="headerlink" title="2. JAVA中的注解"></a>2. JAVA中的注解</h2><ul>
<li>@Override</li>
<li>@Deprecated: 作用在方法上，标记该方法为作废方法 （已经过时的方法）</li>
<li>@SuppressWarning :作用在方法上，压制警告@SuppressWarnings(“all”)压制所有警告</li>
</ul>
<h2 id="3-注解的使用"><a href="#3-注解的使用" class="headerlink" title="3. 注解的使用"></a>3. 注解的使用</h2><ul>
<li>定义注解类：框架的工作</li>
<li>使用注解类：我们的工作</li>
<li>读取注解（反射）：框架的工作</li>
</ul>
<h2 id="4-自定义注解类"><a href="#4-自定义注解类" class="headerlink" title="4.自定义注解类"></a>4.自定义注解类</h2><p><strong>@interface</strong></p>
<p>eg:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnn&#123;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-使用注解的目标"><a href="#5-使用注解的目标" class="headerlink" title="5.使用注解的目标"></a>5.使用注解的目标</h2><p>注解可以使用在类（接口或者枚举），属性，方法，构造器，包，参数，局部变量</p>
<p>eg:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@MyAnn</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="meta">@MyAnn</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> a;</span><br><span class="line"><span class="meta">@MyAnn</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyClass</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;&#125;</span><br><span class="line"><span class="meta">@MyAnn</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;&#125;</span><br><span class="line"><span class="meta">@MyAnn</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun2</span><span class="params">(@MyAnn String s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="meta">@MyAnn</span></span><br><span class="line">    <span class="keyword">int</span> n=<span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-注解的属性"><a href="#6-注解的属性" class="headerlink" title="6.注解的属性"></a>6.注解的属性</h2><p>定义注解时，也可以给出属性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnn</span><br><span class="line">&#123;</span><br><span class="line"><span class="function">String <span class="title">value</span><span class="params">()</span></span>;  <span class="keyword">default</span> <span class="string">"hello world"</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">value1</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中value就是属性，你可能会说value是一个方法，没错，它是一个方法，但是我们非要称之为属性，是因为把它当作属性更好理解:</p>
<p>eg:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@MyAnn</span>(value1=<span class="number">100</span>,value=<span class="string">"hello"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></span><br><span class="line"><span class="class"></span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>注解的属性后面要有一对圆括号，而且圆括号内不能给出东西。就像是无参的方法一样；<br>注解的属性类型只能是：基本类型、String、Enum、Class、注解类型、以上类型的一维数组类型；<br>注解的属性可以有默认值，例如：int a() default 100;<br>数组的属性默认值：int[] arr() default {1,2,3}，这里不能使用new int[]{1,2,3}<br>使用注解时，在给数组属性赋值时的格式：@MyAnn(arr={1,2,3})；</li>
</ul>
<h2 id="7-元注解"><a href="#7-元注解" class="headerlink" title="7.元注解"></a>7.元注解</h2><p><strong>元注解：用于描述注解的注解</strong></p>
<p>@Target ：描述注解作用的位置</p>
<ul>
<li>ElementType取值：</li>
<li>TYPE：作用在类上</li>
<li>METHOD ：作用在方法上</li>
<li>FIELD ：作用在成员变量上</li>
</ul>
<p>eg：</p>
<p>Target 注解的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Target &#123;  </span><br><span class="line">    ElementType[] value();  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> ElementType &#123;  </span><br><span class="line">  TYPE,FIELD,METHOD,PARAMETED,CONSTRUCTOR,LOCAL_VARIABLE,ANNOCATION_TYPE,PACKAGE  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在定义注解时，可以使用@Target 注解来限制注解的作用目标</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE,ElementType.METHOD&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnn</span><br><span class="line">&#123;&#125;  <span class="comment">/* 该注解定义在类和方法上 */</span></span><br><span class="line"><span class="meta">@MyAnn</span>()  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;  </span><br><span class="line">    <span class="meta">@MyAnn</span>()  <span class="comment">//报错  </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a;  </span><br><span class="line">      </span><br><span class="line">    <span class="meta">@MyAnn</span>()  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123;&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-注解的保留策略"><a href="#8-注解的保留策略" class="headerlink" title="8.注解的保留策略"></a>8.注解的保留策略</h2><ul>
<li><p>注解的保留策略是指</p>
<ul>
<li>注解保留在源代码（SOURCE)上</li>
<li>注解保留在class文件上（CLASS）</li>
<li>注解保留在类运行时（RUNTIME），可以被类加载器加载到内存中</li>
</ul>
</li>
<li><p>如果希望注解被反射，那么注解就是保留到运行时，而不是源代码或者类文件上</p>
</li>
<li><p>指定注解的保留策略需要使用元注解@Retention ，它有一个value属性，类型为RetentionPolicy</p>
<p>RetentionPolicy是枚举类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Retention &#123;  </span><br><span class="line">    <span class="function">RetentionPolicy <span class="title">value</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> RetentionPolicy &#123;  </span><br><span class="line">    SOURCE, CLASS, RUNTIME  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>eg：指定注解保留到运行时</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetionOPlicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE,ElementType.METHOD&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnn</span><br><span class="line">&#123;</span><br><span class="line"><span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> "hello"</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">value1</span><span class="params">()</span> <span class="keyword">default</span> 100</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="9-注解处理器"><a href="#9-注解处理器" class="headerlink" title="9.注解处理器"></a>9.注解处理器</h2>]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>JAVASE</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA源码问题</title>
    <url>/2020/05/14/JAVA%E6%BA%90%E7%A0%81%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍JAVA源码问题</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h2 id="说说常见的集合有哪些吧？"><a href="#说说常见的集合有哪些吧？" class="headerlink" title="说说常见的集合有哪些吧？"></a>说说常见的集合有哪些吧？</h2><p>答：Map 接口和 Collection 接口是所有集合框架的父接口：</p>
<ol>
<li>Collection 接口的子接口包括：Set 接口和 List 接口；</li>
<li>Map 接口的实现类主要有：HashMap、TreeMap、Hashtable、ConcurrentHashMap 以及 Properties 等；</li>
<li>Set 接口的实现类主要有：HashSet、TreeSet、LinkedHashSet 等；</li>
<li>List 接口的实现类主要有：ArrayList、LinkedList、Stack 以及 Vector 等。</li>
</ol>
<h3 id="当两个对象的hashcode相同时会发生什么，如何获取对象？"><a href="#当两个对象的hashcode相同时会发生什么，如何获取对象？" class="headerlink" title="当两个对象的hashcode相同时会发生什么，如何获取对象？"></a>当两个对象的hashcode相同时会发生什么，如何获取对象？</h3><p>因为hashcode相同，所以它们的bucket位置相同，‘碰撞’会发生。</p>
<p>两个对象的hashCode相同所以它们的bucket位置相同，找到bucket位置之后，会调用keys.equals()方法去找到链表中正确的节点 <strong><code>(key != null &amp;&amp; key.equals(k)</code></strong>。</p>
<p>因为HashMap使用链表存储对象，这个Entry(包含有键值对的Map.Entry对象)会存储在链表中。这个时候要理解根据hashcode来划分的数组，如果数组的坐标相同，则进入链表这个数据结构中了，一般的添加都在最前面，也就是和数组下标直接相连的地方，链表长度到达8的时候，jdk1.8上升为红黑树。</p>
<h3 id="HashMap的大小超过了负载因子-load-factor-定义的容量，怎么办"><a href="#HashMap的大小超过了负载因子-load-factor-定义的容量，怎么办" class="headerlink" title="HashMap的大小超过了负载因子(load factor)定义的容量，怎么办"></a>HashMap的大小超过了负载因子(load factor)定义的容量，怎么办</h3><p>会调用<strong><code>resize()</code></strong>进行数组扩容。</p>
<h2 id="HashMap中的tableSizeFor方法"><a href="#HashMap中的tableSizeFor方法" class="headerlink" title="HashMap中的tableSizeFor方法"></a>HashMap中的tableSizeFor方法</h2><p>在使用指定数组的初始容量时上面说过，数组容量必须是2的次方。所以就需要通过算法将我们给定的数值转换成2的次方。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这个方法可以将任意一个整数转换成2的次方。</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="HashMap是线程安全的吗，为什么"><a href="#HashMap是线程安全的吗，为什么" class="headerlink" title="HashMap是线程安全的吗，为什么"></a>HashMap是线程安全的吗，为什么</h2><p>HashMap底层是一个Entry数组，当发生hash冲突的时候，hashmap是采用链表的方式来解决的，在对应的数组位置存放链表的头结点。对链表而言，新加入的节点会从头结点加入。</p>
<p>1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">	Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">        table[bucketIndex] = <span class="keyword">new</span> Entry&lt;K,V&gt;(hash, key, value, e);</span><br><span class="line">        <span class="keyword">if</span> (size++ &gt;= threshold)</span><br><span class="line">            resize(<span class="number">2</span> * table.length);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在hashmap做put操作的时候会调用到以上的方法。现在假如A线程和B线程同时对同一个数组位置调用addEntry，两个线程会同时得到现在的头结点，然后A写入新的头结点之后，B也写入新的头结点，那B的写入操作就会覆盖A的写入操作造成A的写入操作丢失</p>
<p>2</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">removeEntryForKey</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> hash = (key == <span class="keyword">null</span>) ? <span class="number">0</span> : hash(key.hashCode());</span><br><span class="line">        <span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line">        Entry&lt;K,V&gt; prev = table[i];</span><br><span class="line">        Entry&lt;K,V&gt; e = prev;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">            Object k;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                modCount++;</span><br><span class="line">                size--;</span><br><span class="line">                <span class="keyword">if</span> (prev == e)</span><br><span class="line">                    table[i] = next;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    prev.next = next;</span><br><span class="line">                e.recordRemoval(<span class="keyword">this</span>);</span><br><span class="line">                <span class="keyword">return</span> e;</span><br><span class="line">            &#125;</span><br><span class="line">            prev = e;</span><br><span class="line">            e = next;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>删除键值对的代码如上：</p>
<p>当多个线程同时操作同一个数组位置的时候，也都会先取得现在状态下该位置存储的头结点，然后各自去进行计算操作，之后再把结果写会到该数组位置去，其实写回的时候可能其他的线程已经就把这个位置给修改过了，就会覆盖其他线程的修改</p>
<p>3、addEntry中当加入新的键值对后键值对总数量超过门限值的时候会调用一个resize操作，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;</span><br><span class="line">        Entry[] oldTable = table;</span><br><span class="line">        <span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line">        <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];</span><br><span class="line">        transfer(newTable);</span><br><span class="line">        table = newTable;</span><br><span class="line">        threshold = (<span class="keyword">int</span>)(newCapacity * loadFactor);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这个操作会新生成一个新的容量的数组，然后对原数组的所有键值对重新进行计算和写入新的数组，之后指向新生成的数组。</p>
<p>当多个线程同时检测到总数量超过门限值的时候就会同时调用resize操作，各自生成新的数组并rehash后赋给该map底层的数组table，结果最终只有最后一个线程生成的新数组被赋给table变量，其他线程的均会丢失。而且当某些线程已经完成赋值而其他线程刚开始的时候，就会用已经被赋值的table作为原始数组，这样也会有问题。</p>
<h2 id="哪些是线程安全的容器"><a href="#哪些是线程安全的容器" class="headerlink" title="哪些是线程安全的容器"></a>哪些是线程安全的容器</h2><p>同步容器类：</p>
<p>使用了synchronized<br>1.Vector<br>2.HashTable</p>
<p>并发容器：<br>3.ConcurrentHashMap:分段<br>4.CopyOnWriteArrayList：写时复制<br>5.CopyOnWriteArraySet：写时复制</p>
<h3 id="Hashtable和HashMap的区别"><a href="#Hashtable和HashMap的区别" class="headerlink" title="Hashtable和HashMap的区别"></a>Hashtable和HashMap的区别</h3><h3 id="HashMap多线程处理之快速失败机制"><a href="#HashMap多线程处理之快速失败机制" class="headerlink" title="HashMap多线程处理之快速失败机制"></a>HashMap多线程处理之快速失败机制</h3><h3 id="jdk7和jdk8的HashMap实现的区别"><a href="#jdk7和jdk8的HashMap实现的区别" class="headerlink" title="jdk7和jdk8的HashMap实现的区别"></a>jdk7和jdk8的HashMap实现的区别</h3><h3 id="HashMap与LinkedHashMap和TreeMap的区别"><a href="#HashMap与LinkedHashMap和TreeMap的区别" class="headerlink" title="HashMap与LinkedHashMap和TreeMap的区别"></a>HashMap与LinkedHashMap和TreeMap的区别</h3>]]></content>
      <categories>
        <category>JAVA源码</category>
      </categories>
      <tags>
        <tag>JAVA源码</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA的静态方法不能被重写</title>
    <url>/2020/05/06/JAVA%E7%9A%84%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E4%B8%8D%E8%83%BD%E8%A2%AB%E9%87%8D%E5%86%99/</url>
    <content><![CDATA[<h1 id="JAVA的静态方法不能被重写"><a href="#JAVA的静态方法不能被重写" class="headerlink" title="JAVA的静态方法不能被重写"></a>JAVA的静态方法不能被重写</h1><p>堆区：</p>
<ul>
<li>存储的全部都是对象，每个对象都包含一个与之对应的class信息。<a id="more"></a>

</li>
</ul>
<p>栈区:</p>
<p>方法区：</p>
<ul>
<li>方法区包含所有的class和static变量  class可以直接调用static</li>
</ul>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>JAVASE</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA面试</title>
    <url>/2020/05/11/JAVA%E9%9D%A2%E8%AF%95/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p><img src="E:%5Cdev%5CMYBLOG%5Cblog%5Csource_posts%5CJAVA%E9%9D%A2%E8%AF%95%5C2020-05-11_205422.png" alt=""></p>
]]></content>
  </entry>
  <entry>
    <title>JAVA编译和运行的过程</title>
    <url>/2020/05/11/JAVA%E7%BC%96%E8%AF%91%E5%92%8C%E8%BF%90%E8%A1%8C%E7%9A%84%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍JAVA编译和运行的过程</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><ul>
<li><p>JAVA程序源码 </p>
</li>
<li><p>——-&gt; JAVA字节码（经过编译器编译)</p>
</li>
<li><p>——-&gt;JVM （对字节码进行解释和运行）</p>
<p>编译只进行一次，但是解释在每次运行程序时都会运行，编译的字节码采用一种针对JVM优化过度机器码的形式进行保存</p>
</li>
<li><p>——&gt;机器码（虚拟机将字节码解释为机器码，在计算机上运行）</p>
<p><img src="Screenshot.png" alt=""></p>
</li>
</ul>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>JAVASE</tag>
      </tags>
  </entry>
  <entry>
    <title>JDK和JRE</title>
    <url>/2020/05/09/JDK%E5%92%8CJRE/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍JDK和JRE的区别，他们的作用分别是什么？</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h2 id="JDK"><a href="#JDK" class="headerlink" title="JDK"></a>JDK</h2><p>JDK是JAVA Development Kit (JAVA开发套件) ，是JAVA的开发工具包。主要包含了类库和工具。</p>
<p>JDK中包含了JRE 而且在JDK安装目录/JRE/bin/server 文件夹下包含jvm.dll</p>
<p><img src="QQ20200509115538.png" alt=""></p>
<p>这说明JDK提供了一个虚拟机。</p>
<p>另外JDK的bin目录下有各种JAVA程序需要用到的命令。</p>
<p>与JRE明显的区别就饿死JDK文件下才会有javac</p>
<p><img src="QQ20200509115836.png" alt=""></p>
<p>因为JRE只是一个运行环境，与开发无关。</p>
<h2 id="JRE"><a href="#JRE" class="headerlink" title="JRE"></a>JRE</h2><p>JRE是JAVA Runtime Environment的缩写。是JAVA程序的运行环境。既然是运行，那么当然要包含JVM,也就是JAVA虚拟机，还有所有JAVA类库的class文件，都在lib下，并且被打包成了jar </p>
<p><img src="Screenshot.png" alt=""></p>
<h2 id="问题：jdk里的jre与外面jre的区别"><a href="#问题：jdk里的jre与外面jre的区别" class="headerlink" title="问题：jdk里的jre与外面jre的区别"></a>问题：jdk里的jre与外面jre的区别</h2><p>分析：如果我们安装了JDK，那么我们的电脑中将会有C:\Program Files (x86)\Java\jdk1.8.0_05文件夹 ，这个文件夹里面有一个jre文件夹。然后我们再安装jre，此时我们的电脑中有C:\Program Files (x86)\Java\jre8文件夹。</p>
<p>通过对比jre和jre8文件夹中的东西，我们发现基本是一样的，那么这俩文件夹到底有啥区别呢？</p>
<p>我们暂且称jre为自带jdk-jre，jre8为公共jre。</p>
<p>jdk-jre与公共jre的主要区别在于jdk-jre多了一个server的vm执行选项。</p>
<p>sever与client使用不同的vm虚拟机。如果电脑运行一个java程序的时候，会自动调用client vm。但是如果开发java程序时使用的就是server vm（server vm启动时间较长，占用内存较多，但是启动后执行性能更高，适合开发）。</p>
<p><strong>换句话说：公共jre是给普通电脑用户使用的，假如你安装了一个java程序，这个java程序启动运行的时候就会调用jre（java runtime environment）；如果你是一个java开发者，那么你就需要安装jdk（java development kit），这时你开发调试java程序的时候就会调用jdk里面的jre。</strong></p>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>JAVASE</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA泛型</title>
    <url>/2020/05/12/JAVA%E6%B3%9B%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2>]]></content>
  </entry>
  <entry>
    <title>JVM内存模型概述</title>
    <url>/2020/05/20/JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍JVM内存模型概述</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>转<a href="https://blog.csdn.net/justloveyou_/article/details/71189093" target="_blank" rel="noopener">https://blog.csdn.net/justloveyou_/article/details/71189093</a></p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Java值传递和引用传递基础分析</title>
    <url>/2020/05/11/Java%E5%80%BC%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92%E5%9F%BA%E7%A1%80%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍JAVA的值传递和引用传递</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h2 id="java内的基础类型数据传递都是值传递-java中实例对象的传递是引用传递。"><a href="#java内的基础类型数据传递都是值传递-java中实例对象的传递是引用传递。" class="headerlink" title="java内的基础类型数据传递都是值传递. java中实例对象的传递是引用传递。"></a>java内的基础类型数据传递都是值传递. java中实例对象的传递是引用传递。</h2><p><strong>值传递是对基本型变量而言的,传递的是该变量的一个副本,改变副本不影响原变量。引用传递一般是对于对象型变量而言的,传递的是该对象地址的一个副本, 并不是原对象本身 。</strong></p>
<p>首先，不要纠结于 Pass By Value 和 Pass By Reference 的字面上的意义，否则很容易陷入所谓的“一切传引用其实本质上是传值”这种并不能解决问题无意义论战中。<br>更何况，要想知道Java到底是传值还是传引用，起码你要先知道传值和传引用的准确含义吧？可是如果你已经知道了这两个名字的准确含义，那么你自己就能判断Java到底是传值还是传引用。</p>
<h2 id="一：搞清楚-基本类型-和-引用类型的不同之处"><a href="#一：搞清楚-基本类型-和-引用类型的不同之处" class="headerlink" title="一：搞清楚 基本类型 和 引用类型的不同之处"></a>一：搞清楚 基本类型 和 引用类型的不同之处</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line">String str = <span class="string">"hello"</span>;</span><br></pre></td></tr></table></figure>

<p><img src="2020-05-12_112353.png" alt=""></p>
<p>如图所示，num是基本类型，值就直接保存在变量中。而str是引用类型，变量中保存的只是实际对象的地址。一般称这种变量为”引用”，引用指向实际对象，实际对象中保存着内容。</p>
<p>二：搞清楚赋值运算符（=）的作用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">num &#x3D; 20;</span><br><span class="line">str &#x3D; &quot;java&quot;;</span><br></pre></td></tr></table></figure>

<p>对于基本类型 num ，赋值运算符会直接改变变量的值，原来的值被覆盖掉。<br>对于引用类型 str，赋值运算符会改变引用中所保存的地址，原来的地址被覆盖掉。但是原来的对象不会被改变（重要）。<br>如上图所示，”hello” 字符串对象没有被改变。（没有被任何引用所指向的对象是垃圾，会被垃圾回收器回收）</p>
<p><img src="2020-05-12_112409.png" alt=""></p>
<h2 id="三：调用方法时发生了什么？参数传递基本上就是赋值操作"><a href="#三：调用方法时发生了什么？参数传递基本上就是赋值操作" class="headerlink" title="三：调用方法时发生了什么？参数传递基本上就是赋值操作"></a>三：调用方法时发生了什么？参数传递基本上就是赋值操作</h2><p>第一个例子：基本类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    value = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">foo(num); <span class="comment">// num 没有被改变</span></span><br></pre></td></tr></table></figure>

<p>第二个例子：没有提供改变自身方法的引用类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(String text)</span> </span>&#123;</span><br><span class="line">    text = <span class="string">"windows"</span>;  <span class="comment">//String没改变是因为赋值新的字符串直接导致新new了一个String</span></span><br><span class="line">&#125;</span><br><span class="line">foo(str); <span class="comment">// str 也没有被改变</span></span><br></pre></td></tr></table></figure>

<p>第三个例子：提供改变自身方法的引用类型</p>
<p>builder的引用对象也是StringBuilder</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="string">"iphone"</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(StringBuilder builder)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    builder.append(<span class="string">"4"</span>); <span class="comment">//没有生成新的stringBuilder对象</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">foo(sb); <span class="comment">// sb 被改变了，变成了"iphone4"。</span></span><br></pre></td></tr></table></figure>

<p>第四个例子：提供了改变自身方法的引用类型，但是不使用，而是使用赋值运算符。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="string">"iphone"</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(StringBuilder builder)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    builder = <span class="keyword">new</span> StringBuilder(<span class="string">"ipad"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(sb); <span class="comment">// sb 没有被改变，还是 "iphone"。</span></span><br></pre></td></tr></table></figure>

<p>重点理解为什么，第三个例子和第四个例子结果不同？</p>
<p>下面是第三个例子的图解：</p>
<p><img src="2020-05-12_112424.png" alt=""></p>
<p>builder = new StringBuilder(“ipad”); 之后</p>
<p><img src="2020-05-12_112435.png" alt=""></p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>JAVASE</tag>
      </tags>
  </entry>
  <entry>
    <title>List接口</title>
    <url>/2020/05/07/List%E6%8E%A5%E5%8F%A3/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>List集合包括List接口和List接口所有的实现类</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h2 id="List接口定义的方法"><a href="#List接口定义的方法" class="headerlink" title="List接口定义的方法"></a>List接口定义的方法</h2><p>除了继承Collection外，List接口还有俩个重要的方法。</p>
<table>
<thead>
<tr>
<th>get(int index)</th>
<th>获得指定索引位置的元素</th>
</tr>
</thead>
<tbody><tr>
<td>set(int index,Object obj)</td>
<td>将集合中指定索引位置的对象修改为指定的对象</td>
</tr>
</tbody></table>
<h2 id="List接口的实现类"><a href="#List接口的实现类" class="headerlink" title="List接口的实现类"></a>List接口的实现类</h2><ul>
<li><p>ArrayList</p>
<p>实现了可变的数组，允许保存所有元素包括null .并且可以根据索引的位置对集合进行快速的随机访问，缺点是向指向的索引位置插入对象或删除对象时的速度较慢</p>
</li>
<li><p>LinkedList </p>
<p>采用链表的结构保存对象。优点是便于向集合中插入和删除对象</p>
<p>分别用ArrayList 和LinkedList来实例化集合</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;E&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">List&lt;E&gt; list=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p>E是合法的JAVA数据类型，也可以是字符串String</p>
</li>
</ul>
]]></content>
      <categories>
        <category>JAVA集合</category>
      </categories>
      <tags>
        <tag>JAVA集合</tag>
      </tags>
  </entry>
  <entry>
    <title>Map接口</title>
    <url>/2020/05/08/Map%E6%8E%A5%E5%8F%A3/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍Map接口</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h2 id="一-Map的定义"><a href="#一-Map的定义" class="headerlink" title="一.Map的定义"></a>一.Map的定义</h2><p>Map是一种依照键（key）存储元素的容器，键（key）很像下标。在List里下标是整数，而在Map中键（key）可以是任意类型的对象。Map中不能有重复的键（key），每个键都有一个对应的值（value)</p>
<p>一个键（key）和它对应的值（value)构成Map集合中的一个元素。</p>
<p>Map中的元素是俩个对象，一个对象作为键，一个对象作为值，<strong>键不可以重复，但是值可以重复。</strong></p>
<h2 id="二-Map常用方法"><a href="#二-Map常用方法" class="headerlink" title="二.Map常用方法"></a>二.Map常用方法</h2><ul>
<li><p>添加</p>
<table>
<thead>
<tr>
<th>put(key,Value)</th>
<th>调用put方法时，如果已经存在一个相同的key， 则返回的是前一个key对应的value，同时该key的新value覆盖旧value；如果是新的一个key，则返回的是null</th>
</tr>
</thead>
<tbody><tr>
<td>putAll</td>
<td>从指定映射中将所有映射关系复制到此映射中去。</td>
</tr>
</tbody></table>
</li>
<li><p>删除</p>
<table>
<thead>
<tr>
<th>remove(key)</th>
<th>删除指定key的键值对，返回被删除的key关联的value，不存在返回null</th>
</tr>
</thead>
<tbody><tr>
<td>remove(key,value)</td>
<td>删除指定键值对，成功返回true</td>
</tr>
<tr>
<td>clear()</td>
<td>删除map中所有的键值对</td>
</tr>
</tbody></table>
</li>
<li><p>获取</p>
<table>
<thead>
<tr>
<th>get(key)</th>
<th>返回指定key所对应的value，不存在则返回null</th>
</tr>
</thead>
<tbody><tr>
<td>Int size()</td>
<td>获取长度</td>
</tr>
</tbody></table>
</li>
<li><p>判断</p>
<table>
<thead>
<tr>
<th>boolean isEmpty()</th>
<th>长度为0返回true，否则false</th>
</tr>
</thead>
<tbody><tr>
<td>boolean containsKey(Object key)</td>
<td>判断集合中是否包含指定的key</td>
</tr>
<tr>
<td>boolean containsValue(Object value)</td>
<td>判断集合中是否包含指定的value</td>
</tr>
</tbody></table>
</li>
</ul>
<p>示例：</p>
<p>添加：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This program demonstrates</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Alita Alice</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: Created in 13:48 2020/5/9</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo7</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Integer&gt; map1 = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map1.put(<span class="string">"jack"</span>, <span class="number">20</span>);</span><br><span class="line">        map1.put(<span class="string">"rose"</span>, <span class="number">18</span>);</span><br><span class="line">        map1.put(<span class="string">"lucy"</span>, <span class="number">17</span>);</span><br><span class="line">        map1.put(<span class="string">"java"</span>, <span class="number">25</span>);</span><br><span class="line">        System.out.println(<span class="string">"map11"</span>+map1);</span><br><span class="line"></span><br><span class="line">        Map&lt;String,Integer&gt; map2=<span class="keyword">new</span> HashMap();</span><br><span class="line">        map2.put(<span class="string">"张三丰"</span>, <span class="number">100</span>);</span><br><span class="line">        map2.put(<span class="string">"虚竹"</span>, <span class="number">20</span>);</span><br><span class="line">        System.out.println(<span class="string">"map2"</span>+map2);</span><br><span class="line">        <span class="comment">//从指定映射种将所有的映射关系复制到此映射种</span></span><br><span class="line">        map1.putAll(map2);</span><br><span class="line">        System.out.println(<span class="string">"map1"</span>+map1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* out</span></span><br><span class="line"><span class="comment">map11&#123;java=25, rose=18, lucy=17, jack=20&#125;</span></span><br><span class="line"><span class="comment">map2&#123;张三丰=100, 虚竹=20&#125;</span></span><br><span class="line"><span class="comment">map1&#123;java=25, 张三丰=100, rose=18, lucy=17, jack=20, 虚竹=20&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>删除：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This program demonstrates</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Alita Alice</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: Created in 13:48 2020/5/9</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo7</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Integer&gt; map1 = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map1.put(<span class="string">"jack"</span>, <span class="number">20</span>);</span><br><span class="line">        map1.put(<span class="string">"rose"</span>, <span class="number">18</span>);</span><br><span class="line">        map1.put(<span class="string">"lucy"</span>, <span class="number">17</span>);</span><br><span class="line">        map1.put(<span class="string">"java"</span>, <span class="number">25</span>);</span><br><span class="line">        System.out.println(map1);</span><br><span class="line">        System.out.println(<span class="string">"delete value:"</span>+map1.remove(<span class="string">"java"</span>));</span><br><span class="line">        map1.clear();</span><br><span class="line">        System.out.println(<span class="string">"map1"</span>+map1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* out</span></span><br><span class="line"><span class="comment">&#123;java=25, rose=18, lucy=17, jack=20&#125;</span></span><br><span class="line"><span class="comment">delete value:25</span></span><br><span class="line"><span class="comment">map1&#123;&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>获取：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This program demonstrates</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Alita Alice</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: Created in 13:48 2020/5/9</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo7</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Integer&gt; map1 = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map1.put(<span class="string">"jack"</span>, <span class="number">20</span>);</span><br><span class="line">        map1.put(<span class="string">"rose"</span>, <span class="number">18</span>);</span><br><span class="line">        map1.put(<span class="string">"lucy"</span>, <span class="number">17</span>);</span><br><span class="line">        map1.put(<span class="string">"java"</span>, <span class="number">25</span>);</span><br><span class="line">        System.out.println(map1);</span><br><span class="line">        System.out.println(<span class="string">"value:"</span>+map1.get(<span class="string">"jack"</span>));</span><br><span class="line">        System.out.println(<span class="string">"map.size:"</span>+map1.size());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* out</span></span><br><span class="line"><span class="comment">&#123;java=25, rose=18, lucy=17, jack=20&#125;</span></span><br><span class="line"><span class="comment">value:20</span></span><br><span class="line"><span class="comment">map.size:4</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>判断：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This program demonstrates</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Alita Alice</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: Created in 13:48 2020/5/9</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo7</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Integer&gt; map1 = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map1.put(<span class="string">"jack"</span>, <span class="number">20</span>);</span><br><span class="line">        map1.put(<span class="string">"rose"</span>, <span class="number">18</span>);</span><br><span class="line">        map1.put(<span class="string">"lucy"</span>, <span class="number">17</span>);</span><br><span class="line">        map1.put(<span class="string">"java"</span>, <span class="number">25</span>);</span><br><span class="line">        System.out.println(map1);</span><br><span class="line">        System.out.println(<span class="string">"isEmpty"</span>+map1.isEmpty());</span><br><span class="line">        System.out.println(<span class="string">"containskey"</span>+map1.containsKey(<span class="string">"jack"</span>));</span><br><span class="line">        System.out.println(<span class="string">"containsvaluse"</span>+map1.containsValue(<span class="number">100</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* out</span></span><br><span class="line"><span class="comment">&#123;java=25, rose=18, lucy=17, jack=20&#125;</span></span><br><span class="line"><span class="comment">isEmptyfalse</span></span><br><span class="line"><span class="comment">containskeytrue</span></span><br><span class="line"><span class="comment">containsvalusefalse</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="三-遍历Map的方式"><a href="#三-遍历Map的方式" class="headerlink" title="三.遍历Map的方式"></a>三.遍历Map的方式</h3><ul>
<li><p><strong>使用KeySet</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This program demonstrates</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Alita Alice</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: Created in 13:48 2020/5/9</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo7</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Integer&gt; map1 = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map1.put(<span class="string">"jack"</span>, <span class="number">20</span>);</span><br><span class="line">        map1.put(<span class="string">"rose"</span>, <span class="number">18</span>);</span><br><span class="line">        map1.put(<span class="string">"lucy"</span>, <span class="number">17</span>);</span><br><span class="line">        map1.put(<span class="string">"java"</span>, <span class="number">25</span>);</span><br><span class="line">        System.out.println(map1);</span><br><span class="line">        Set&lt;String&gt; ks=map1.keySet();</span><br><span class="line">        Iterator&lt;String&gt; it=ks.iterator();</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext())</span><br><span class="line">        &#123;</span><br><span class="line">            String key=it.next();</span><br><span class="line">            Integer value = map1.get(key);</span><br><span class="line">            System.out.println(<span class="string">"key="</span>+key+<span class="string">" value="</span>+value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* out</span></span><br><span class="line"><span class="comment">&#123;java=25, rose=18, lucy=17, jack=20&#125;</span></span><br><span class="line"><span class="comment">key=java value=25</span></span><br><span class="line"><span class="comment">key=rose value=18</span></span><br><span class="line"><span class="comment">key=lucy value=17</span></span><br><span class="line"><span class="comment">key=jack value=20</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>将Map转换成Set集合，通过Set的迭代器取出Set集合中的每一个元素（Iterator)就是Map集合中所有的键，再通过get方法获取键对应的值。</p>
</li>
<li><p>通过values获取所有的值，不能获取到key对象</p>
<p>Collection<V> values()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo7</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Integer&gt; map1 = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map1.put(<span class="string">"jack"</span>, <span class="number">20</span>);</span><br><span class="line">        map1.put(<span class="string">"rose"</span>, <span class="number">18</span>);</span><br><span class="line">        map1.put(<span class="string">"lucy"</span>, <span class="number">17</span>);</span><br><span class="line">        map1.put(<span class="string">"java"</span>, <span class="number">25</span>);</span><br><span class="line">        Collection&lt;Integer&gt; vs=map1.values();  <span class="comment">//values方法获取所有的值但是不能获取到KEY对象。</span></span><br><span class="line">        Iterator&lt;Integer&gt; it = vs.iterator();</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext())</span><br><span class="line">        &#123;</span><br><span class="line">            Integer value=it.next();</span><br><span class="line">            System.out.println(<span class="string">"valuse="</span> +value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Map.Entry</p>
<p>面向对象的思想将Map集合中的键和值映射关系打包成一个对象，就是Map.Entry</p>
<p>将该对象存入Set集合，Map.Entry是一个对象，那么该对象具备的getKey ，getValue获得键和值。（<strong>通过Map中的entrySet()方法获取存放Map.Entry&lt;K,V&gt;对象的Set集合</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo7</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer,String&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="number">1</span>,<span class="string">"aaaa"</span>);</span><br><span class="line">        map.put(<span class="number">2</span>,<span class="string">"bbb"</span>);</span><br><span class="line">        map.put(<span class="number">3</span>, <span class="string">"cccc"</span>);</span><br><span class="line">        System.out.println(map);</span><br><span class="line"></span><br><span class="line">        Set&lt;Map.Entry&lt;Integer,String&gt;&gt; es=map.entrySet();</span><br><span class="line">        Iterator&lt;Map.Entry&lt;Integer,String&gt;&gt; it=es.iterator();</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext())</span><br><span class="line">        &#123;</span><br><span class="line">            Map.Entry&lt;Integer,String&gt; en =it.next();</span><br><span class="line">            Integer key=en.getKey();</span><br><span class="line">            String value=en.getValue();</span><br><span class="line">            System.out.println(<span class="string">"key="</span>+key+<span class="string">"value="</span>+value);</span><br><span class="line">        &#125;a</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* out</span></span><br><span class="line"><span class="comment">&#123;1=aaaa, 2=bbb, 3=cccc&#125;</span></span><br><span class="line"><span class="comment">key=1value=aaaa</span></span><br><span class="line"><span class="comment">key=2value=bbb</span></span><br><span class="line"><span class="comment">key=3value=cccc</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p>底层是哈希表数据结构，线程是不同步的，可以存入null键。</p>
<p>要保证键的唯一性，需要覆盖hashCode方法 和equals方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This program demonstrates</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Alita Alice</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: Created in 22:09 2020/5/10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;Person,String&gt; hm=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        hm.put(<span class="keyword">new</span> Person(<span class="string">"jack"</span>, <span class="number">20</span>), <span class="string">"1001"</span>);</span><br><span class="line">        hm.put(<span class="keyword">new</span> Person(<span class="string">"rose"</span>, <span class="number">18</span>), <span class="string">"1002"</span>);</span><br><span class="line">        hm.put(<span class="keyword">new</span> Person(<span class="string">"lucy"</span>, <span class="number">19</span>), <span class="string">"1003"</span>);</span><br><span class="line">        hm.put(<span class="keyword">new</span> Person(<span class="string">"hmm"</span>, <span class="number">17</span>), <span class="string">"1004"</span>);</span><br><span class="line">        hm.put(<span class="keyword">new</span> Person(<span class="string">"ll"</span>, <span class="number">17</span>), <span class="string">"1005"</span>);</span><br><span class="line">        System.out.println(hm);</span><br><span class="line">        System.out.println(hm.put(<span class="keyword">new</span> Person(<span class="string">"rose"</span>, <span class="number">18</span>), <span class="string">"1006"</span>));</span><br><span class="line">        Set&lt;Map.Entry&lt;Person,String&gt;&gt; entrySet =hm.entrySet();</span><br><span class="line">        Iterator&lt;Map.Entry&lt;Person,String&gt;&gt; it= entrySet.iterator();</span><br><span class="line">        <span class="keyword">while</span>  (it.hasNext())</span><br><span class="line">        &#123;</span><br><span class="line">            Map.Entry&lt;Person,String&gt; next=it.next();</span><br><span class="line">            Person key =next.getKey();</span><br><span class="line">            String value=next.getValue();</span><br><span class="line">            System.out.println(key+ <span class="string">"="</span> +value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span>  String name;</span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">int</span> age;</span><br><span class="line">    Person()</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Person)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Person person = (Person) o;</span><br><span class="line">        <span class="keyword">return</span> getAge() == person.getAge() &amp;&amp;</span><br><span class="line">                getName().equals(person.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(getName(), getAge());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* out </span></span><br><span class="line"><span class="comment">&#123;Person&#123;name='ll', age=17&#125;=1005, Person&#123;name='jack', age=20&#125;=1001, Person&#123;name='hmm', age=17&#125;=1004, Person&#123;name='lucy', age=19&#125;=1003, Person&#123;name='rose', age=18&#125;=1002&#125;</span></span><br><span class="line"><span class="comment">1002</span></span><br><span class="line"><span class="comment">Person&#123;name='ll', age=17&#125;=1005</span></span><br><span class="line"><span class="comment">Person&#123;name='jack', age=20&#125;=1001</span></span><br><span class="line"><span class="comment">Person&#123;name='hmm', age=17&#125;=1004</span></span><br><span class="line"><span class="comment">Person&#123;name='lucy', age=19&#125;=1003</span></span><br><span class="line"><span class="comment">Person&#123;name='rose', age=18&#125;=1006</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h2><p>TreeMap的排序，TreeMap 可以对集合中的键进行排序，如何实现对键的排序？</p>
<h3 id="方式1：-元素自身具备比较性"><a href="#方式1：-元素自身具备比较性" class="headerlink" title="方式1： 元素自身具备比较性"></a>方式1： 元素自身具备比较性</h3><p>和TreeSet一样原理，需要让存储在键位置的对象实现Comparable接口。重写compareTo方法，也就是让元素自身具备比较性，这种方式叫做元素的自然排序也叫默认排序。</p>
<h3 id="方式2：容器具备比较性"><a href="#方式2：容器具备比较性" class="headerlink" title="方式2：容器具备比较性"></a>方式2：容器具备比较性</h3><p>当元素自身不具备比较性，或者自身具备的比较性不是所需要的，那么此时可以让<strong>容器自身具备</strong>，需要定义一个类<strong>实现接口Compatator，重写compare方法，并将该接口的子类实例对象作为参数传递给TreeMap集合的构造方法。</strong></p>
<p>注意：当Comparable比较方式和Comparator比较方式同时存在时，以Comparator的比较方式为主。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This program demonstrates</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Alita Alice</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: Created in 22:09 2020/5/10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       TreeMap&lt;String,Integer&gt; tree=<span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">        tree.put(<span class="string">"张三"</span>,<span class="number">19</span>);</span><br><span class="line">        tree.put(<span class="string">"李四"</span>,<span class="number">20</span>);</span><br><span class="line">        tree.put(<span class="string">"王五"</span>,<span class="number">21</span>);</span><br><span class="line">        tree.put(<span class="string">"赵留"</span>,<span class="number">21</span>);</span><br><span class="line">        System.out.println(tree);</span><br><span class="line">        System.out.println(<span class="string">"张三"</span>.compareTo(<span class="string">"李四"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自定义元素排序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This program demonstrates</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Alita Alice</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: Created in 22:09 2020/5/10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">     TreeMap&lt;Person,String&gt; hm=<span class="keyword">new</span> TreeMap&lt;Person, String&gt;(<span class="keyword">new</span> MyComparator());<span class="comment">//该接口的子类实例对象作为参数传递给TreeMap集合的构造方法。</span></span><br><span class="line">        hm.put(<span class="keyword">new</span> Person(<span class="string">"jack"</span>,<span class="number">20</span>),<span class="string">"1001"</span>);</span><br><span class="line">        hm.put(<span class="keyword">new</span> Person(<span class="string">"rose"</span>, <span class="number">18</span>), <span class="string">"1002"</span>);</span><br><span class="line">        hm.put(<span class="keyword">new</span> Person(<span class="string">"lucy"</span>, <span class="number">19</span>), <span class="string">"1003"</span>);</span><br><span class="line">        hm.put(<span class="keyword">new</span> Person(<span class="string">"hmm"</span>, <span class="number">17</span>), <span class="string">"1004"</span>);</span><br><span class="line">        System.out.println(hm);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Set&lt;Map.Entry&lt;Person,String&gt;&gt; entrySet=hm.entrySet();</span><br><span class="line">        Iterator&lt;Map.Entry&lt;Person,String&gt;&gt; it=entrySet.iterator();</span><br><span class="line">        <span class="keyword">while</span>  (it.hasNext())</span><br><span class="line">        &#123;</span><br><span class="line">            Map.Entry&lt;Person,String&gt; next=it.next();</span><br><span class="line">            Person key=next.getKey();</span><br><span class="line">            String value=next.getValue();</span><br><span class="line">            System.out.println(key+ <span class="string">"="</span> +value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Person</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Person p1,Person p2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p1.getAge()&gt;p2.getAge())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p1.getAge()&lt;p2.getAge())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p1.getName().compareTo(p2.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Person</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">  Person()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Person)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Person person = (Person) o;</span><br><span class="line">        <span class="keyword">return</span> getAge() == person.getAge() &amp;&amp;</span><br><span class="line">                getName().equals(person.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(getName(), getAge());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Person p)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(<span class="keyword">this</span>.age&gt;p.age) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.age&lt;p.age)</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name.compareTo(p.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* out</span></span><br><span class="line"><span class="comment">&#123;Person&#123;name='jack', age=20&#125;=1001, Person&#123;name='lucy', age=19&#125;=1003, Person&#123;name='rose', age=18&#125;=1002, Person&#123;name='hmm', age=17&#125;=1004&#125;</span></span><br><span class="line"><span class="comment">Person&#123;name='jack', age=20&#125;=1001</span></span><br><span class="line"><span class="comment">Person&#123;name='lucy', age=19&#125;=1003</span></span><br><span class="line"><span class="comment">Person&#123;name='rose', age=18&#125;=1002</span></span><br><span class="line"><span class="comment">Person&#123;name='hmm', age=17&#125;=1004</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>注意：Set元素不可重复，Map的键不可重复</p>
<p>​           如果存入重复元素如何处理?</p>
<p>Set元素重复元素不能存入add方法，返回false;</p>
<p>Map的重复键将覆盖旧键，将旧值返回。</p>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>JAVA集合</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql用户变量和set语句</title>
    <url>/2020/05/19/Mysql%E7%94%A8%E6%88%B7%E5%8F%98%E9%87%8F%E5%92%8Cset%E8%AF%AD%E5%8F%A5/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍mysql用户变量和set语句</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="1-用户变量介绍"><a href="#1-用户变量介绍" class="headerlink" title="1 用户变量介绍"></a>1 用户变量介绍</h3><p>用户变量即用户自己定义的变量，我们可以给用户变量分配值，并且可用在任何可以正常使用标量表达式的地方。<br>    引入用户变量之前我们必须使用set语句或select语句来定义它，然后为它赋一个值，否则变量就只有一个空值。<br>    用户变量与连接有关。也就是说，一个客户端定义的变量不能被其它客户端看到或使用。当客户端退出时，该客户端连接的所有变量将自动释放。</p>
<h3 id="2-用户变量定义"><a href="#2-用户变量定义" class="headerlink" title="2 用户变量定义"></a>2 用户变量定义</h3><p>set语句可用于向系统变量或用户变量赋值，针对用户变量的定义如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SET <span class="meta">@var</span>_name = expr [, <span class="meta">@var</span>_name = expr] ...</span><br></pre></td></tr></table></figure>

<p>也可使用select语句来定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SELECT <span class="meta">@var</span>_name := expr [, <span class="meta">@var</span>_name = expr] ...</span><br></pre></td></tr></table></figure>

<p>用户变量：以”@”开始，形式为”@var_name”,以区分用户变量及列名。它可以是任何随机的，复合的标量表达式，只要其中没有列指定。<br>一个变量名可以由当前字符集的数字字母字符和“_”、“$”和“.”组成。缺省字符集是ISO-8859-1 Latin1；这可以用mysqld 的–default-character-set 选项更改字符集。<br>对于SET，可以使用=或:=来赋值，对于SELECT只能使用:=来赋值。<br>我们可以使用一条简单的select语句查询定义的用户变量的值</p>
<h3 id="3-用户变量的使用"><a href="#3-用户变量的使用" class="headerlink" title="3 用户变量的使用"></a>3 用户变量的使用</h3><h4 id="3-1-通过set的实例"><a href="#3-1-通过set的实例" class="headerlink" title="3.1 通过set的实例"></a>3.1 通过set的实例</h4><p>用来把一个值赋给一个变量的标量表达式可以是复合表达式。计算，函数，系统标量以及其他用户变量都是允许的，子查询也是允许的。然后通过select语句可以获取一个用户变量的值，结果是带有一行的一个表。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mysql&gt; set <span class="meta">@var</span>1=<span class="number">1</span>, <span class="meta">@var</span>2=<span class="string">'vartest'</span>, <span class="meta">@var</span>3=abs(-<span class="number">2</span>), <span class="meta">@var</span>4=(<span class="function">select <span class="title">count</span><span class="params">(*)</span> from mysql.user)</span>;</span><br><span class="line">mysql&gt; select <span class="meta">@var</span>1, <span class="meta">@var</span>2, <span class="meta">@var</span>3, <span class="meta">@var</span>4;</span><br><span class="line">+-------+---------+-------+-------+</span><br><span class="line">| <span class="meta">@var</span>1 | <span class="meta">@var</span>2   | <span class="meta">@var</span>3 | <span class="meta">@var</span>4 |</span><br><span class="line">+-------+---------+-------+-------+</span><br><span class="line">|     <span class="number">1</span> | vartest |     <span class="number">2</span> |    <span class="number">25</span> |</span><br><span class="line">+-------+---------+-------+-------+</span><br></pre></td></tr></table></figure>

<p> 在用来为一个用户变量赋值的表达式中，也可以指定其它的用户变量，需要注意的是mysql首先确定所有表达式的值，之后才会把值赋给变量。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mysql&gt; set <span class="meta">@varA</span> = <span class="number">2</span>; </span><br><span class="line"></span><br><span class="line">mysql&gt; set <span class="meta">@varA</span> = <span class="number">3</span>, <span class="meta">@varB</span> = <span class="meta">@varA</span>;</span><br><span class="line">mysql&gt; select <span class="meta">@varB</span>;</span><br><span class="line">+-------+</span><br><span class="line">| <span class="meta">@varB</span> |</span><br><span class="line">+-------+</span><br><span class="line">|     <span class="number">2</span> |</span><br><span class="line">+-------+</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mysql&gt; set <span class="meta">@varA</span> = <span class="number">3</span>; </span><br><span class="line">mysql&gt; set <span class="meta">@varB</span> = <span class="meta">@varA</span>;</span><br><span class="line">mysql&gt; select <span class="meta">@varB</span>;                                             </span><br><span class="line">+-------+</span><br><span class="line">| <span class="meta">@varB</span> |</span><br><span class="line">+-------+</span><br><span class="line">|     <span class="number">3</span> |</span><br><span class="line">+-------+</span><br></pre></td></tr></table></figure>

<h4 id="3-2-通过select-的实例"><a href="#3-2-通过select-的实例" class="headerlink" title="3.2 通过select 的实例"></a>3.2 通过select 的实例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mysql&gt; select <span class="meta">@var</span>1:=<span class="number">1</span>, <span class="meta">@var</span>2:=<span class="string">'vartest'</span>, <span class="meta">@var</span>3:=abs(-<span class="number">2</span>), <span class="meta">@var</span>4:=(<span class="function">select <span class="title">count</span><span class="params">(*)</span> from mysql.user)</span>;</span><br><span class="line">+----------+------------------+----------------+------------------------------------------+</span><br><span class="line">| <span class="meta">@var</span>1:=<span class="number">1</span> | <span class="meta">@var</span>2:=<span class="string">'vartest'</span> | <span class="meta">@var</span>3:=abs(-<span class="number">2</span>) | <span class="meta">@var</span>4:=(<span class="function">select <span class="title">count</span><span class="params">(*)</span> from mysql.user) |</span></span><br><span class="line"><span class="function">+----------+------------------+----------------+------------------------------------------+</span></span><br><span class="line"><span class="function">|        1 | vartest          |              2 |                                       25 |</span></span><br><span class="line"><span class="function">+----------+------------------+----------------+------------------------------------------+</span></span><br><span class="line"><span class="function">mysql&gt; select @var1, @var2, @var3, @var4</span>;</span><br><span class="line">+-------+---------+-------+-------+</span><br><span class="line">| <span class="meta">@var</span>1 | <span class="meta">@var</span>2   | <span class="meta">@var</span>3 | <span class="meta">@var</span>4 |</span><br><span class="line">+-------+---------+-------+-------+</span><br><span class="line">|     <span class="number">1</span> | vartest |     <span class="number">2</span> |    <span class="number">25</span> |</span><br><span class="line">+-------+---------+-------+-------+</span><br><span class="line">+-------+---------+-------+-------+</span><br><span class="line">|     <span class="number">1</span> | vartest |     <span class="number">2</span> |    <span class="number">25</span> |</span><br><span class="line">+-------+---------+-------+-------+</span><br></pre></td></tr></table></figure>



<h3 id="用户变量注意事项"><a href="#用户变量注意事项" class="headerlink" title="用户变量注意事项"></a>用户变量注意事项</h3><p>4.1 用户变量用在where或having子句中，他们必须首先用另一条语句来定义,如下面例子，初次查询没有返回结果，先定以后在查询才有输出。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mysql&gt; select <span class="meta">@H</span>:=<span class="string">'localhost'</span> from mysql.user where host = <span class="meta">@H</span>;</span><br><span class="line"><span class="function">Empty <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br><span class="line"><span class="function">mysql&gt; select @H:</span>=<span class="string">'localhost'</span>;</span><br><span class="line">+-----------------+</span><br><span class="line">| <span class="meta">@H</span>:=<span class="string">'localhost'</span> |</span><br><span class="line">+-----------------+</span><br><span class="line">| localhost       |</span><br><span class="line">+-----------------+</span><br><span class="line"><span class="number">1</span> <span class="function">row in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br><span class="line"><span class="function">mysql&gt; select @H:</span>=<span class="string">'localhost'</span>, user from mysql.user where host = <span class="meta">@H</span>;</span><br><span class="line">+-----------------+-----------------+</span><br><span class="line">| <span class="meta">@H</span>:=<span class="string">'localhost'</span> | user            |</span><br><span class="line">+-----------------+-----------------+</span><br><span class="line">| localhost       |                 |</span><br><span class="line">| localhost       | jesse           |</span><br><span class="line">| localhost       | local           |</span><br><span class="line">| localhost       | root            |</span><br><span class="line">| localhost       | user_tab_update |</span><br><span class="line">+-----------------+-----------------+</span><br></pre></td></tr></table></figure>

<p> 4.2 用户变量为session级别，当我们关闭客户端或退出登录时用户变量全部消失。如果想用就保存自定义的变量，需要自行创建一个表，将标量insert到表里。<br>  4.3 用户变量名对大小写不敏感。<br>  4.4 未定义的变量初始化是null。</p>
<h4 id="mysql语句do"><a href="#mysql语句do" class="headerlink" title="mysql语句do"></a>mysql语句do</h4><p> 在do语句中，使用了一个或多个标量表达式，mysql会一条一条的处理它们，但并不显示表达式的结果。例如我们可以调用函数执行后台的某些事情，而不需要看到其结果。</p>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql自定义函数</title>
    <url>/2020/05/18/Mysql%E8%87%AA%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍Mysql自定义函数</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>创建函数语法：<br>CREATE FUNCTION fn_name(func_parameter[,…])<br>RETURNS type<br>[characteristic…]<br>routine_body</p>
<p>eg:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">#创建一个函数</span><br><span class="line">DELIMITER $$ -- 定界符</span><br><span class="line">-- 开始创建函数</span><br><span class="line"><span class="function">CREATE FUNCTION <span class="title">user_main_fn</span><span class="params">(v_id INT)</span></span></span><br><span class="line"><span class="function">RETURNS <span class="title">VARCHAR</span><span class="params">(<span class="number">50</span>)</span></span></span><br><span class="line"><span class="function">BEGIN</span></span><br><span class="line"><span class="function">  -- 定义变量</span></span><br><span class="line"><span class="function">  DECLARE v_userName <span class="title">VARCHAR</span><span class="params">(<span class="number">50</span>)</span></span>;</span><br><span class="line">  -- 给定义的变量赋值</span><br><span class="line">  SELECT f_userName INTO v_userName FROM t_user_main </span><br><span class="line">  WHERE f_userId = v_id;</span><br><span class="line">  -- 返回函数处理结果</span><br><span class="line">  RETURN v_userName;</span><br><span class="line">END $$ -- 函数创建定界符</span><br><span class="line">DELIMITER;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">#创建第二个函数，使用第一个函数</span><br><span class="line">DELIMITER $$</span><br><span class="line"><span class="function">CREATE FUNCTION <span class="title">user_main_fn2</span><span class="params">(v_id INT)</span></span></span><br><span class="line"><span class="function">RETURNS <span class="title">VARCHAR</span><span class="params">(<span class="number">100</span>)</span></span></span><br><span class="line"><span class="function">BEGIN </span></span><br><span class="line"><span class="function">  #定义变量</span></span><br><span class="line"><span class="function">  DECLARE v_userName <span class="title">VARCHAR</span><span class="params">(<span class="number">50</span>)</span></span>;</span><br><span class="line">  <span class="function">DECLARE  v_userNameNew <span class="title">VARCHAR</span><span class="params">(<span class="number">50</span>)</span></span>;</span><br><span class="line">  #通过into赋值</span><br><span class="line">  SELECT f_userName INTO v_userName FROM t_user_main WHERE f_userId = v_id;</span><br><span class="line">  #使用函数</span><br><span class="line">  <span class="function">SELECT <span class="title">user_main_fn</span><span class="params">(v_id)</span> INTO v_userNameNew FROM DUAL</span>;</span><br><span class="line">  #返回函数处理结果</span><br><span class="line">  <span class="function">RETURN <span class="title">CONCAT</span><span class="params">(v_userName,<span class="string">'***'</span>,v_userNameNew)</span></span>;</span><br><span class="line">END $$</span><br><span class="line">DELIMITER;</span><br></pre></td></tr></table></figure>

<p>DUAL 虚拟表</p>
<h3 id="查看函数状态语法："><a href="#查看函数状态语法：" class="headerlink" title="查看函数状态语法："></a>查看函数状态语法：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SHOW FUNCTION STATUS [LIKE <span class="string">'pattern'</span>]</span><br></pre></td></tr></table></figure>



<h4 id="查看函数的定义语法："><a href="#查看函数的定义语法：" class="headerlink" title="查看函数的定义语法："></a>查看函数的定义语法：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SHOW CREATE FUNCTION fn_name;</span><br></pre></td></tr></table></figure>

<p>eg:  输出第n高的工资</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">CREATE FUNCTION <span class="title">getNthHighestSalary</span><span class="params">(N INT)</span> RETURNS INT</span></span><br><span class="line"><span class="function">BEGIN</span></span><br><span class="line"><span class="function">  SET N</span>=N-<span class="number">1</span>;</span><br><span class="line">  RETURN (</span><br><span class="line">      # Write your MySQL query statement below.</span><br><span class="line">      SELECT  DISTINCT Salary  FROM Employee ORDER BY Salary DESC  limit N,<span class="number">1</span></span><br><span class="line">  );</span><br><span class="line">END</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>OutOfMemeryError异常</title>
    <url>/2020/05/25/OutOfMemeryError%E5%BC%82%E5%B8%B8/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍OutOfMemeryError异常</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="1-Java堆溢出"><a href="#1-Java堆溢出" class="headerlink" title="1 Java堆溢出"></a>1 Java堆溢出</h3><p><img src="https://photos.alitaalice.cn/image/20200525171739.png" alt=""></p>
<h3 id="2-虚拟机栈和本地方法栈溢出"><a href="#2-虚拟机栈和本地方法栈溢出" class="headerlink" title="2 虚拟机栈和本地方法栈溢出"></a>2 虚拟机栈和本地方法栈溢出</h3><p><img src="https://photos.alitaalice.cn/image/20200525171954.png" alt=""></p>
<h3 id="3-方法区和运行时常量池溢出"><a href="#3-方法区和运行时常量池溢出" class="headerlink" title="3 方法区和运行时常量池溢出"></a>3 方法区和运行时常量池溢出</h3><h3 id="4-本地直接内存溢出"><a href="#4-本地直接内存溢出" class="headerlink" title="4 本地直接内存溢出"></a>4 本地直接内存溢出</h3>]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>SSM基础</title>
    <url>/2020/05/27/SSM%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2>]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring起步</title>
    <url>/2020/05/10/Spring%E8%B5%B7%E6%AD%A5/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍什么是Spring</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h2 id="什么是Spring"><a href="#什么是Spring" class="headerlink" title="什么是Spring"></a>什么是Spring</h2><ul>
<li><p>Spring 的核心是提供一个容器(container) </p>
<p>通常称为Spring 应用上下文（Spring application context) 应用前后关系，它们会创建和管理应用组件。</p>
<p>这些组件也被称为是bean ，会在Spring应用上下文中装配在一起，从而形成一个完整的应用程序。</p>
<p>这就像砖块，砂浆，木材 ，管道等组合在一起</p>
</li>
</ul>
<ul>
<li><p>将bean装配在一起是通过一种基于依赖注入（dependency injection DI)</p>
<p>举例来说：假设在众多的组件中，有俩个是我们需要处理的：库存服务，和商品服务。</p>
<p>商品服务需要依赖于库存服务。</p>
<p>如图所示阐述了bean和Spring 应用上下文之间的关系。</p>
<p><img src="TIM%E5%9B%BE%E7%89%8720200510124205.png" alt=""></p>
<p>依赖注入到需要它们的bean中，另外使用依赖注入的应用依赖于单独的实体（容器）来创建和维护所有的组件。</p>
<p> Spring Initializr 是一个基于浏览器的web应用，能够生成Spring 项目结构的骨架。</p>
</li>
</ul>
<h3 id="pom文件"><a href="#pom文件" class="headerlink" title="pom文件"></a>pom文件</h3><h2 id="Springboot的引导类"><a href="#Springboot的引导类" class="headerlink" title="Springboot的引导类"></a>Springboot的引导类</h2><p>@SpringBootApplication  ：是一个组合注解，包括：</p>
<ul>
<li>@SpringBootConfiguration</li>
</ul>
<p>将该类声明为配置类</p>
<ul>
<li>@EnableAutoConfiguration</li>
</ul>
<p>启动Spring BOOT 的自动配置 </p>
<ul>
<li>@ComponentScan </li>
</ul>
<p>启动组件扫描</p>
<p>@Component @Controller @Service 注解声明其他类，Spring会自动发现它们并将它们注册为Spring应用上下文的组件。</p>
]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>char可以存储汉字吗？</title>
    <url>/2020/05/06/char%E5%8F%AF%E4%BB%A5%E5%AD%98%E5%82%A8%E6%B1%89%E5%AD%97%E5%90%97%EF%BC%9F/</url>
    <content><![CDATA[<h2 id="char存储汉字"><a href="#char存储汉字" class="headerlink" title="char存储汉字"></a>char存储汉字</h2><ul>
<li><p>char是按照字符存储的，不管是英文还是中文，JAVA中固定占用2个字符，用来存储Unicode字符，范围在0-65535.</p>
</li>
<li><p>Unicode编码字符集中包含了汉字，所以char类型变量当然可以存储汉字拉。</p>
<a id="more"></a>

<h2 id="char和String的区别"><a href="#char和String的区别" class="headerlink" title="char和String的区别"></a>char和String的区别</h2><ul>
<li>char表示字符，定义时用单引号，只能存储一个字符。如char c=‘x’ ;</li>
<li>String表示的是字符串，可以存储一个或多个字符 如String name=”tom”;</li>
<li></li>
</ul>
</li>
</ul>
<p>如name.length();</p>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>JAVASE</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql使用触发器</title>
    <url>/2020/05/15/mysql%E4%BD%BF%E7%94%A8%E8%A7%A6%E5%8F%91%E5%99%A8/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍触发器</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>触发器是MySQL响应以下任意语句而自动执行的一条MySQL语句（或位于BEGIN和END语句之间的一组语句 。</p>
<ul>
<li><p>DELETE </p>
</li>
<li><p>INSERT </p>
</li>
<li><p>UPDATE</p>
<p>在创建触发器时，需要给出4条信息 :</p>
<p><img src="https://photos.alitaalice.cn/image/20200515154008.png" alt=""></p>
</li>
</ul>
<p>Eg：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CREATE TRIGGER newproduct AFTER INSERT ON products</span><br><span class="line">FOR EACH ROW SELECT <span class="string">'Product added'</span></span><br></pre></td></tr></table></figure>

<p>CREATE TRIGGER用来创建名为newproduct的新触发器。触发器<br>可在一个操作发生之前或之后执行，这里给出了AFTER INSERT，<br>所以此触发器将在INSERT语句成功执行后执行。这个触发器还指定FOR EACH ROW，因此代码对每个插入行执行。在这个例子中，文本Product added将对每个插入的行显示一次.</p>
<p>  每个表最多支持6个触发器（每条INSERT、 UPDATE和DELETE的之前和之后）。单一触发器不能与多个事件或多个表关联，所以，如果你需要一个对INSERT和UPDATE操作执行的触发器，则应该定义两个触发器  .</p>
<h2 id="删除触发器"><a href="#删除触发器" class="headerlink" title="删除触发器"></a>删除触发器</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DROP TRIGGER newproduct;</span><br></pre></td></tr></table></figure>

<p>触发器不能更新或覆盖。为了修改一个触发器，必须先删除它，然后再重新创建。  </p>
<h2 id="使用-触发器"><a href="#使用-触发器" class="headerlink" title="使用 触发器"></a>使用 触发器</h2><h3 id="1-INSERT-触发器"><a href="#1-INSERT-触发器" class="headerlink" title="1 INSERT 触发器"></a>1 INSERT 触发器</h3><p>INSERT触发器在INSERT语句执行之前或之后执行。  </p>
<ul>
<li>在INSERT触发器代码内，可引用一个名为NEW的虚拟表，访问被插入的行；</li>
<li>在BEFORE INSERT触发器中， NEW中的值也可以被更新（允许更改被插入的值）；</li>
<li>对于AUTO_INCREMENT列， NEW在INSERT执行之前包含0，在INSERT 执行之后包含新的自动生成值  </li>
</ul>
<p>eg：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CREATE TRIGGER neworder AFTER INSERT ON orders</span><br><span class="line">FOR EACH ROW SELECT NEW.order_num;</span><br></pre></td></tr></table></figure>

<p>此代码创建一个名为neworder的触发器，它按照AFTER INSERT<br>ON orders执行。在插入一个新订单到orders表时， MySQL生<br>成一个新订单号并保存到order_num中。触发器从NEW. order_num取得这个值并返回它。此触发器必须按照AFTER INSERT执行，因为在BEFORE INSERT语句执行之前，新order_num还没有生成。对于orders的每次插入使用这个触发器将总是返回新的订单号。  </p>
<p>试着插入一下新行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INSERT INTO orders(order_date,cust_id) VALUES(NOW(),10001);</span><br></pre></td></tr></table></figure>

<p><img src="https://photos.alitaalice.cn/image/20200515155708.png" alt=""></p>
<h3 id="DELETE-触发器"><a href="#DELETE-触发器" class="headerlink" title="DELETE 触发器"></a>DELETE 触发器</h3><ul>
<li>在DELETE触发器代码内，你可以引用一个名为OLD的虚拟表，访问被删除的行；</li>
<li>OLD中的值全都是只读的，不能更新。  </li>
</ul>
<p>下面例子用OLD保存将要被删除的行到一个存档表中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CREATE TRIGGER deleteorder BEFORE DELETE ON orders</span><br><span class="line">FOR EACH ROW</span><br><span class="line">BEGIN</span><br><span class="line">    <span class="function">INSERT INTO <span class="title">archive_orders</span><span class="params">(order_num, order_date,cust_id)</span> <span class="title">VALUES</span><span class="params">(OLD.order_num,OLD.order_date,OLD.cust_id)</span></span>;</span><br><span class="line">END;</span><br></pre></td></tr></table></figure>

<p>在任意订单被删除前将执行此触发器。它使用一条INSERT语句将OLD中的值（要被删除的订单）保存到一个名为archive_orders的存档表中（为实际使用这个例子，你需要用与orders相同的列创建一个名为archive_orders的表）  </p>
<h2 id="UPDATE-触发器"><a href="#UPDATE-触发器" class="headerlink" title="UPDATE 触发器"></a>UPDATE 触发器</h2><ul>
<li><p>在UPDATE触发器代码中，你可以引用一个名为OLD的虚拟表访问以前（UPDATE语句前）的值，引用一个名为NEW的虚拟表访问新更新的值；</p>
</li>
<li><p>在BEFORE UPDATE触发器中， NEW中的值可能也被更新（允许更改将要用于UPDATE语句中的值）；</p>
</li>
<li><p>OLD中的值全都是只读的，不能更新  </p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CREATE TRIGGER updatevendor BERORE UPDATE ON vendors</span><br><span class="line">FOR EACH ROW SET NEW.vend_state=Upper(NEW.vend_state);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql全文本搜索</title>
    <url>/2020/05/07/mysql%E5%85%A8%E6%96%87%E6%9C%AC%E6%90%9C%E7%B4%A2/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>Mysql 全文本搜索用法实例及详解。</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h1 id="启用全文本搜索支持"><a href="#启用全文本搜索支持" class="headerlink" title="启用全文本搜索支持"></a>启用全文本搜索支持</h1><p>CREATE  TABLE 接受FULLTEXT子句</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">CREATE TABLE productsnotes</span><br><span class="line">(</span><br><span class="line"> note_id <span class="keyword">int</span> NOT <span class="literal">NULL</span> AUTO_INCREMENT,  <span class="comment">/* auto increment 自动递增主键字段 */</span></span><br><span class="line"> prod_id <span class="keyword">char</span>(<span class="number">10</span>)  NOT <span class="literal">NULL</span>,</span><br><span class="line"> note_date datetime NOT <span class="literal">NULL</span>,</span><br><span class="line"> note_text  <span class="built_in">text</span>  <span class="literal">NULL</span>,</span><br><span class="line"> PRIMARY KEY(note_id),</span><br><span class="line"> FULLTEXT(note_text)</span><br><span class="line"> ) ENGINE=MyISAM;</span><br></pre></td></tr></table></figure>

<p>这条CREATE TABLE 语句定义表productnotes 并列出它所包含的列即可。这些列中有一个名为note_text 的列，为了进行全文本搜素，MySQL根据子句FULLTEXT(note_text)的指示对它进行索引。<br>FULLTEXT索引单个列，如果需要也可以指定多个列。</p>
<h2 id="在索引之后，使用俩个函数Match-和Against-执行全文本搜素"><a href="#在索引之后，使用俩个函数Match-和Against-执行全文本搜素" class="headerlink" title="在索引之后，使用俩个函数Match() 和Against()执行全文本搜素"></a>在索引之后，使用俩个函数Match() 和Against()执行全文本搜素</h2><p>其中Match()指定被搜索的列，Against()指定要使用的搜索表达式</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">SELECT note_text FROM productnotes WHERE Match(not_text) Against('rabbit');</span><br></pre></td></tr></table></figure>

<p>Match(note_text )指示MySQL针对指定的列进行搜索，Against(‘rabbit’) 指定词rabbit作为搜索文本。</p>
<p>使用完整的Match()说明，传递给Match()的值必须与FULLTEXT()定义中的相同。除非使用BINARY 方式，否则全文本搜索不区分大小写。</p>
<ul>
<li>搜索页可以简单地用LIKE子句完成</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">SELECT note_text FROM productnotes WHERE note_text LIKE '%rabbit%';</span><br></pre></td></tr></table></figure>

<ul>
<li>但是却与全文本搜索，各有优劣</li>
</ul>
<ol>
<li></li>
<li>在使用全文本搜索时就会对此结果排序，但是like却不会。</li>
</ol>
<h1 id="全文本布尔操作符"><a href="#全文本布尔操作符" class="headerlink" title="全文本布尔操作符"></a>全文本布尔操作符</h1><ul>
<li>+包含，词必须存在</li>
</ul>
<ul>
<li>-排除，词必须不出现</li>
<li>大于号 包含，而且增加等级值</li>
<li>&lt;包含，且减少等级值</li>
<li>() 把词组成子表达式(允许这些子表达式作为一个组被包含，排除，排列等）</li>
<li>~取消一个词的排序值</li>
</ul>
<ul>
<li>*词尾的通配符</li>
<li>“” 定义一个短语</li>
</ul>
<h2 id="布尔文本搜索"><a href="#布尔文本搜索" class="headerlink" title="布尔文本搜索"></a>布尔文本搜索</h2><p>布尔方式搜索，添加布尔操作符</p>
<p>IN BOOLEAN MODE</p>
<ul>
<li><p>举几个例子：</p>
</li>
<li><pre><code class="c">1 SELECT note_text FROM productnotes WHERE Match(note_text) Against('+rabbit +bait' IN BOOLEAN MODE);
<span class="comment">/*这个搜索匹配包含词rabbit和bait的行 */</span>
2 SELECT note_text FROM productnotes WHERE Match(note_text) Against('rabbit bait' IN BOOLEAN MODE);
<span class="comment">/*没有指定操作符，这个搜索匹配包含rabbit 和bait中的至少一个词的行。*/</span>
3 SELECT note_text FROM productnotes WHERE Match(note_text) Against('"rabbit bait"' IN BOOLEAN MODE);
4 SELECT note_text FROM productnotes WHERE Match(note_text) Against ('&gt;rabbit &lt;carrot' IN BOOLEAN MODE);</code></pre>
</li>
</ul>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql插入数据</title>
    <url>/2020/05/07/mysql%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍如何利用SQL的INSERT语句将数据插入到表中</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h2 id="插入到完整的行"><a href="#插入到完整的行" class="headerlink" title="插入到完整的行"></a>插入到完整的行</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">INSERT INTO Customers</span><br><span class="line">VALUES(<span class="literal">NULL</span>,</span><br><span class="line">       'PEP E.LAPEW',</span><br><span class="line">       '100 MAIN STREET',</span><br><span class="line">        'Los Angeles',</span><br><span class="line">         'CA',</span><br><span class="line">        '90046',</span><br><span class="line">         'USA',</span><br><span class="line">          <span class="literal">NULL</span>,</span><br><span class="line">          <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>

<p>编写INSERT语句的更加安全（不过更加繁琐）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INSERT INTO customers(cust_name,cust_address,cust_city,cust_state,cust_zip,cust_country,cust_contact,cust_email)</span><br><span class="line">VALUSES(&#39;PEP E.LAPEW&#39;,</span><br><span class="line">       &#39;100 MAIN STREET&#39;,</span><br><span class="line">        &#39;Los Angeles&#39;,</span><br><span class="line">         &#39;CA&#39;,</span><br><span class="line">        &#39;90046&#39;,</span><br><span class="line">         &#39;USA&#39;,</span><br><span class="line">          NULL,</span><br><span class="line">          NULL&#39;);</span><br></pre></td></tr></table></figure>

<h3 id="省略列"><a href="#省略列" class="headerlink" title="省略列"></a>省略列</h3><ul>
<li>该列定义为允许null值</li>
<li>在表定义中给出默认值</li>
</ul>
<h3 id="提高整体性能"><a href="#提高整体性能" class="headerlink" title="提高整体性能"></a>提高整体性能</h3><p>如果数据检索是最重要的，那你可以通过在INSERT INTO 之间添加关键字</p>
<p>LOW_PRIORITY 指示Mysql降低INSERT语句的优先级</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INSERT LOW_PRIORITY INTO</span><br></pre></td></tr></table></figure>

<h2 id="插入多个行"><a href="#插入多个行" class="headerlink" title="插入多个行"></a>插入多个行</h2><figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="function">INSERT INTO <span class="title">customers</span><span class="params">(cust_name,cust_address,cust_city,cust_state,cust_zip,cust_country,cust_contact,cust_email)</span></span></span><br><span class="line">VALUSES('PEP E.LAPEW',</span><br><span class="line">       '100 MAIN STREET',</span><br><span class="line">        'Los Angeles',</span><br><span class="line">         'CA',</span><br><span class="line">        '90046',</span><br><span class="line">         'USA',</span><br><span class="line">          <span class="literal">NULL</span>,</span><br><span class="line">          NULL'),</span><br><span class="line">       ('PEP E.LAPEW',</span><br><span class="line">       '100 MAIN STREET',</span><br><span class="line">        'Los Angeles',</span><br><span class="line">         'CA',</span><br><span class="line">        '90046',</span><br><span class="line">         'USA',</span><br><span class="line">          <span class="literal">NULL</span>,</span><br><span class="line">          NULL');</span><br></pre></td></tr></table></figure>

<p>其中单条INSERT语句有多组值，每组值用一对圆括号括起来，用逗号分隔。</p>
<h3 id="插入检索出的数据"><a href="#插入检索出的数据" class="headerlink" title="插入检索出的数据"></a>插入检索出的数据</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="function">INSERT INTO <span class="title">customers</span><span class="params">(cust_id,cust_name,cust_address,cust_city,cust_state,cust_zip,cust_country,cust_contact,cust_email)</span></span></span><br><span class="line">SELECT cust_id,cust_name,cust_address,cust_city,cust_state,cust_zip,cust_country,cust_contact,cust_email FROM custnew;</span><br></pre></td></tr></table></figure>

<p>这个例子中INSERT SELECT 从custnew中将所有数据导入到customer中。</p>
<p><strong>其实MYSQL不关心SELECT返回的列名，它使用的是列的位置，因此SELECT中的第一列用来填充表列中指定的第一列</strong>。</p>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>JDK中常用的包有哪些？</title>
    <url>/2020/05/11/JDK%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E5%8C%85%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍JDK中常用的包</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>JDK中常用的包有哪些？</p>
<ul>
<li>JAVA.lang  java语言的核心类，如String,Math,Interger,System,和Thread</li>
<li>java.io 提供多种输入/输出功能的类</li>
<li>java.net 包括执行与网络相关的操作的类</li>
<li>java.util 包括一些实用的工具类，如定义系统的特性，与日期日历相关的方法</li>
<li>java.awt 抽象窗口工具集，用来构建和管理应用程序的GUI</li>
<li>java.applet 包含applet运行所需的类</li>
<li>java.swing 用来建立图形用户界面</li>
</ul>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>JAVASE</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql必知必会</title>
    <url>/2020/05/03/mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/</url>
    <content><![CDATA[<p> 登录mysql -h localhost -u root -p<br> Show databases;<br> Use databasename;<br>Show tables;  //显示行</p>
<a id="more"></a>
<p> Show columns from xxx;   //显示列<br>SELECT DISTINCT  published FROM t_blog ;  DISTINCT此关键字指示只返回不同的值。<br> SELECT id FROM t_blog LIMIT 5;<br> SELECT id FROM t_blog LIMIT 3,3; //从第三行开始的后三行<br> SELECT t_blog.id FROM blog.t_blog;   完全限定的列名和表名 和之前的用法一样。<br> SELECT id,type_id,user_id FROM t_blog ORDER BY type_id,id;  先对type_id排序 再对id进行排序。<br> DESC 降序 ASC 升序  没多大用处<br> SELECT id FROM t_blog ORDER BY type_id LIMIT 1; 此种方式找到了数值最大的一行。<br> 在使用where 过滤时 ，order by 排序要在where的后面<br>  SELECT id FROM t_blog  where id &lt;&gt;10;   &lt;&gt; 不匹配检查<br> 范围值检查<br>  SELECT ID FROM T_BLOG WHERE ID BETWEEN 10 AND 20 :<br> Select id from t_blog where id is null;  空值检查<br> Select id,user_id from t_blog where id &lt;=10 and user_id &lt;=1;<br> Select prod_name,prod_price from products where vend_id=1002 or vend_id =1003 and<br>  Prod_price&gt;=10; SQL处理OR操作符和AND操作符时，优先处理AND操作符。<br> 故先处理 vend_id =1003 and prod_price&gt;=10  或者  vend_id=1002  ；<br>解决方法是<br>Select prod_name,prod_price from products where (vend_id =1002 or vend_id =1003) and prod_price &gt;=10    用( )来明确分组操作符。DBMS 首先过滤圆括号内的OR条件。<br>NOT 在MYSQL中的NOT中 MYSQL支持使用NOT 对IN,BETWEEN 和EXISTS子句取反。这与多数其他DBMS允许使用NOT对各种条件取反有很大区别。<br>######<br>通配符<br>用来匹配值的一部分的特殊字符<br>LIKE 指示MYSQL 后跟的搜索模式利用通配符匹配而不是直接相等匹配比较<br>SELECT prod_name FROM products WHERE prod_name REGEXP ‘[123] Ton’<br>ORDER BY prod_name;<br>正则表达式 [123]Ton 其中[123]定义一组字符<br>它的意思是匹配1或2或3  因此 1ton 和2ton 都匹配且返回了<br>[] 其实是另一种形式的OR语句<br>[1|2|3]Ton 的缩写 为 [123]Ton<br>1|2|3 Ton 的意思是检索出1或2或3 ton<br>[^123] 匹配除这些字符除外的任何东西<br> ^ 是REGEXP的否定符号<br>在匹配范围中<br>0到9  将由[0123456789] 等同于 [0-9]<br>.表示匹配一个字符<br>输入 SELECT vend_name FROM vendors WHERE vend_name REGEXP ‘.’ ORDER BY vend_name<br>.匹配任意字符  这时每一行都被检索出来 为了匹配特殊字符 必须用\ 作为前导<br>如<br>SELECT vend_name FROM vendors WHERE vend_name REGEXP ‘\.’ ORDER BY vend_name<br>这才是期望的输出 \.匹配. 这种处理就是所谓的转义。<br>？ 字符 ？匹配它前面的任何字符的0次或者1次出现。<br> 如 SELECT prod_name FROM products WHERE prod_name REGEXP ‘\([0-9] sticks?\)’<br> ORDER BY prod_name ;<br>Sticks 匹配 stick 和sticks s后的?使s可选<br>另外例如<br>SELECT prod_name FROM products WHERE prod_name REGEXP ‘[[:digit:]]{4}<br>ORDER BY prod_name；<br>[:digit:]匹配任意数字<br>因而它作为数字的一个集合<br>{4} 确切的要求它前面的字符 出现4次<br>匹配特定位置的文本，需要使用表9-4列出的定位符<br>^ 文本的开始<br>$ 文本的结尾<br>[[:&lt;:]] 词的开始<br>[[:&gt;;]] 词的结尾<br>‘^[0-9\.]’ 找出一个数 包括以小数点开始的数开始的所有产品。<br>SELECT prod_name FROM products WHERE prod_name REGEXP ‘^[0-9\.]’<br>ORDER BY prod_name;<br>在第10章 中 创建计算字段<br>MySQL 使用Concat() 函数来实现<br>SELECT Concat(vend_name,’（‘，vend_country,’）’)<br>FROM vendors ORDER BY vend_name;<br>拼接  将值联结到一起构成单个值<br>比如以上的输出为<br>ACME (USA)<br>删除数据右侧多余的空格来整理数据<br>MySQL 的RTrim()可以去掉值右边的所有的空格<br>SELECT Concat(RTrim(vend_name),’(‘,RTrim(vend_country),’)’)<br>FROM vendors<br>ORDER BY vend_name;<br>LTrim() 去掉串左边的空格<br>Trim()去掉左右俩边的空格<br>SELECT Concat (RTrim(vend_name),’(‘,RTrim(vend_country),’)’)AS vend_title FROM vendors ORDER BY vend_name;<br>一个未命名的列不能用于客户机的应用中，因为客户机没有办法去引用它。<br>所以才出现了别名。AS 关键字来赋予别名 任何客户机应用都可以按名来引用这个列，就像它是一个实际的表列一样。</p>
<p>执行算数运算<br>SELECT pro_id,quantity,item_price FROM oderitems WHERE order order_num =20005;<br>在算数运算中 检索200005中的所有物品<br>如果要计算汇总物品的价格<br>SELECT prod_id ,quantity,item_price, quantity*item_price  AS expanded_price FROM oderitems WHERE order_num =20005;<br>此时客户机可以使用这个新计算的列，就像其他列一样。<br>MYSQL 支持基本算术运算符</p>
<ul>
<li><ul>
<li>/ 圆括号可以用来区分优先顺序<br>第十一章 使用数据来处理函数<br>SELECT vend_name,Upper(vend_name) AS  vend_name_upcase FROM vendors ORDER BY vend_name;<br>Upper()将文本转换为大写<br>常用的文本处理函数：<br>Left() 返回串左边的字符<br>Length() 返回串的长度<br>Locate()返回串的一个子串<br>Lower()将串转换为小写<br>LTrim() 去掉左边的空格<br>Right()返回串右边的字符<br>RTrim() 去掉串右边的空格<br>Soundex()返回串的Soundex值<br>SubString() 返回子串的字符<br>Upper() 大写<br>Soundex（） 将任何文本串转换为描述其语音表示的字母数字模式的算法<br>如<br>SELECT cust_name ,cust_contact FROM customers WHERE cust_contact =’Y.Lie’;<br>其联系名是为Y.Lee 此时没办法搜索到<br>但是通过<br>SELECT cust_name,cust_contact FROM customers WHERE Soundex(cust_contact)=Soundex(‘Y.lie);<br>此时可以搜索到Y.Lee<br>日期和时间的处理函数<br>Date() 返回日期部分的日期部分<br>Year() 返回日期部分的年份部分<br>Day()<br>Month()</li>
</ul>
</li>
</ul>
<p>如：<br>SELECT cust_id,oder_num FROM oders WHERE Date(order_date)=’2005-09-01’;<br>SELECT cust_id,order_num FROM orders WHERE Date(order_date) BETWEEN ‘2005-09-01’AND’2005-03-30’;<br>数值处理函数<br>Abs() 返回数的绝对值</p>
<p>Cos() 角度的余弦<br>Exp() 返回一个数的指数值<br>Mod() 操作数的余数<br>……<br>第12章 汇总数据<br>12.1 聚集函数  运行在行组上，计算和返回单个值得函数<br>AVG() 返回某列的平均值<br>COUNT()  返回某列的行数<br>MAX() 返回某列的最大值<br>MIN() 返回某列的最小值<br>SUM() 返回某列值之和<br>SELECT AVG(prod_price) AS avg_price FROM products;<br>AVG() 也可以用来确定列或行当平均值<br>SELECT AVG(prod_price) AS avg_price FROM products WHERE vend_id =1003;<br>COUNT () 函数<br>COUNT(<em>)对表中的行的数目进行技术<br>COUNT(column) 对特定列中具有值的行进行计数<br>例如SELECT COUNT(</em>) AS num_cust FROM customers;<br>利用COUNT(<em>)对所有行计数<br>SELECT COUNT(cust_email) AS num_cust FROM customers;<br>对于cust_email中所有有值的行进行计数<br>MAX() 指定列中的最大值 MAX()要求指定列名。<br>MIN()<br>SUM() 也可以用来合计计算值 用来得出总的订单金额<br>SELECT SUM(item_price  *quantity) AS total_price FROM oderitems WHERE order_num=20005;<br>SUM(item_price *quantity) 返回订单中所有物品价钱之和<br>第13章 分组数据<br>SELECT vend_id ,COUNT(</em>) AS num_prods FROM products GROUP BY vend_id;<br>Vend_id num_prods<br>1001        3<br>1002        2<br>1003        7<br>1005        2<br>上述语句将vend_id进行分组，GROUP BY 对于分组的整个结果集进行聚集<br>使用ROLLUP 使用WITH ROLLUP 关键字，将得到每个分组以及分组汇总级别的值<br>2如何过滤分组?<br>HAVING<br>如： SELECT cust_id ,COUNT(<em>)AS orders FROM orders GROUP BY cust_id<br>HAVING COUNT(</em>) &gt;=2<br>它过滤COUNT(<em>)&gt;=2 的那些分组<br>输入： SELECT vend_id,COUNT(</em>) AS num_prods FROM products WHERE prod_price &gt;=10<br>GROUP BY vend_id HAVING COUNT(<em>)&gt;=2;<br>13.4 分组和排序<br>GROUP BY 和ORDER BY<br>GROUP BY  是在ORDER BY 之前，在where 之后<br>第14章 子查询<br>子查询：嵌套在其他查询中的查询<br>1 检索包含物品TNT2 的所有订单的编号<br> SELECT order_num FROM orderitems WHERE prod_id =’TNT2’；<br>2 检索具有前一步骤列出的订单编号的所有客户的ID<br> SELECT cust_id FROM orders WHERE order_num IN (20005,20007);<br>3 现在把第一个查询变为子查询 组合成俩个查询：<br> SELECT cust_id FROM oders WHERE order_num IN (SELECT order_num FROM orderitems WHERE prod_id =’TNT2’);<br>在SELECT 语句中，子查询总是从内向外查询处理。<br>检索这些客户的ID的客户信息，检索俩列的SQL语句为：<br>SELECT cust_name, cust_contact FROM customers WHERE cust_id IN (10001,10004);<br>则可以转换为：<br>SELECT cust_name ,cust_contact FROM customers WHERE cust_id IN (SELECT cust_id FROM orders WHERE order_num IN (SELECT order_num FROM orderitems WHERE prod_Id =’TNT2’))；<br>计算结果子查询：<br>SELECT cust_name,cust_state,(SELECT COUNT(</em>) FROM oders WHERE orders.cust_id=customers.cust_id)AS orders FROM customers ORDER BY cust_name;<br>第15 章  联结表  join 表<br>外键位某个表中的一列 它包含另一个表的主键值定义了俩个表之间的关系。<br>SELECT vent_name,prod_name,prod_price<br>FROM vendors ,products<br>WHERE vendors.vend_id=products.vend_id;<br>ORDER BY vend_name,prod_name ;<br>此种方法通过WHERE子句来限定了列名 ，如果要给出 vend_id 那么mysql_id 并不知道是哪个<br>存在一种状况是<br>笛卡尔积：<br>在不指定where子句时<br>：<br>SELECT vend_name ,prod_name,prod_price<br>FROM vendors,products ORDER BY vend_name,prod_name;<br>15.2.2 内部联结<br>目前为止所使用的联结称为 等值联结  它基于俩个表之间的相等测试 这种联结也叫内部联结。<br>SELECT vend_name , prod_name , prod_price FROM vendors INNER JOIN products ON vendors.vend_id =products.vend_id ;<br>此时使用的是INNER JOIN  联结条件用的是ON<br>联结多个表：<br>SELECT prod_name,vend_name,prod_price,quantity FROM orderitems,products,vendors WHERE products.vend_id =vendors.vend_id AND orderitems.prod_id =products.prod_id AND order_num =20005;<br>第16章 创建高级联结<br>使用表别名<br>SELECT Concat(RTrim(vend_name)，‘（’，RTrim（vend_country）,’）’) AS vend_title FROM vendors ORDER BY vend_name;<br>内部联结：<br>它基于俩个表之间的相等测试<br>SELECT vend_name .prod_name,prod_price FROM vendors INNER JOIN products ON vendors.vend_id =produces.vend_id;<br>自联结： 引用别名，自己联结自己<br>SELECT p1.prod_id,p1.prod_name FROM products AS p1,products AS p2<br>WHERE p1.vend_id =p2.vend_id AND p2.prod_id =’DTNTR’;<br>此查询种需要的俩个表实际上是相同的表。<br>因此products 表在from 子句中出现了俩次。虽然这是合法的，但是对products 的引用具有二义性。因此使用了别名。（用自联结而不用子查询。有时候处理联结要比处理查询要快的多）<br>自然联结：<br>其中你只能选择那些唯一的列。<br>通过对表使用通配符（SELECT <em>）对所有其他表的列使用明确的子集来完成的。<br>SELECT c.</em>,o.ordr_num,o.order_date,oi.prod_id,oi.quantity,OI.item_price FROM customers AS c,orders AS o,orderitems AS oi WHERE c.cust_id =o.cust_id AND oi.order_num =o.order_num<br>AND prod_id =’FB’;<br>通配符只对第一个表使用，所有其他列明确列出，所以没有重复的列被检索出来。<br>外部联结：<br>许多联结将一个表中的行与另外一个表中的行相关联，但有时候会需要包含没有关联行的那些行，例如  可能需要使用联结来完成以下的工作：<br>1对每个客户下了多少订单进行计数，包括那些至今未下订单的客户。<br>2列出所有产品以及订购数量，包括没有人订购的产品<br>3计算平均销售规模，包括那些至今未下订单的客户<br>联结包含了那些在相关表中没有关联行的行，这种叫做外部联结<br>内部联结检索所有客户及其订单：<br>SELECT customers.cust_id,order.orders.order_num FROM customers INNER JOIN orders ON<br>Customers.cust_id =orders.cust_id;<br>外部联结：<br>SELECT customers.cust_id ,orders.order_num FROM customers LEFT OUTER JOIN oders<br>ON customers.cust_id =orders.cust_id;<br>输出为：<br> cust_id   order_num<br>  10001      20005<br>  10001      20009<br>  10002       null<br> 10003       null<br>此时必须要用RIGHT 或LEFT 关键字指定包括其所有行的表<br>其实就是左外部联结和右外部联结<br>16.3 使用带聚集函数的联结<br>使用了COUNT（）函数的联结<br>SELECT customers.cust_name, customers.cust_id,COUNT(orders.order_num) AS num_ord FROM customers INNER JOIN orders ON customers.cust_id =orders.cust_id GROUP BY customers.cust_id;<br>SELECT 语句使用INNER JOIN 将customers和orders 表互相关联。 GROUP BY 子句按客户分组数据。<br>聚集函数也可以方便地与其他联结一起使用，<br>如 SELECT customers,cust_name,cusomers,cust_id,COUNT(orders,order_num)AS num_ord FROM customers LEFT OUTER JOIN orders ON customers.cust_id =orders.cust_id  GROUP BY customers.cust_id;<br>17 章 组合查询<br>利用UNION 操作符将多条SELECT 语句组合成一个结果集<br>执行多个查询，多个SELECT 语句 并将结果作为单个查询结果集返回。<br>这种称为并（union）或复合查询<br>使用UNION<br>输入<br>SELECT vend_id ,prod_id ,prod_price FROM products WHERE prod_price &lt;=5<br>UNION<br>SELECT vend_id,prod_id,prod_price FROM products WHERE vend_id IN(1001,1002);<br>也可以使用多个where<br>SELECT vend_id ,prod_id,prod_price FROM products WHERE prod_price &lt;=5 OR vend_id IN<br>(1001,1002);<br>从多个表中检索数据的情形，使用UNION 可能会处理更简单。<br>17.2.2 UNION 规则<br> 1   UNION 的每个查询必须包含相同的列，表达式，或聚集函数</p>
<p> 2   UNION 的默认行为，如果想返回所有匹配行 可以使用UNION ALL 而不是UNION<br> 17.2.4 对组合查询结果排序<br>SELECT vend_id ,prod_id,prod_price FROM products WHERE prod_price &lt;=5<br>UNION<br>SELECT vend_id,prod_id,prod_price FROM products WHERE vend_id IN (1001,1002)<br>ORDER BY vend_id ,prod_price ;<br>18章 全文本搜素<br>18.1 理解全文本搜素</p>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql更新和删除数据</title>
    <url>/2020/05/07/mysql%E6%9B%B4%E6%96%B0%E5%92%8C%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍如何利用UPDATA和DELETE语句进一步操控表数据</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h2 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h2><ul>
<li>更新特定行</li>
<li>更新所有行 <strong>特别注意不要省略WHERE子句 稍不注意就会更新表中的所有行</strong></li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">UPDATA customers SET cust_email ='elmer@gmail.com' WHERE cust_id =10005;</span><br></pre></td></tr></table></figure>

<p>更新多个列： 用逗号分隔</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">UPDATE customers SET cust_name='The Fudds',</span><br><span class="line">cust_email='elmer@gmail.com'</span><br><span class="line">WHERE cust_id =<span class="number">10005</span>;</span><br></pre></td></tr></table></figure>

<h3 id="IGNORE关键字"><a href="#IGNORE关键字" class="headerlink" title="IGNORE关键字"></a>IGNORE关键字</h3><p>如果用UPDATE 语句更新多行，并且在更新这些行中的一行或多行时出现一个现错误，则整个UPDATE操作被取消。</p>
<p>为即使是发生错误，也继续进行更新可以使用<strong>IGNORE</strong>关键字</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">UPDATE IGNORE customers...</span><br></pre></td></tr></table></figure>

<h2 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h2><ul>
<li>从表中删除特定的行</li>
<li>从表中删除所有行  <strong>不要省略WHERE子句</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">DELETE FROM customers WHERE cust_id =<span class="number">10006</span>;</span><br></pre></td></tr></table></figure>

<h3 id="更快的删除"><a href="#更快的删除" class="headerlink" title="更快的删除"></a>更快的删除</h3><p>如果想删除所有行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TRUNCATE TABLE</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql联结表</title>
    <url>/2020/05/08/mysql%E8%81%94%E7%BB%93%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍联结以及高级联结。</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h2 id="创建联结"><a href="#创建联结" class="headerlink" title="创建联结"></a>创建联结</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SELECT vent_name,prod_name,prod_price </span><br><span class="line">FROM vendors ,products </span><br><span class="line">WHERE vendors.vend_id=products.vend_id;</span><br><span class="line">ORDER BY vend_name,prod_name ;</span><br></pre></td></tr></table></figure>

<h2 id="内部联结"><a href="#内部联结" class="headerlink" title="内部联结"></a>内部联结</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SELECT vend_name , prod_name , prod_price FROM vendors INNER JOIN products ON vendors.vend_id =products.vend_id ;</span><br></pre></td></tr></table></figure>

<p>此时使用的是INNER JOIN 联结条件用的是ON</p>
<p>联结多个表：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SELECT prod_name,vend_name,prod_price,quantity FROM orderitems,products,vendors WHERE products.vend_id =vendors.vend_id AND orderitems.prod_id =products.prod_id AND order_num =<span class="number">20005</span>;</span><br></pre></td></tr></table></figure>

<h2 id="创建高级联结"><a href="#创建高级联结" class="headerlink" title="创建高级联结"></a>创建高级联结</h2><h3 id="使用表别名"><a href="#使用表别名" class="headerlink" title="使用表别名"></a>使用表别名</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">SELECT <span class="title">Concat</span><span class="params">(RTrim(vend_name)，‘（’，RTrim（vend_country）,’）’)</span> AS vend_title FROM vendors ORDER BY vend_name</span>;</span><br></pre></td></tr></table></figure>

<h3 id="内部联结："><a href="#内部联结：" class="headerlink" title="内部联结："></a>内部联结：</h3><p>它基于俩个表之间的相等测试</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SELECT vend_name .prod_name,prod_price FROM vendors INNER JOIN products ON vendors.vend_id =produces.vend_id;</span><br></pre></td></tr></table></figure>

<h3 id="自联结：-引用别名，自己联结自己"><a href="#自联结：-引用别名，自己联结自己" class="headerlink" title="自联结： 引用别名，自己联结自己"></a>自联结： 引用别名，自己联结自己</h3><p>假如你发现某物品（其ID为DTNRT)存在问题，因此想知道生产该物品的供应商生产的其他物品是否也存在这些问题。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SELECT p1.prod_id,p1.prod_name FROM products AS p1,products AS p2</span><br><span class="line">WHERE p1.vend_id =p2.vend_id AND p2.prod_id =’DTNTR’;</span><br></pre></td></tr></table></figure>

<p>因此products 表在from 子句中出现了俩次。虽然这是合法的，但是对products 的引用具有二义性。因此使用了别名。（用自联结而不用子查询。有时候处理联结要比处理查询要快的多）</p>
<h3 id="自然联结"><a href="#自然联结" class="headerlink" title="自然联结"></a>自然联结</h3><p><strong>自然联结的意思是排除多次出现，使每个列只返回一次。</strong></p>
<p><strong>我们建立的每个内部联结都是自然联结。</strong></p>
<p>示例通过对表使用通配符（SELECT *）对所有其他表的列使用明确的子集来完成的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SELECT c.*,o.ordr_num,o.order_date,oi.prod_id,oi.quantity,OI.item_price FROM customers AS c,orders AS o,orderitems AS oi WHERE c.cust_id =o.cust_id AND oi.order_num =o.order_num</span><br><span class="line">AND prod_id =’FB’;</span><br></pre></td></tr></table></figure>

<p>通配符只对第一个表使用，所有其他列明确列出，但没有重复的列被检索出来。</p>
<h3 id="外部联结："><a href="#外部联结：" class="headerlink" title="外部联结："></a>外部联结：</h3><p><strong>许多联结将一个表中的行与另外一个表中的行相关联，但有时候会需要包含没有关联行的那些行，</strong>例如 可能需要使用联结来完成以下的工作：</p>
<ul>
<li>对每个客户下了多少订单进行计数，包括那些至今未下订单的客户。</li>
<li>列出所有产品以及订购数量，包括没有人订购的产品</li>
<li>计算平均销售规模，包括那些至今未下订单的客户</li>
</ul>
<p><strong>联结包含了那些在相关表中没有关联行的行，这种叫做外部联结</strong>     </p>
<p>内部联结检索所有客户及其订单：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT customers.cust_id,order.orders.order_num FROM customers INNER JOIN orders ON</span><br><span class="line">Customers.cust_id &#x3D;orders.cust_id;</span><br></pre></td></tr></table></figure>

<p>外部联结：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SELECT customers.cust_id ,orders.order_num FROM customers LEFT OUTER JOIN oders </span><br><span class="line">ON customers.cust_id =orders.cust_id;</span><br></pre></td></tr></table></figure>

<p>输出为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cust_id   order_num</span><br><span class="line"> 10001      20005</span><br><span class="line"> 10001      20009</span><br><span class="line"> 10002       null</span><br><span class="line"> 10003       null</span><br></pre></td></tr></table></figure>

<p>此时必须要用RIGHT 或LEFT 关键字指定包括其所有行的表，如果是<strong>LEFT</strong>，就<strong>指出包括OUTER JOIN左边表的所有行</strong>。示例是包括（customers)表种所有行。</p>
<p>其实就是左外部联结和右外部联结</p>
<h3 id="使用带聚集函数的联结"><a href="#使用带聚集函数的联结" class="headerlink" title="使用带聚集函数的联结"></a>使用带聚集函数的联结</h3><p>使用了COUNT（）函数的联结</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT customers.cust_name, customers.cust_id,COUNT(orders.order_num) AS num_ord FROM customers INNER JOIN orders ON customers.cust_id &#x3D;orders.cust_id GROUP BY customers.cust_id;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT customers,cust_name,cusomers,cust_id,COUNT(orders,order_num)AS num_ord FROM customers LEFT OUTER JOIN orders ON customers.cust_id &#x3D;orders.cust_id  GROUP BY customers.cust_id;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql视图</title>
    <url>/2020/05/09/mysql%E8%A7%86%E5%9B%BE/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍视图究竟是什么，它们怎么样工作，何时使用它们。</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>视图是 虚拟的表，与包含数据的表不一样，视图只包含使用时动态检索数据的查询。</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT cust_name ,cust_contact FROM customers ,orders ,orderitems WHERE customers.cust_id&#x3D;orders.cust_id  AND orderitems.order_num &#x3D;orders.order_num</span><br><span class="line">AND prod_id &#x3D;&#39;TNT2&#39;;</span><br></pre></td></tr></table></figure>

<p>假设把整个查询包装成一个名叫productcustomers的虚拟表，则</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT cust_name,cust_contact FROM productcustomers WHERE prod_id&#x3D;&#39;TNT2&#39;;</span><br></pre></td></tr></table></figure>

<h3 id="为什么使用视图"><a href="#为什么使用视图" class="headerlink" title="为什么使用视图"></a>为什么使用视图</h3><ul>
<li>重用SQL 语句</li>
<li>简化复杂的SQL语句，在编写查询后，可以方便地重用它而不必知道它的基本查询细节。</li>
<li>使用表的组成部分而不是整个表</li>
<li>保护数据，可以给用户授予表的特定部分的访问权限，而不是整个表的访问权限。</li>
<li>更改数据格式和表示。</li>
</ul>
<h3 id="视图的规则和限制"><a href="#视图的规则和限制" class="headerlink" title="视图的规则和限制"></a>视图的规则和限制</h3><ul>
<li>视图必须唯一命名</li>
<li>对于创建的视图数目没有限制</li>
<li>视图可以嵌套</li>
<li>视图不能索引，不能有关联的触发器或者默认值</li>
</ul>
<h3 id="使用视图"><a href="#使用视图" class="headerlink" title="使用视图"></a>使用视图</h3><ul>
<li>视图用CREATE VIEW 来创建 </li>
<li>使用SHOW CREATE VIEW viewname; 来查看创建视图的语句</li>
<li>用DROP 来删除视图。语法为DROP VIEW viewname;</li>
<li>更新视图时，可以 先用DROP 再用CREATE  也可以直接使用CREATE OR REPLACE VIEW</li>
<li>可以先用DROP 再用 CREATE  也可以直接用CREATE OR REPLACE VIEW</li>
</ul>
<h3 id="利用视图简化复杂的联结"><a href="#利用视图简化复杂的联结" class="headerlink" title="利用视图简化复杂的联结"></a>利用视图简化复杂的联结</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">CREATE VIEW productcustomers AS SELECT cust_name,cust_contact,prod_id</span><br><span class="line">FROM customers,orders,orderitems WHERE customers.cust_id=orders.cust_id</span><br><span class="line">AND orderitems.order_num =orders.order_name;</span><br></pre></td></tr></table></figure>

<p>那么为了检索订购产品的TNT2客户</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">SELECT cust_name,cust_contact FROM productcustomers WHERE prod_id ='TNT2';</span><br></pre></td></tr></table></figure>

<h3 id="使用视图重新格式化检索出的数据"><a href="#使用视图重新格式化检索出的数据" class="headerlink" title="使用视图重新格式化检索出的数据"></a>使用视图重新格式化检索出的数据</h3><p>下面的SELECT  语句在单个组合计算列中返回供应商名和位置</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">SELECT <span class="title">Concat</span><span class="params">(RTrim(vend_name),<span class="string">'('</span>,RTrim(vend_country),<span class="string">')'</span>)</span> AS vend_title</span></span><br><span class="line"><span class="function">FROM vendors</span></span><br><span class="line"><span class="function">ORDER BY vend_name</span>;</span><br><span class="line"><span class="comment">/*out </span></span><br><span class="line"><span class="comment">    vend_title</span></span><br><span class="line"><span class="comment">    ACME  (USA)</span></span><br><span class="line"><span class="comment">    Jet Set (England)</span></span><br><span class="line"><span class="comment">    LT Supplies (USA)</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p>现在，假如经常需要这个格式的结果，不必在每次需要时执行联结，创建一个视图</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">CREATE VIEW vendorlocations AS SELECT <span class="title">Concat</span><span class="params">(RTrim(vend_name),<span class="string">'('</span>,RTrim(vend_country),<span class="string">')'</span>)</span> AS vend_title</span></span><br><span class="line"><span class="function">FROM vendors</span></span><br><span class="line"><span class="function">ORDER BY vend_name</span>;</span><br></pre></td></tr></table></figure>

<p>now </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM vendorlocations;</span><br></pre></td></tr></table></figure>

<h3 id="使用视图过滤不想要的数据"><a href="#使用视图过滤不想要的数据" class="headerlink" title="使用视图过滤不想要的数据"></a>使用视图过滤不想要的数据</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE VIEW customeremaillist AS SELECT cust_id,cust_name,cust_email FROM customers WHERE cust_email IS NOT NULL;</span><br></pre></td></tr></table></figure>

<p>在发送电子邮件到邮件列表时，需要排除没有电子邮件地址的用户</p>
<p>现在，可以像使用其他表一样使用视图customeremaillist </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM customeremaillist;</span><br></pre></td></tr></table></figure>

<h3 id="使用视图与计算字段"><a href="#使用视图与计算字段" class="headerlink" title="使用视图与计算字段"></a>使用视图与计算字段</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SELECT prod_id,</span><br><span class="line">       quantity,</span><br><span class="line">       item_price,</span><br><span class="line">       quantity*item_price AS expanded_price</span><br><span class="line">FROM orderitems</span><br><span class="line">WHERE order_num =<span class="number">20005</span>;</span><br></pre></td></tr></table></figure>

<p>现在转换为视图</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE VIEW orderitemsexpanded AS </span><br><span class="line">SELECT order_num,</span><br><span class="line">       prod_id,</span><br><span class="line">       quantity,</span><br><span class="line">       item_price,</span><br><span class="line">       quantity*item_price AS expanded_price</span><br><span class="line">FROM orderitems;</span><br></pre></td></tr></table></figure>

<p>检索订单20005的详细内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM orderitemsexpanded WHERE order_num &#x3D;20005;</span><br></pre></td></tr></table></figure>

<h3 id="更新视图"><a href="#更新视图" class="headerlink" title="更新视图"></a>更新视图</h3><p>视图是可更新的，更新一个视图将更新其基表。如果你对视图增加或者删除行，实际上是对其基表增加或者删除行。</p>
<p>但是并非所有的视图都是可更新的</p>
<ul>
<li>分组 （使用GROUP BY 和 HAVING )</li>
<li>联结</li>
<li>子查询</li>
<li>并</li>
<li>聚集函数 （Min() ,Count(),Sum() 等）；</li>
<li>DISTINCT;  （用于返回不重复的值 ，select distinct name,id from A</li>
<li>导出（计算）列</li>
</ul>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>两数之和</title>
    <url>/2020/05/25/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h4 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a><a href="https://leetcode-cn.com/problems/two-sum/" target="_blank" rel="noopener">1. 两数之和</a></h4><p>难度简单8282</p>
<p>给定一个整数数组 <code>nums</code> 和一个目标值 <code>target</code>，请你在该数组中找出和为目标值的那 <strong>两个</strong> 整数，并返回他们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。</p>
<p><strong>示例:</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">给定 nums = [<span class="number">2</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>], target = <span class="number">9</span></span><br><span class="line"></span><br><span class="line">因为 nums[<span class="number">0</span>] + nums[<span class="number">1</span>] = <span class="number">2</span> + <span class="number">7</span> = <span class="number">9</span></span><br><span class="line">所以返回 [<span class="number">0</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<p>Solution:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span>  <span class="title">Solution</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> [] twoSum(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> target)</span><br><span class="line">    &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(target-nums[i]))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;map.get(target-nums[i]),i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉查找树</title>
    <url>/2020/05/14/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>定义：一棵二叉查找树 （BST）是一棵二叉树，其中每个结点都含有一个 Comparable 的键（以及相关联的值）且每个结点的键都大于其左子树中的任意结点的键而小于右子树的任意结点的键。  </p>
<p><img src="https://photos.alitaalice.cn/image/20200514134241.png" alt=""></p>
<h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p>一般来说，在符号表中查找一个键可能得到两种结果。如果含有该键的结点存在于表中，我们的查找就命<br>中 了，然后返回相应的值。否则查找未命中 （并返回 null ）。根据数据表示的递归结构我们马上就能得到，在二叉查找树中查找一个键的递归算法：如果树是空的，则查找未命中；如果被查找的键和根结点的键相等，查找命中，否则我们就（递归地）在适当的子树中继续查找。如果被查找的键较小就选择左子树，较大则选择右子树。算法 3.3（续 1）中递归的 get() 方法完全实现了这段算法。它的第一个参 数是一个结点（子树的根结点），第二个参数是被查找的键。  </p>
]]></content>
  </entry>
  <entry>
    <title>二叉树</title>
    <url>/2020/05/07/%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本文。</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h2 id="二叉树的特点"><a href="#二叉树的特点" class="headerlink" title="二叉树的特点"></a>二叉树的特点</h2><ul>
<li><p>每个结点最多有俩颗子树。所以二叉树中不存在大于2的结点。</p>
</li>
<li><p>左子树和右子树是有顺序的，次序不能随意颠倒。</p>
</li>
<li><p>即使树中某结点只有一颗子树，也要区分它是左子树还是右子树</p>
<h3 id="二叉树的5种形态"><a href="#二叉树的5种形态" class="headerlink" title="二叉树的5种形态"></a>二叉树的5种形态</h3><ul>
<li>空二叉树</li>
<li>只有一个根结点</li>
<li>根节点只有左子树</li>
<li>根节点只有右子树</li>
<li>根节点既有左子树又有右子树</li>
</ul>
</li>
</ul>
<h2 id="特殊二叉树"><a href="#特殊二叉树" class="headerlink" title="特殊二叉树"></a>特殊二叉树</h2><ol>
<li><p>斜树</p>
<p>所有结点都只有左子树的二叉树叫做左斜树</p>
<p>所有结点都只有右子树的二叉树叫做右斜树</p>
<p>俩者统称为斜树</p>
</li>
<li><p>满二叉树</p>
<p>在一颗二叉树中，如果所有分支结点都存在左子树和右子树，并且所有叶子都在同一层上，这样的二叉树叫做满二叉树</p>
</li>
<li><p>完全二叉树</p>
<p>对一颗具有n个结点的二叉树按照层序编号，如果编号为i（1&lt;=i&lt;=n)的结点与同样深度的满二叉树中编号为i的结点在二叉树中位置完全相同，则这颗二叉树称为完全二叉树。</p>
</li>
</ol>
<h2 id="二叉树的性质"><a href="#二叉树的性质" class="headerlink" title="二叉树的性质"></a>二叉树的性质</h2><h3 id="二叉树性质1"><a href="#二叉树性质1" class="headerlink" title="二叉树性质1"></a>二叉树性质1</h3><p>性质1：在二叉树的第i层上至多有2^(i-1) 个结点。（i&gt;=1)</p>
<h3 id="二叉树性质2"><a href="#二叉树性质2" class="headerlink" title="二叉树性质2"></a>二叉树性质2</h3><p>性质2：深度为k的二叉树至多有2^(k) -1个结点 （k&gt;=1)   (<strong>结点的总量</strong>)</p>
<h3 id="二叉树性质3"><a href="#二叉树性质3" class="headerlink" title="二叉树性质3"></a>二叉树性质3</h3><p>性质3：对于任何一颗二叉树T，如果其终端结点数为n0，度为2的结点数为n2，则n0=n2+1</p>
<h3 id="二叉树性质4"><a href="#二叉树性质4" class="headerlink" title="二叉树性质4"></a>二叉树性质4</h3><p>性质4： 具有n个结点的完全二叉树的深度为[log2 n]+1 ([x]表示不大于x的最大整数)</p>
<h3 id="二叉树性质5"><a href="#二叉树性质5" class="headerlink" title="二叉树性质5"></a>二叉树性质5</h3><p><strong>性质5： 如果对一颗有n个结点的完全二叉树（其深度为[log2 n]+1)的结点按层序编号，对任一结点i（1&lt;=i&lt;=n)</strong></p>
<p><strong>有</strong></p>
<ol>
<li><strong>如果i=1,则结点i是二叉树的根，无双亲;如果i&gt;1,则其双亲是结点[i/2]</strong></li>
<li><strong>如果2i&gt;n,则结点i无左孩子（结点i为叶子结点）；否则其左孩子是结点2i</strong></li>
<li><strong>如果2i+1&gt;n,则结点i无右孩子；否则其右孩子是结点2i+1</strong></li>
</ol>
<h2 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h2><h4 id="二叉树的顺序存储结构"><a href="#二叉树的顺序存储结构" class="headerlink" title="二叉树的顺序存储结构"></a>二叉树的顺序存储结构</h4><p>用一维数组存储二叉树的结点，并且结点的位置，也就是数组的下标要能体现结点之间的逻辑关系。</p>
<p>一般来说顺序存储用于完全二叉树</p>
<h4 id="二叉链表"><a href="#二叉链表" class="headerlink" title="二叉链表"></a>二叉链表</h4><p>二叉树的每个结点最多有俩个孩子。所以为它设计一个数据域，和俩个指针域是比较自然的想法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lchid -- data --rchild</span><br></pre></td></tr></table></figure>

<p>lchild 和 rchild 都是指针域</p>
<p><strong>二叉树的二叉链表结点结构定义</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef struct BiTNode</span><br><span class="line">&#123;</span><br><span class="line">   TElemType data; &#x2F;&#x2F;结点数据</span><br><span class="line">   struct BiTNode *lchild ,*rchild;</span><br><span class="line">&#125; BiTNode, *BiTree;</span><br></pre></td></tr></table></figure>

<p>图示：</p>
<h2 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h2><p>二叉树的定义：</p>
<p><strong>二叉树的遍历是指从根节点出发，按照某种次序依次访问二叉树中的所有结点，使得每个结点被访问且仅被访问一次。</strong></p>
<h3 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h3><p>规则：若二叉树为空，则空操作返回，否则先访问根结点，然后前序遍历左子树，再前序遍历右子树。</p>
<p>如图：</p>
<p><img src="TIM%E5%9B%BE%E7%89%8720200510112558.png" alt=""></p>
<h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><p>规则： 若树为空，则空操作返回，否则从根节点开始（注意并不是先访问根节点），中序遍历根节点的左子树，然后是访问根节点，最后中序遍历右子树。</p>
<p><img src="TIM%E5%9B%BE%E7%89%8720200510113141.png" alt=""></p>
<h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><p>规则： 若树为空，则空操作返回，否则从左到右先叶子后结点的方式遍历访问左右子树，最后是访问根结点。</p>
<p>图示：</p>
<p><img src="TIM%E5%9B%BE%E7%89%8720200510113343.png" alt=""></p>
<h3 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h3><p>规则：若树为空，则空操作返回。</p>
<p>否则从树的第一层，也就是根节点开始访问，从上而下逐层遍历，在同一层中，按从左到右的顺序对结点逐个访问。</p>
<p><img src="TIM%E5%9B%BE%E7%89%8720200510113800.png" alt=""></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>DataStructure</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的遍历</title>
    <url>/2020/05/11/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍二叉树的遍历</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h2 id="前序遍历算法"><a href="#前序遍历算法" class="headerlink" title="前序遍历算法"></a>前序遍历算法</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrderTraverse</span><span class="params">(BiTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(T==<span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%c"</span>,T-&gt;data);</span><br><span class="line">    PreOrderTraverse(T-&gt;lchild);</span><br><span class="line">    PreOrderTraverse(T-&gt;rchild);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>递归调用PreOrderTaverse()函数</p>
<h2 id="中序遍历算法"><a href="#中序遍历算法" class="headerlink" title="中序遍历算法"></a>中序遍历算法</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrderTraverse</span><span class="params">(BiTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(T=<span class="literal">NULL</span>)</span><br><span class="line">  <span class="keyword">return</span> ;</span><br><span class="line">  InOrderTraverse(T-&gt;lchild);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%c"</span>,T-&gt;data);</span><br><span class="line">  InOrderTraverse(T-rchild);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>递归调用InOrderTraverse()</p>
<h2 id="后序遍历算法"><a href="#后序遍历算法" class="headerlink" title="后序遍历算法"></a>后序遍历算法</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrderTraverse</span><span class="params">(BiTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(T==<span class="literal">NULL</span>)</span><br><span class="line">  <span class="keyword">return</span> ;</span><br><span class="line">  PostOrderTraverse(T-&gt;lchild);</span><br><span class="line">  PostOrderTraverse(T-&gt;rchild);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%c"</span>,T-&gt;data);</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



































































































































































































































































]]></content>
  </entry>
  <entry>
    <title>使用事务处理</title>
    <url>/2020/05/15/%E4%BD%BF%E7%94%A8%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍什么是事务处理以及如何利用COMMIT和ROLLBACK语句来管理事务处理  .</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>MyISAM和<strong>InnoDB</strong>是两种最常使用的引擎。前者不支持明确的事务处理管理，而后者支持。  </p>
<p><strong>事务处理（transaction processing）可以用来维护数据库的完整性，它保证成批的MySQL操作要么完全执行，要么完全不执行。</strong>  </p>
<p><strong>事务处理是一种机制，用来管理必须成批执行的MySQL操作，以保证数据库不包含不完整的操作结果。利用事务处理，可以保证一组操作不会中途停止，它们或者作为整体执行，或者完全不执行（除非明确指示）。如果没有错误发生，整组语句提交给（写到）数据库表。如果发生错误，则进行回退（撤销）以恢复数据库到某个已知且安全的状态 .</strong> </p>
<p><img src="https://photos.alitaalice.cn/image/20200515163050.png" alt=""></p>
<h2 id="1控制事务处理"><a href="#1控制事务处理" class="headerlink" title="1控制事务处理"></a>1控制事务处理</h2><p>MySQL-使用下面的语句来标识事务的开始  ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">START TRANSACTION</span><br></pre></td></tr></table></figure>

<p>MySQL的ROLLBACK命令用来回退（撤销） MySQL语句，请看下面的语句：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SELECT * FROM ordertotals;</span><br><span class="line">START TRANSACTION;</span><br><span class="line">DELETE FROM ordertotals;</span><br><span class="line">SELECL * FROM ordertotals;</span><br><span class="line">ROLLBACK;</span><br><span class="line">SELECT * FROM ordertotals;</span><br></pre></td></tr></table></figure>

<p>ROLLBACK只能在一个事务处理内使用（在执行一条START<br> TRANSACTION命令之后）  .</p>
<p>事务处理用来<strong>管理INSERT、 UPDATE和DELETE语</strong>句。你不能回退SELECT语句。（这样做也没有什么意义。）你不能<strong>回退CREATE或DROP</strong>操作。事务处理块中可以使用这两条语句，但如果你执行回退，它们不会被撤销。  </p>
<h2 id="2-使用COMMIT"><a href="#2-使用COMMIT" class="headerlink" title="2 使用COMMIT"></a>2 使用COMMIT</h2><p>一般的MySQL语句都是直接针对数据库表执行和编写的。这就是<br>所谓的隐含提交（implicit commit），即提交（写或保存）操作是自动进行的。  </p>
<p>在事务处理块中，提交不会隐含地进行。为进行明确的提交，<br>使用COMMIT语句 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">START TRANSACTION;</span><br><span class="line">DELETE FROM orderitems WHERE order_num =<span class="number">20010</span>;</span><br><span class="line">DELETE FROM orders WHERE order_num=<span class="number">20010</span>;</span><br><span class="line">COMMIT;</span><br></pre></td></tr></table></figure>

<p>隐含事务关闭 当COMMIT或ROLLBACK语句执行后，事务会自动关闭（将来的更改会隐含提交）。  </p>
<h3 id="3-使用保留点"><a href="#3-使用保留点" class="headerlink" title="3 使用保留点"></a>3 使用保留点</h3><p>为了支持回退部分事务处理，必须能在事务处理块中合适的位置放<br>置占位符。这样，如果需要回退，可以回退到某个占位符。      </p>
<p>这些占位符称为保留点。为了创建占位符，可如下使用SAVEPOINT<br>语句：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SAVEPOINT delete1;</span><br></pre></td></tr></table></figure>

<p>每个保留点都取标识它的唯一名字，以便在回退时， MySQL知道要<br>回退到何处。为了回退到本例给出的保留点，可如下进行  :</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ROLLBACK TO delete1;</span><br></pre></td></tr></table></figure>

<p>留点在事务处理完成（执行一条ROLLBACK或COMMIT）后自动释放。自MySQL 5以来，也可以用RELEASE SAVEPOINT明确地释放保留点。</p>
<h3 id="4-更改默认的提交行为"><a href="#4-更改默认的提交行为" class="headerlink" title="4 更改默认的提交行为"></a>4 更改默认的提交行为</h3><p>为指示MySQL不自动提交更改，需要使用以下语句 ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SET autocommit=<span class="number">0</span>;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>使用存储过程</title>
    <url>/2020/05/12/%E4%BD%BF%E7%94%A8%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B-1/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍什么是存储过程，为什么要使用存储过程以及如何使用存储过程，并且介绍创建和使用存储过程的基本语法。  </p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>存储过程简单来说，就是为以后的使用而保存的一条或多条MySQL语句的集合。可将其视为批文件，虽然它们的作用不仅限于批处理  。</p>
<h2 id="为什么要使用存储过程"><a href="#为什么要使用存储过程" class="headerlink" title="为什么要使用存储过程"></a>为什么要使用存储过程</h2><p>理由：</p>
<ul>
<li>通过把处理封装在容易使用的单元中，简化复杂的操作（正如前面例子所述）。</li>
<li>由于不要求反复建立一系列处理步骤，这保证了数据的完整性。如果所有开发人员和应用程序都使用同一（试验和测试）存储过程，则所使用的代码都是相同的。这一点的延伸就是防止错误。需要执行的步骤越多，出错的可能性就越大。防止错误保证了数据的一致性。</li>
<li>简化对变动的管理。如果表名、列名或业务逻辑（或别的内容）有变化，只需要更改存储过程的代码。使用它的人员甚至不需要知道这些变化。</li>
</ul>
<p>这一点的延伸就是安全性。通过存储过程限制对基础数据的访问减少了数据讹误（无意识的或别的原因所导致的数据讹误）的机会。</p>
<ul>
<li>提高性能。因为使用存储过程比使用单独的SQL语句要快。</li>
<li>存在一些只能用在单个请求中的MySQL元素和特性，存储过程可以使用它们来编写功能更强更灵活的代码（在下一章的例子中可以看到。）  </li>
</ul>
<p>换句话说，使用存储过程有3个主要的好处，即简单、安全、高性能。显然，它们都很重要。不过，在将SQL代码转换为存储过程前，也必须知道它的一些缺陷。  </p>
<ul>
<li><p>一般来说，存储过程的编写比基本SQL语句复杂，编写存储过程需要更高的技能，更丰富的经验。  </p>
</li>
<li><p>你可能没有创建存储过程的安全访问权限。许多数据库管理员限制存储过程的创建权限，允许用户使用存储过程，但不允许他们创建存储过程。  </p>
</li>
</ul>
<h2 id="eg：一个返回产品平均价格的存储过程"><a href="#eg：一个返回产品平均价格的存储过程" class="headerlink" title="eg：一个返回产品平均价格的存储过程"></a>eg：一个返回产品平均价格的存储过程</h2><p><img src="https://photos.alitaalice.cn/image/20200513001100.png" alt=""></p>
<p>此存储过程名为productpricing，用CREATE PROCEDURE productpricing()语句定义。如果存储过程接受参数，它们将在()中列举出来。此存储过程没有参数，但后跟的()仍然需要。 BEGIN和END语句用来限定存储过程体，过<br>程体本身仅是一个简单的SELECT语句。如何使用这个存储过程呢？</p>
<p><img src="https://photos.alitaalice.cn/image/20200513001134.png" alt=""></p>
<p><img src="https://photos.alitaalice.cn/image/20200513001157.png" alt=""></p>
<p><img src="https://photos.alitaalice.cn/image/20200513001232.png" alt=""></p>
<h4 id="如何使用这个存储过程-？"><a href="#如何使用这个存储过程-？" class="headerlink" title="如何使用这个存储过程  ？"></a>如何使用这个存储过程  ？</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">CALL <span class="title">productpricing</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://photos.alitaalice.cn/image/20200513001250.png" alt=""></p>
<h4 id="如何删除这个存储过程？"><a href="#如何删除这个存储过程？" class="headerlink" title="如何删除这个存储过程？"></a>如何删除这个存储过程？</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DROP PROCEDURE productpricing;</span><br></pre></td></tr></table></figure>

<p>仅当存在时删除 如果指定的过程不存在，则DROP PROCEDURE将产生一个错误。当过程存在想删除它时（如果过程不存在也不产生错误）可使用DROP PROCEDURE IF EXISTS。  </p>
<h4 id="使用参数"><a href="#使用参数" class="headerlink" title="使用参数"></a>使用参数</h4><p>productpricing只是一个简单的存储过程，它简单地显示SELECT语句的结果。一般，存储过程并不显示结果，而是把结果返回给你指定的变量。    </p>
<p>变量（variable） 内存中一个特定的位置，用来临时存储数据。  以下productpricing的修改版本（如果不先删除此存储过程，则不能再次创建它）：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">CREATE PROCEDURE <span class="title">productpricing</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">              OUT p1 DECIMAL(<span class="number">8</span>,<span class="number">2</span>)</span>,</span></span><br><span class="line"><span class="function">              OUT ph <span class="title">DECIMAL</span><span class="params">(<span class="number">8</span>,<span class="number">2</span>)</span>,</span></span><br><span class="line"><span class="function">              OUT pa <span class="title">DECIMAL</span><span class="params">(<span class="number">8</span>,<span class="number">2</span>)</span></span></span><br><span class="line"><span class="function">              )</span></span><br><span class="line"><span class="function">        BEGIN</span></span><br><span class="line"><span class="function">            SELECT <span class="title">Min</span><span class="params">(prod_price)</span></span></span><br><span class="line"><span class="function">            INTO p1</span></span><br><span class="line"><span class="function">            FROM products</span>;</span><br><span class="line">            <span class="function">SELECT <span class="title">Max</span><span class="params">(prod_price)</span></span></span><br><span class="line"><span class="function">            INTO ph</span></span><br><span class="line"><span class="function">            FROM products</span>;</span><br><span class="line">            <span class="function">SELECT <span class="title">Avg</span><span class="params">(prod_price)</span></span></span><br><span class="line"><span class="function">            INTO pa</span></span><br><span class="line"><span class="function">            FROM products</span>;</span><br><span class="line">            END;</span><br></pre></td></tr></table></figure>

<p>此存储过程接受3个参数： pl存储产品最低价格， ph存储产品最高价格， pa存储产品平均价格。每个参数必须具有指定的类型，这里使用十进制值。关键字OUT指出相应的参数用来从存储过程传出一个值（返回给调用者）。 MySQL支持IN（传递给存储过程）、 OUT（从存储过程传出，如这里所用）和INOUT（对存储过程传入和传出）类型的参数。存储过程的代码位于BEGIN和END语句内，如前所见，它们是一系列SELECT语句，用来检索值，然后保存到相应的变量（通过指定INTO关键字）。</p>
<p>​    为调用此修改过的存储过程，必须指定3个变量名  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">CALL <span class="title">productpricing</span><span class="params">(@pricelow,</span></span></span><br><span class="line"><span class="function"><span class="params">                    @pricehigh,</span></span></span><br><span class="line"><span class="function"><span class="params">                    @priceaverage)</span></span>;</span><br></pre></td></tr></table></figure>

<p>由于此存储过程要求3个参数，因此必须正好传递3个参数，不多也不少。所以，这条CALL语句给出3个参数。它们是存储过程将保存结果的3个变量的名字。<br><strong>变量名</strong> 所有MySQL变量都必须以@开始。  </p>
<p><img src="https://photos.alitaalice.cn/image/20200513094242.png" alt=""></p>
<p><img src="https://photos.alitaalice.cn/image/20200513094323.png" alt=""></p>
<p>另外一个例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE PROCEDURE ordertotal(</span><br><span class="line">IN onumeber INT,</span><br><span class="line">OUT ototal DECIMAL(8,2))</span><br><span class="line">BEGIN</span><br><span class="line">    SELECT Sum(item_price*quantity)</span><br><span class="line">    FROM orderitems</span><br><span class="line">    WHERE order_num&#x3D;onumber</span><br><span class="line">    INTO ototal;</span><br><span class="line">END;</span><br></pre></td></tr></table></figure>

<p>为调用新存储过程，可以使用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CALL ordertotal(20005,@total);</span><br></pre></td></tr></table></figure>

<p><strong>必须给ordertotal传递两个参数；第一个参数为订单号，第二个参数为包含计算出来的合计的变量名。</strong>  </p>
<p>为了显示合计：</p>
<p>SELECT @total;</p>
<p><img src="https://photos.alitaalice.cn/image/20200513094845.png" alt=""></p>
<h2 id="建立智能存储过程"><a href="#建立智能存储过程" class="headerlink" title="建立智能存储过程"></a>建立智能存储过程</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-- Name: ordertotal</span><br><span class="line">-- Parameters: onumber =order number</span><br><span class="line">--             taxable= <span class="number">0</span> <span class="keyword">if</span> not taxable,<span class="number">1</span> <span class="keyword">if</span> taxable</span><br><span class="line">--             ototal =order total variable</span><br><span class="line"></span><br><span class="line"><span class="function">CREATE PROCEDURE <span class="title">ordertotal</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        IN onumber INT,</span></span></span><br><span class="line"><span class="function"><span class="params">        IN taxable BOOLEAN,</span></span></span><br><span class="line"><span class="function"><span class="params">        OUT ototal DECIMAL(<span class="number">8</span>,<span class="number">2</span>)</span></span></span><br><span class="line"><span class="function">)COMMENT 'Obtain order total,optionally adding tax'</span></span><br><span class="line"><span class="function">BEGIN</span></span><br><span class="line"><span class="function">     --Declare variable <span class="keyword">for</span> total</span></span><br><span class="line"><span class="function">     DECLARE total <span class="title">DECIMAL</span><span class="params">(<span class="number">8</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line">     --Declare tax percentage</span><br><span class="line">     DECLARE taxrate INT DEFAULT <span class="number">6</span>;</span><br><span class="line">     </span><br><span class="line">     --Get the order total</span><br><span class="line">     <span class="function">SELECT <span class="title">Sum</span><span class="params">(item_price*quantity)</span></span></span><br><span class="line"><span class="function">     FROM orderitems</span></span><br><span class="line"><span class="function">     WHERE order_num </span>=onumber</span><br><span class="line">     INTO total;</span><br><span class="line">     </span><br><span class="line">     --is <span class="keyword">this</span> taxable?</span><br><span class="line">     IF taxable THEN</span><br><span class="line">        --Yes,so add taxrate to the total</span><br><span class="line">        SELECT total+(total/<span class="number">100</span>*taxrate) INTO total;</span><br><span class="line">     END IF;</span><br><span class="line">     --And <span class="keyword">finally</span>,save to out variable</span><br><span class="line">     SELECT total INTO ototal;</span><br><span class="line">END;</span><br></pre></td></tr></table></figure>

<p>为了试验它</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CALL ordertotal(20005,0,@total);</span><br><span class="line">SELECT @total;</span><br></pre></td></tr></table></figure>

<p>为显示用来创建一个存储过程的CREATE语句，使用SHOW CREATE<br>PROCEDURE语句：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SHOW CREATE PROCEDURE ordertotal;</span><br></pre></td></tr></table></figure>

<p>为了获得包括何时、由谁创建等详细信息的存储过程列表， 使用SHOW<br>PROCEDURE STATUS。  </p>
<p>SHOW PROCEDURE STATUS列出所有存储过程。为限制其输出，可使用LIKE指定一个过滤模式，例如：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SHOW PROCEDURE STATUS LIKE <span class="string">'ordertotal'</span>;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>使用游标mysql</title>
    <url>/2020/05/14/%E4%BD%BF%E7%94%A8%E6%B8%B8%E6%A0%87mysql/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍游标</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p> MySQL检索操作返回一组称为结果集的行。这组返回的行都是与SQL语句相匹配的行（零行或多行）。使用简单的SELECT语<br>句，例如，没有办法得到第一行、下一行或前10行，也不存在每次一行地处理所有行的简单方法（相对于成批地处理它们）  </p>
<p>游标（cursor） 是一个存储在MySQL服务器上的数据库查询，<br>它不是一条SELECT语句，而是被该语句检索出来的结果集。在存储了游标之后，应用程序可以根据需要滚动或浏览其中的数据.  </p>
<p>只能用于存储过程 不像多数DBMS， MySQL游标只能用于<br>存储过程（和函数）  </p>
<h2 id="1-创建游标"><a href="#1-创建游标" class="headerlink" title="1 创建游标"></a>1 创建游标</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE PROCEDURE processorders()</span><br><span class="line">BEGIN </span><br><span class="line">   DECLARE ordernumbers CURSOR</span><br><span class="line">   FOR</span><br><span class="line">   SELECT order_num FROM orders</span><br><span class="line">END;</span><br></pre></td></tr></table></figure>

<p>DECLARE语句用来定义和命名游标，这里为ordernumbers。 存储过程处理完成后，游标就消失（因为它局限于存储过程）  </p>
<h2 id="2-打开和关闭游标"><a href="#2-打开和关闭游标" class="headerlink" title="2 打开和关闭游标"></a>2 打开和关闭游标</h2><p>输入：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">OPEN ordernumbers;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">关闭游标： CLOSE ordernumbers;</span><br></pre></td></tr></table></figure>

<p>如果你不明确关闭游标，MySQL将会在到达END语句时自动关闭它。</p>
<p>前面的例子修改版本：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">CREATE PROCEDURE <span class="title">processorders</span><span class="params">()</span></span></span><br><span class="line"><span class="function">BEGIN</span></span><br><span class="line"><span class="function">     --Declare the cursor</span></span><br><span class="line"><span class="function">     DECLARE ordernumbers CURSOR</span></span><br><span class="line"><span class="function">     FOR</span></span><br><span class="line"><span class="function">     SELECT order_num FROM orders</span>;</span><br><span class="line">     --Open the cursor</span><br><span class="line">     OPEN ordernumbers;</span><br><span class="line">     --Close the cursor</span><br><span class="line">     CLOSE ordernumbers;</span><br><span class="line">     </span><br><span class="line">     END;</span><br></pre></td></tr></table></figure>

<p>声明打开和关闭一个游标。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">CREATE PROCEDURE <span class="title">processorders</span><span class="params">()</span></span></span><br><span class="line"><span class="function">BEGIN</span></span><br><span class="line"><span class="function">    --Delare local variables</span></span><br><span class="line"><span class="function">    DECLARE done BOOLEAN DEFAULT 0</span>;</span><br><span class="line">    DECLARE o INT;</span><br><span class="line">    --Declare the cursor</span><br><span class="line">    DECLARE ordernumbers CURSOR</span><br><span class="line">    FOR</span><br><span class="line">    SELECT order_num FROM orders;</span><br><span class="line">    --Declare <span class="keyword">continue</span> handler</span><br><span class="line">    DELARE CONTINUE HANDLER FOR SQLSTATE <span class="string">'02000'</span> SET done=<span class="number">1</span>;</span><br><span class="line">    --Open the cursor</span><br><span class="line">    OPEN ordernumbers;</span><br><span class="line">    --LOOP through all rows</span><br><span class="line">    REPEAT</span><br><span class="line">    </span><br><span class="line">    --GET order number</span><br><span class="line">    FETCH ordernumbers INTO o;</span><br><span class="line">    --End of loop</span><br><span class="line">    UNTIL done END REPEAT;</span><br><span class="line">    --Close the cursor</span><br><span class="line">    CLOSE ordernumbers;</span><br><span class="line">    END;</span><br></pre></td></tr></table></figure>

<p>FETCH是在REPEAT内，因此它反复执行直到done为真（由UNTIL<br>done END REPEAT;规定）。为使它起作用，用一个DEFAULT 0（假，不结束）定义变量done。那么， done怎样才能在结束时被设置为真呢？答案是用以下语句：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DECLARE CONTINUE HANDLER FOR SQLSTATE <span class="string">'02000'</span> SET done=<span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>这条语句定义了一个CONTINUE HANDLER，它是在条件出现时被执行的代码。这里， 它指出当SQLSTATE ‘02000’出现时， SET done=1。SQLSTATE’02000’是一个未找到条件， 当REPEAT由于没有更多的行供循环而不能继续时，出现这个条件。  </p>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>内部类</title>
    <url>/2020/05/08/%E5%86%85%E9%83%A8%E7%B1%BB/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍JAVA内部类</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h1 id="JAVA内部类"><a href="#JAVA内部类" class="headerlink" title="JAVA内部类"></a>JAVA内部类</h1><h2 id="为什么需要内部类"><a href="#为什么需要内部类" class="headerlink" title="为什么需要内部类"></a>为什么需要内部类</h2><ul>
<li>内部类可以对同一个包中的其他类隐藏</li>
<li>内部类方法可以访问定义这个类的作用域中的数据，包括原有私有的数据。</li>
</ul>
<p>内部类的特点：</p>
<ul>
<li><p>一个内部类方法可以访问自身的数据字段</p>
</li>
<li><p>可以访问创建它的外围类对象的数据字段</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TalkingClock</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> interval;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> beep;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TalkingClock</span><span class="params">(<span class="keyword">int</span> interval ,<span class="keyword">boolean</span> beep)</span></span></span><br><span class="line"><span class="function">    </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// an inner class</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimePrinter</span> <span class="keyword">implements</span> <span class="title">ActionListener</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent event)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"at the tone,the time is"</span>+Insant.ofEpochMilli(event.getWhen()));</span><br><span class="line">            <span class="keyword">if</span>(beep) Toolkit.getDefaultToolkit().beep();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>TimePrinter类没有实例字段或者名为beep的对象。</p>
<p>实际上为此，<strong>内部类对象总有一个隐式引用，指向创建它的外部类对象。</strong></p>
</li>
</ul>
<p>​       但是这个引用在内部类的定义中是不可见的。我们将外围类对象的引用称为outer</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent event)</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">          System.out.println(<span class="string">"at the tone,the time is"</span>+Insant.ofEpochMilli(event.getWhen()));</span><br><span class="line">          <span class="keyword">if</span>(outer.beep) Toolkit.getDefaultToolkit().beep();</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<h3 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// an inner class</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TimePrinter</span> <span class="keyword">implements</span> <span class="title">ActionListener</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent event)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"at the tone,the time is"</span>+Insant.ofEpochMilli(event.getWhen()));</span><br><span class="line">            <span class="keyword">if</span>(beep) Toolkit.getDefaultToolkit().beep();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> listener =<span class="keyword">new</span> TimePrinter();</span><br><span class="line">    <span class="keyword">var</span> timer=<span class="keyword">new</span> Timer(interval,listener);</span><br><span class="line">    timer.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在示例代码中，只是在start方法中创建这个类型的对象时使用了一次。</p>
<p>当遇到这类情况时，可以在一个方法中局部的定义这个类。</p>
<ul>
<li><p>声明局部类时不能有访问说明符（即public 或者private)</p>
</li>
<li><p>局部类的作用域被限定在声明这个局部类的块中</p>
</li>
<li><p>局部类的优点: 对外部世界完全隐藏。除了start()方法外，没有任何方法知道TimePrinter类的存在。</p>
</li>
<li><p>局部类不仅可以访问外部类的字段，还可以访问局部变量。（必须是事实最终变量）它们一旦赋值就绝对不会改变。</p>
<h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>创建和操纵表</title>
    <url>/2020/05/09/%E5%88%9B%E5%BB%BA%E5%92%8C%E6%93%8D%E7%BA%B5%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍表的创建，更改和删除的基本知识</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h2 id="1-创建表"><a href="#1-创建表" class="headerlink" title="1.创建表"></a>1.创建表</h2><p>示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">CREATE TABLE customers</span><br><span class="line">(</span><br><span class="line"> cust_id   <span class="keyword">int</span>  NOT <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line"> cust_name <span class="keyword">char</span>(<span class="number">50</span>) NOT <span class="literal">NULL</span>,</span><br><span class="line"> cust_address <span class="keyword">char</span>(<span class="number">50</span>) NOT <span class="literal">NULL</span>,</span><br><span class="line"> PRIMARY KEY(cust_id)</span><br><span class="line">) ENGINE=InnoDB</span><br></pre></td></tr></table></figure>

<ul>
<li>语句格式化  MYsql语句中忽略空格，可以采用缩进格式，这样以便阅读和编辑。</li>
<li>处理现有的表 在创建新表时，指定的表名必须不存在，否则将出错。如果你仅仅想在一个表不存在时创建它，应该在表名后给出IF NOT EXISTS  如CREATE TABLE customers IF NOT EXISTS</li>
</ul>
<h3 id="使用NULL值"><a href="#使用NULL值" class="headerlink" title="使用NULL值"></a>使用NULL值</h3><p>NULL值就是没有值或者缺值。</p>
<p>NULL为默认值，如果不指定NOT NULL 则认定为是NULL</p>
<h4 id="理解NULL"><a href="#理解NULL" class="headerlink" title="理解NULL"></a>理解NULL</h4><p>不要把NULL和空串相混淆，NULL值是没有值，它不是空串。</p>
<p>如果指定  ‘ ’   （俩个单引号，其间没有字符）</p>
<p>这在<strong>NOT NULL</strong> 列中是允许的</p>
<p>空串 是一个有效的值，它并不是无值</p>
<p>NULL值用关键字NULL而不是空串指定。</p>
<h2 id="2-主键再介绍"><a href="#2-主键再介绍" class="headerlink" title="2.主键再介绍"></a>2.主键再介绍</h2><p>创建多个列组成的主键，应该以逗号分隔的列表给出列名</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">PRIMARY <span class="title">KEY</span><span class="params">(order_num,order_item)</span></span></span><br></pre></td></tr></table></figure>

<p><strong>主键只能使用不允许NULL值的列，允许NULL值的列不能作为唯一标识</strong></p>
<h2 id="3-使用AUTO-INCREMENT"><a href="#3-使用AUTO-INCREMENT" class="headerlink" title="3.使用AUTO_INCREMENT"></a>3.使用AUTO_INCREMENT</h2><p>AUTO_INCREMENT告诉Mysql ，本列每当增加一行时自动增量。每次执行一个INSERT操作时，Mysql自动对该列增量，每个列只允许有一个AUTO_INCREMENT列，而且它必须被索引。（如，通过使它成为主键）</p>
<h2 id="4-使用默认值"><a href="#4-使用默认值" class="headerlink" title="4.使用默认值"></a>4.使用默认值</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE customers</span><br><span class="line">(</span><br><span class="line"> cust_id   int  NOT NULL AUTO_INCREMENT,</span><br><span class="line"> cust_name char(50) NOT NULL,</span><br><span class="line"> cust_address char(50) NOT NULL ,</span><br><span class="line"> quantity int   NOT NULL DEFAULT 1,</span><br><span class="line"> PRIMARY KEY(cust_id)</span><br><span class="line">) ENGINE&#x3D;InnoDB</span><br></pre></td></tr></table></figure>

<p>DEFAULT 1 指示Mysql再未给出数量的情况下，使用数量1</p>
<ul>
<li>不允许函数，Mysql 不允许使用函数作为默认值，它只支持常量</li>
<li>使用默认值而不是NULL值。</li>
</ul>
<h2 id="5-引擎类型"><a href="#5-引擎类型" class="headerlink" title="5.引擎类型"></a>5.引擎类型</h2><p>上述的demo 以ENGINE=InnoDB语句结束。</p>
<p>Mysql有一个具体管理和处理数据的内部引擎，而且MYSQL 具有多种引擎，它打包多个引擎，并且这些引擎都隐藏再Mysql服务器内，全都能执行CREATE TABLE 和SELECT 等命令。</p>
<h3 id="引擎种类"><a href="#引擎种类" class="headerlink" title="引擎种类"></a>引擎种类</h3><table>
<thead>
<tr>
<th>InnoDB</th>
<th>可靠的事务处理引擎，它不支持全文本搜索</th>
</tr>
</thead>
<tbody><tr>
<td>MEMORY</td>
<td>在功能等同于MyISAM,但由于数据存储在内存（不是磁盘中），速度很快（特别适用于临时表）</td>
</tr>
<tr>
<td>MyISAM</td>
<td>性能极高的引擎，它支持全文本搜索，但是不支持事务处理</td>
</tr>
</tbody></table>
<p>如果省略ENGINE=语句，则使用默认引擎（MyISAM）</p>
<p><strong>注意：</strong></p>
<ul>
<li>引擎类型可以混用</li>
<li>外键不能跨引擎，一个引擎的表不能引用具有使用不同引擎的表的外键。</li>
</ul>
<h2 id="6-更新表"><a href="#6-更新表" class="headerlink" title="6.更新表"></a>6.更新表</h2><p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">ALTER TABLE vendors ADD vend_phone <span class="title">CHAR</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ALTER TABLE vendors DROP COLUMN vend_phone;</span><br></pre></td></tr></table></figure>

<p>ALTER TABLE 的一种常见用途是定义外键。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE orderitems ADD CONSTRAINT fk_orderitems_orders FOREIGN KEY (order_num) REFERENCES orders (order_num);</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE orderitems ADD CONSTRAINT fk_orderitems_products FOREIGN KEY (prod_id) REFERENCES products (prod_id);</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE orders ADD CONSTRAINT fk_orders_customers FOREIGN KEY (cust_id)REFERENCES customers (cust_id);</span><br></pre></td></tr></table></figure>

<p>ALTER TABLE要极为小心，应该在改动之前做一个完整的备份</p>
<h3 id="7-删除表"><a href="#7-删除表" class="headerlink" title="7.删除表"></a>7.删除表</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DROP TABLE customers2;</span><br></pre></td></tr></table></figure>

<p>无法撤销，永久删除</p>
<h3 id="8-重命名表"><a href="#8-重命名表" class="headerlink" title="8.重命名表"></a>8.重命名表</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RENAME TABLE customers2 TO customers;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RENAME TABLE backup_customers TO customers,</span><br><span class="line">             backup_vendors TO vendors,</span><br><span class="line">             backup_products TO products;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>创建表和操控表</title>
    <url>/2020/05/08/%E5%88%9B%E5%BB%BA%E8%A1%A8%E5%92%8C%E6%93%8D%E6%8E%A7%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍表的创建，更改和删除的基本知识。</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2>]]></content>
  </entry>
  <entry>
    <title>初级排序算法</title>
    <url>/2020/05/12/%E5%88%9D%E7%BA%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍排序算法</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>我们关注的主要对象是重新排列数组元素 的算法，其中每个元素都有一个主键 。排序算法的目标就是将所有元素的主键按照某种方式排列（通常是按照大小或是字母顺序）。排序后索引较大的主键大于等于索引较小的主键 . </p>
<h2 id="一-初级排序算法"><a href="#一-初级排序算法" class="headerlink" title="一.初级排序算法"></a>一.初级排序算法</h2><p>排序算法类的模板</p>
<p>排序算法类模版”中的 Example 类展示了我们的习惯约定：我们会将排序代码放在类的 sort() 方法中，该类还将包含辅助函数 less() 和 exch() （可能还有其他辅助函数）以及一个示例用例main() 。Example 类还包含了一些早期调试使用的代码：测试用例 main() 将标准输入得到的字符串排序，并用私有方法 show() 打印字符数组的内容。我们还会在本章中遇到各种用于比较不同算法并研究它们的性能的测试用例。为了区别不同的排序算法，我们为相应的类取了不同的名字，用例可以根据名字调用不同的实现，例如 Insertion.sort() 、Merge.sort() 、Quick.sort() 等。<br>大多数情况下，我们的排序代码只会通过两个方法操作数据：less() 方法对元素进行比较，exch()方法将元素交换位置。exch() 方法的实现很简单，通过 Comparable 接口实现 less() 方法也不困难。将数据操作限制在这两个方法中使得代码的可读性和可移植性更好，更容易验证代码的正确性、分析性能以及排序算法之间的比较。在学习具体的排序算法实现之前，我们先讨论几个对于所有排序算法都很<br>重要的问题。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">/* 请见算法2.1、算法2.2、算法2.3、算法2.4、算法2.5或算法2.7*/</span> &#125;<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">less</span><span class="params">(Comparable v, Comparable w)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> v.compareTo(w) &lt; <span class="number">0</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exch</span><span class="params">(Comparable[] a, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123; Comparable t = a[i]; a[i] = a[j]; a[j] = t; &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(Comparable[] a)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">// 在单行中打印数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++)</span><br><span class="line">StdOut.print(a[i] + <span class="string">" "</span>);</span><br><span class="line">StdOut.println();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSorted</span><span class="params">(Comparable[] a)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">// 测试数组元素是否有序</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; a.length; i++)</span><br><span class="line"><span class="keyword">if</span> (less(a[i], a[i-<span class="number">1</span>])) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">// 从标准输入读取字符串，将它们排序并输出</span></span><br><span class="line">String[] a = In.readStrings();</span><br><span class="line">sort(a);</span><br><span class="line"><span class="function"><span class="keyword">assert</span> <span class="title">isSorted</span><span class="params">(a)</span></span>;</span><br><span class="line">show(a);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="1-java中compareTo-用法详解"><a href="#1-java中compareTo-用法详解" class="headerlink" title="1.java中compareTo()用法详解"></a>1.java中compareTo()用法详解</h2><p>一、字符串比较用compareTo()时:</p>
<p>1，长度相同,从第一位开始比较，如果相同返回0，如果不同则马上返回这两个字符的ascii值的差值。</p>
<p>2，长度不同,直接返回长度差值。</p>
<p>二、Integer比较用compareTo()时：</p>
<p>1，对比数字时相同，返回0。</p>
<p>2，对比数字不同时，返回-1。</p>
<p><strong>对于 v&lt;w 、v=w 和 v&gt;w 三种情况，Java 的习惯是在 v.compareTo(w) 被调用时分别返回一个负整数、零和一个正整数（一般是 -1、0 和 1）</strong></p>
<p>我们接下来用 v&gt;w 来表示<br>v.compareTo(w)&gt;0  </p>
<h2 id="2-实现-Comparable-接口"><a href="#2-实现-Comparable-接口" class="headerlink" title="2.实现 Comparable 接口"></a>2.实现 Comparable 接口</h2><p><strong>我们的排序算法模板适用于任何实现了 Comparable 接口的数据类型。遵守 Java 惯例的好处是很多你希望排序的数据都实现了 Comparable 接口。例如，Java 中封装数字的类型 Integer 和 Double，以及 String 和其他许多高级数据类型（如 File 和 URL ）都实现了 Comparable 接口。因此你可以直接用这些类型的数组作为参数调用我们的排序方法。</strong>  </p>
<p>在创建自己的数据类型时，我们只要实现 Comparable 接口就能够保证用例代码可以将其排序。要做到这一点，只需要实现一个 compareTo() 方法来定义目标类型对象的自然次序  .</p>
<p><img src="https://photos.alitaalice.cn/image/20200513001323.png" alt=""></p>
<h2 id="二-选择排序"><a href="#二-选择排序" class="headerlink" title="二.选择排序"></a>二.选择排序</h2><p><strong>定义</strong>：一种最简单的排序算法是这样的：首先，找到数组中最小的那个元素，其次，将它和数组的第一个元素交换位置（如果第一个元素就是最小元素那么它就和自己交换）。再次，在剩下的元素中找到最小的元素，将它与数组的第二个元素交换位置。如此往复，直到将整个数组排序。这种方法叫做选择排序 ，因为它在不断地选择剩余元素之中的最小者。  </p>
<p><strong>选择排序代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Selection</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">// 将a[]按升序排列</span></span><br><span class="line"><span class="keyword">int</span> N = a.length; <span class="comment">// 数组长度</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">&#123; <span class="comment">// 将a[i]和a[i+1..N]中最小的元素交换</span></span><br><span class="line"><span class="keyword">int</span> min = i; <span class="comment">// 最小元素的索引</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; N; j++)</span><br><span class="line"><span class="keyword">if</span> (less(a[j], a[min])) min = j;</span><br><span class="line">exch(a, i, min);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// less()、exch()、isSorted()和main()方法见“排序算法类模板”</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>for循环i时，先找到最小a[0]的元素，再找到第二小的元素a[1]…一直进行下去</p>
<p>该算法将第 i 小的元素放到 a[i] 之中。数组的第 i 个位置的左边是 i 个最小的元素且它们不会再被访问。  </p>
<p><img src="https://photos.alitaalice.cn/image/20200513001448.png" alt=""></p>
<h1 id="三-插入排序"><a href="#三-插入排序" class="headerlink" title="三.插入排序"></a>三.插入排序</h1><p>在计算机的实现中，为了给要插入的元素腾出空间，我们需要将其余所有元素在插入之前都向右移动一位。这种算法叫做<strong>插入排序</strong>   </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Insertion</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">// 将a[]按升序排列</span></span><br><span class="line"><span class="keyword">int</span> N = a.length;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i++)</span><br><span class="line">&#123; <span class="comment">// 将 a[i] 插入到 a[i-1]、a[i-2]、a[i-3]...之中</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt; <span class="number">0</span> &amp;&amp; less(a[j], a[j-<span class="number">1</span>]); j--)</span><br><span class="line">exch(a, j, j-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// less()、exch()、isSorted()和main()方法见“排序算法类模板”</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://photos.alitaalice.cn/image/20200513001419.png" alt=""></p>
<p>插入排序原理很简单，讲一组数据分成两组，我分别将其称为有序组与待插入组。每次从待插入组中取出一个元素，与有序组的元素进行比较，并找到合适的位置，将该元素插到有序组当中。就这样，每次插入一个元素，有序组增加，待插入组减少。直到待插入组元素个数为0。当然，插入过程中涉及到了元素的移动。为了排序方便，我们一般将数据第一个元素视为有序组，其他均为待插入组。</p>
<p><img src="https://photos.alitaalice.cn/image/20200513001521.png" alt="">下面是几种典型的部分有序的数组：</p>
<ul>
<li><p>数组中每个元素距离它的最终位置都不远；</p>
</li>
<li><p>一个有序的大数组接一个小数组；</p>
</li>
<li><p>数组中只有几个元素的位置不正确。</p>
<p>插入排序对这样的数组很有效，而选择排序则不然。事实上，当倒置的数量很少时，插入排序很可能比本章中的其他任何算法都要快。  </p>
</li>
</ul>
<h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Shell</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">// 将a[]按升序排列</span></span><br><span class="line"><span class="keyword">int</span> N = a.length;</span><br><span class="line"><span class="keyword">int</span> h = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (h &lt; N/<span class="number">3</span>) h = <span class="number">3</span>*h + <span class="number">1</span>; <span class="comment">// 1, 4, 13, 40, 121, 364, 1093, ...</span></span><br><span class="line"><span class="keyword">while</span> (h &gt;= <span class="number">1</span>)</span><br><span class="line">&#123; <span class="comment">// 将数组变为h有序</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h; i &lt; N; i++)</span><br><span class="line">&#123; <span class="comment">// 将a[i]插入到a[i-h], a[i-2*h], a[i-3*h]... 之中</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt;= h &amp;&amp; less(a[j], a[j-h]); j -= h)</span><br><span class="line">exch(a, j, j-h);</span><br><span class="line">&#125;</span><br><span class="line">h = h/<span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// less()、exch()、isSorted()和main()方法见“排序算法类模板”</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://photos.alitaalice.cn/image/20200513154601.png" alt=""></p>
<p>算法 shell 的实现使用了序列 ，从N/3 开始递减至 1。我们把这个序列称为递增序列 。  实现希尔排序的一种方法是对于每个 h，用插入排序将 h 个子数组独立地排序。但因为子数组是相互独立的，一个更简单的方法是在 h- 子数组中将每个元素交换到比它大的元素之前去（将比它大的元素向右移动一格）。只需要在插入排序的代码中将移动元素的距离由 1 改为 h 即可。这样，希尔排序的实现就转化为了一个类似于插入排序但使用不同增量的过程。  </p>
<p><img src="https://photos.alitaalice.cn/image/20200513154809.png" alt=""></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>DataStructure</tag>
      </tags>
  </entry>
  <entry>
    <title>单件模式</title>
    <url>/2020/05/27/%E5%8D%95%E4%BB%B6%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>单件模式 –&gt;  确保一个类只有一个实例，并提供全局访问点。</p>
<p>当你需要确保程序中的某个类只有一个实例时，就采用单件模式吧</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>synchronized关键字</title>
    <url>/2020/05/25/synchronized%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍synchronized关键字</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>转自<a href="https://juejin.im/post/5adf14dcf265da0b7b358d58#heading-10" target="_blank" rel="noopener">https://juejin.im/post/5adf14dcf265da0b7b358d58#heading-10</a></p>
]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>图解JAVA垃圾回收机制</title>
    <url>/2020/05/20/%E5%9B%BE%E8%A7%A3JAVA%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>转<a href="https://blog.csdn.net/justloveyou_/article/details/71216049" target="_blank" rel="noopener">https://blog.csdn.net/justloveyou_/article/details/71216049</a></p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>垃圾收集器与内存分配策略</title>
    <url>/2020/05/18/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍垃圾收集器与内存分配策略</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="1-java中init和clinit方法"><a href="#1-java中init和clinit方法" class="headerlink" title="1 java中init和clinit方法"></a>1 java中init和clinit方法</h3><p>init是对象构造器方法，也就是说在程序执行 new 一个对象调用该对象类的 constructor 方法时才会执行init方法，而clinit是类构造器方法，也就是在jvm进行类<strong>加载—–验证—-解析—–初始化</strong>，中的初始化阶段jvm会调用clinit方法。</p>
<p><strong>init是instance实例构造器，对非静态变量解析初始化</strong>，而<strong>clinit是class类构造器对静态变量，静态代码块进行初始化</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">static</span> Log log = LogFactory.getLog(); <span class="comment">// &lt;clinit&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> x = <span class="number">1</span>;   <span class="comment">// &lt;init&gt;</span></span><br><span class="line"></span><br><span class="line">   X()&#123;</span><br><span class="line">      <span class="comment">// &lt;init&gt;</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">static</span> &#123;</span><br><span class="line">      <span class="comment">// &lt;clinit&gt;</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="简述可达性分析算法"><a href="#简述可达性分析算法" class="headerlink" title="简述可达性分析算法"></a>简述可达性分析算法</h3><h3 id="finalize关键字"><a href="#finalize关键字" class="headerlink" title="finalize关键字"></a>finalize关键字</h3><p>java提供<a href="http://www.51testing.com/javascrīpt:;" target="_blank" rel="noopener"><strong>finalize</strong></a>()方法，垃圾回收器准备释放内存的时候，会先调用finalize()。</p>
<p>​    (1).对象不一定会被回收。</p>
<p>​    (2).垃圾回收不是析构函数。</p>
<p>​    (3).垃圾回收只与内存有关。</p>
<p>​    (4).垃圾回收和finalize()都是靠不住的，只要JVM还没有快到耗尽内存的地步，它是不会浪费时间进行垃圾回收的。</p>
<p>有时当撤消一个对象时，需要完成一些操作。例如，如果一个对象正在处理的是非Java 资源，如文件句柄或window 字符字体，这时你要确认在一个对象被撤消以前要保证这些资源被释放。为处理这样的状况，Java 提供了被称为收尾（finalization ）的机制。使用该机制你可以定义一些特殊的操作，这些操作在一个对象将要被垃圾回收程序释放时执行。</p>
<p>要给一个类增加收尾（finalizer ），你只要定义finalize ( ) 方法即可。Java 回收该类的一个对象时，就会调用这个方法。在finalize ( )方法中，你要指定在一个对象被撤消前必须执行的操作。垃圾回收周期性地运行，检查对象不再被运行状态引用或间接地通过其他对象引用。就在对象被释放之前，Java 运行系统调用该对象的finalize( ) 方法。</p>
<p>finalize()方法的通用格式如下：</p>
<p>protected void finalize( )<br>{<br>// finalization code here<br>}</p>
<h3 id="finalize"><a href="#finalize" class="headerlink" title="finalize"></a>finalize</h3><p>方法名。Java 技术允许使用 finalize() 方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在确定这个对象没有被引用时对这个对象调用的。它是在 Object 类中定义的，因此所有的类都继承了它。子类覆盖 finalize() 方法以整理系统资源或者执行其他清理工作。finalize() 方法是在垃圾收集器删除对象之前对这个对象调用的。 </p>
<p>Java中所有类都从Object类中继承finalize()方法。</p>
<p>当垃圾回收器(garbage colector)决定回收某对象时，就会运行该对象的finalize()方法。值得C++程序员注意的是，finalize()方法并不能等同与析构函数。Java中是没有析构函数的。C++的析构函数是在对象消亡时运行的。由于C++没有垃圾回收，对象空间手动回收，所以一旦对象用不到时，程序员就应当把它delete()掉。所以析构函数中经常做一些文件保存之类的收尾工作。但是在Java中很不幸，如果内存总是充足的，那么垃圾回收可能永远不会进行，也就是说filalize()可能永远不被执行，显然指望它做收尾工作是靠不住的。</p>
<p>那么finalize()究竟是做什么的呢？它最主要的用途是回收特殊渠道申请的内存。Java程序有垃圾回收器，所以一般情况下内存问题不用程序员操心。但有一种JNI(Java Native Interface)调用non-Java程序（C或C++），finalize()的工作就是回收这部分的内存。</p>
<h3 id="Java中的引用"><a href="#Java中的引用" class="headerlink" title="Java中的引用"></a>Java中的引用</h3><h3 id="简述垃圾回收算法"><a href="#简述垃圾回收算法" class="headerlink" title="简述垃圾回收算法"></a>简述垃圾回收算法</h3><h3 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h3><h3 id="在垃圾回收器回收对象的时候，程序的逻辑是否可以继续执行"><a href="#在垃圾回收器回收对象的时候，程序的逻辑是否可以继续执行" class="headerlink" title="在垃圾回收器回收对象的时候，程序的逻辑是否可以继续执行"></a>在垃圾回收器回收对象的时候，程序的逻辑是否可以继续执行</h3><h3 id="垃圾回收器在什么时候，对哪些对象，做了什么"><a href="#垃圾回收器在什么时候，对哪些对象，做了什么" class="headerlink" title="垃圾回收器在什么时候，对哪些对象，做了什么"></a>垃圾回收器在什么时候，对哪些对象，做了什么</h3><h3 id="简述minor-GC，与full-GC-java垃圾回收分代，以及何时发生minor-gc，以及full-gc"><a href="#简述minor-GC，与full-GC-java垃圾回收分代，以及何时发生minor-gc，以及full-gc" class="headerlink" title="简述minor GC，与full GC,java垃圾回收分代，以及何时发生minor gc，以及full gc"></a>简述minor GC，与full GC,java垃圾回收分代，以及何时发生minor gc，以及full gc</h3>]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>基于拉链和线性探测法的散列表</title>
    <url>/2020/05/13/%E5%9F%BA%E4%BA%8E%E6%8B%89%E9%93%BE%E5%92%8C%E7%BA%BF%E6%80%A7%E6%8E%A2%E6%B5%8B%E6%B3%95%E7%9A%84%E6%95%A3%E5%88%97%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍基于拉链和线性探测法的散列表</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>使用散列的查找算法分为两步。第一步是用散列函数 将被查找的键转化为数组的一个索引。理想情况下，不同的键都能转化为不同的索引值。当然，这只是理想情况，所以我们需要面对两个或者多个键都会散列到相同的索引值的情况。因此，散列查找的第二步就是一个处理碰撞冲突 的过程，如图 所示。在描述了多种散列函数的计算后，我们会学习两种解决碰撞的方法：拉链法 和线性探测法 。  </p>
<p><img src="https://photos.alitaalice.cn/image/20200514100602.png" alt=""></p>
<h3 id="散列表的核心问题"><a href="#散列表的核心问题" class="headerlink" title="散列表的核心问题"></a>散列表的核心问题</h3><p>散列表是算法在时间和空间上作出权衡的 经典例子。如果没有内存限制，我们可以直接将键作为（可能是一个超大的）数组的索引，那么所有查找操作只需要访问内存一次即可完成。但这种理想情况不会经常<br>出现，因为当键很多时需要的内存太大。另一方面，如果没有时间限制，我们可以使用无序数组并进行顺序查找，这样就只需要很少的内存。而散列表则使用了适度的空间和时间并在这两个极端之间找到了一种平衡。事实上，我们不必重写代码，只需要调整散列算法的参数就可以在空间和时间之间作出取舍。我们会使用概率论的经典结论来帮助我们选择适当的参数。  </p>
<h3 id="基于拉链法的散列表"><a href="#基于拉链法的散列表" class="headerlink" title="基于拉链法的散列表"></a>基于拉链法的散列表</h3><p>一个散列函数能够将键转化为数组索引。散列算法的第二步是碰撞处理 ，也就是处理两个或多个键的散列值相同的情况。<strong>一种直接的办法是将大小为 的数组中的每个元素指向一条链表，链表中的每个结点都存储了散列值为该元素的索引的键值对。这种方法被称为拉链法</strong> ，因为发生冲突的元素都被存储在链表中。这个方法的基本思想就是选择足够大的 ，使得所有链表都尽可能短以保证高效的查找。查找分两步：首先根据散列值找到对应的链表，然后沿着链表顺序查找相应的键。  </p>
<h3 id="散列表的大小"><a href="#散列表的大小" class="headerlink" title="散列表的大小"></a>散列表的大小</h3><p>在实现基于拉链法的散列表时，我们的目标是选择适当的数组大小 ，既不会因为空链表而浪费大量内存，也不会因为链表太长而在查找上浪费太多时间。而拉链法的一个好处就是这并不是关键性的选择。如<br>果存入的键多于预期，查找所需的时间只会比选择更大的数组稍长；如果少于预期，虽然有些空间浪费但查找会非常快。当内存不是很紧张时，可以选择一个足够大的 ，使得查找需要的时间变为常数；当内<br>存紧张时，选择尽量大的 仍然能够将性能提高 倍。  </p>
<h3 id="基于线性探测法的散列表"><a href="#基于线性探测法的散列表" class="headerlink" title="基于线性探测法的散列表"></a>基于线性探测法的散列表</h3><p>实现散列表的另一种方式就是用大小为 M的数组保存N 个键值对，其中 M&gt;N。我们需要依靠数组中的空位 解决碰撞冲突。基于这种策略的所有方法被统称为开放地址 散列表。  </p>
<p>开放地址散列表中最简单的方法叫做线性探测法 ：当碰撞发生时（当一个键的散列值已经被另一个不同的键占用），我们直接检查散列表中的下一个位置（将索引值加 1）。这样的线性探测可能会产生三种结<br>果：  </p>
<ul>
<li>命中，该位置的键和被查找的键相同；</li>
<li>未命中，键为空（该位置没有键）；</li>
<li>继续查找，该位置的键和被查找的键不同。  </li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>DataStructure</tag>
      </tags>
  </entry>
  <entry>
    <title>学习方法</title>
    <url>/2020/05/07/%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>学习方法</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><ul>
<li>慢一点，你理解的越多，需要记的就越少</li>
<li>勤做练习，自己记笔记</li>
<li>上床睡觉之前就不要再看别的书了，或者至少不能再看其他有难度的东西</li>
<li>要喝水，要多喝水</li>
<li>大声说出来</li>
<li>听听你的大脑怎么说（注意大脑是不是负荷太重）</li>
<li>要有点感觉（真正融入到书的故事中）</li>
</ul>
]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>抽象类和接口的区别详解</title>
    <url>/2020/05/11/%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8C%BA%E5%88%AB%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍抽象类和接口</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>它不能被实例化，只能被用作 子类的超类。抽象类是被用来创建继承层级里子类的模板。</p>
<p>以JDK中的GenericServlet为例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericServlet</span> <span class="keyword">implements</span> <span class="title">Servlet</span>, <span class="title">ServletConfig</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// abstract method</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest req, ServletResponse res)</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Its implementation</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// other method related to Servlet</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当HttpServlet类继承GenericServlet时，它提供了<strong>service</strong>方法的实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpServlet</span> <span class="keyword">extends</span> <span class="title">GenericServlet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest req, ServletResponse res)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// implementation</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Implementation</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Implementation</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// some other methods related to HttpServlet</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>接口是抽象方法的集合，如果一个类实现了某个接口，那么它就继承了这个接口的抽象方法，这就像契约的模式，如果实现了这个接口，那么就必须确保使用了这些方法，接口只是一种形式，它本身不能实现任何方法，以Externalizable接口为例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Externalizable</span> <span class="keyword">extends</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">writeExternal</span><span class="params">(ObjectOutput out)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">readExternal</span><span class="params">(ObjectInput in)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当你继承这个接口时，你就必须实现上面的俩个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Externalizable</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> employeeId;</span><br><span class="line">    String employeeName;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readExternal</span><span class="params">(ObjectInput in)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        employeeId = in.readInt();</span><br><span class="line">        employeeName = (String) in.readObject();</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeExternal</span><span class="params">(ObjectOutput out)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"> </span><br><span class="line">        out.writeInt(employeeId);</span><br><span class="line">        out.writeObject(employeeName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="什么时候使用抽象类和接口？"><a href="#什么时候使用抽象类和接口？" class="headerlink" title="什么时候使用抽象类和接口？"></a>什么时候使用抽象类和接口？</h2><ul>
<li>如果你拥有一些方法，并且想让它们中的一些有默认实现，那么使用抽象类吧</li>
<li>如果你想实现多重继承，那么请使用接口，抽象类不允许多重继承</li>
<li>如果基本功能在不断的进行改变，那么你就需要使用抽象类。如果不断改变基本功能，并且使用接口，那么就需要改变所有实现了该接口的类。</li>
</ul>
<h2 id="JAVA8中的默认方法和静态方法"><a href="#JAVA8中的默认方法和静态方法" class="headerlink" title="JAVA8中的默认方法和静态方法"></a>JAVA8中的默认方法和静态方法</h2><p>Oracle已经开始尝试向接口中引入默认方法和静态方法，依次来减少抽象类和接口之间的差异。</p>
<p>现在我们可以为接口提供默认实现的方法并且不用强制子类来实现它。default方法。</p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>JAVASE</tag>
      </tags>
  </entry>
  <entry>
    <title>散列表详解</title>
    <url>/2020/05/13/%E6%95%A3%E5%88%97%E8%A1%A8%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍散列表。</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h2 id="散列函数"><a href="#散列函数" class="headerlink" title="散列函数"></a>散列函数</h2><p>我们面对的第一个问题就是散列函数的计算，这个过程会将键转化为数组的索引。如果我们有一个能够保存 M个键值对的数组，那么我们就需要一个能够将任意键转化为该数组范围内的索引([0,M-1] 范围内的整数）的散列函数 -</p>
<p>散列函数和键的类型有关。<strong>严格地说，对于每种类型的键都我们都需要一个与之对应的散列函数 。</strong>如果键是一个数，比如社会保险号，我们就可以直接使用这个数；如果键是一个字符串，比如一个人的名字，<br>我们就需要将这个字符串转化为一个数；<strong>如果键含有多个部分，比如邮件地址，我们需要用某种方法将这些部分结合起来</strong>。对于许多常见类型的键，我们可以利用 Java 提供的默认实现。我们会简略讨论多种数<br>据类型的散列函数。你应该看看它们是如何实现的，因为你也需要为自定义的类型实现散列函数。  </p>
<h3 id="正整数"><a href="#正整数" class="headerlink" title="正整数"></a>正整数</h3><p>将整数散列最常用方法是<strong>除留余数法</strong> 。我们选择大小为素数 的数组，对于任意正整数 ，计算除以 的余数。这个函数的计算非常容易（在 Java 中为 k% M ）并能够有效地将键散布在 0 到M-1的范围内。  </p>
<p><img src="https://photos.alitaalice.cn/image/20200513162105.png" alt=""></p>
<h3 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h3><p>如果键是 0 到 1 之间的实数，我们可以将它乘以 并四舍五入得到一个 0 至 之间的索引值。<br>尽管这个方法很容易理解，但它是有缺陷的，因为这种情况下键的高位起的作用更大，最低位对散列的结果没有影响。修正这个问题的办法是将键表示为二进制数然后再使用除留余数法（Java 就是这么做的）  </p>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h2 id="组合键"><a href="#组合键" class="headerlink" title="组合键"></a>组合键</h2><h2 id="JAVA的约定"><a href="#JAVA的约定" class="headerlink" title="JAVA的约定"></a>JAVA的约定</h2><p>每种数据类型都需要相应的散列函数，于是 Java 令所有数据类型都继承了一个能够返回一个 32 比特整数的 hashCode() 方法。每一种数据类型的 hashCode() 方法都必须和 equals() 方法一致 。也就是说，如果 a.equals(b) 返回 true ，那么 a.hashCode() 的返回值必然和 b.hashCode()的返回值相同。相反，如果两个对象的 hashCode() 方法的返回值不同，那么我们就知道这两个对象是不同的。但如果两个对象的 hashCode() 方法的返回值相同，这两个对象也有可能不同，我们还需要用equals() 方法进行判断。请注意，这说明如果你要为自定义的数据类型定义散列函数，你需要同时重写 hashCode() 和 equals() 两个方法。默认散列函数会返回对象的内存地址，但这只适用于很少的情况。Java 为很多常用的数据类型重写了 hashCode() 方法（包括 String 、Integer 、Double、File 和 URL ）。  </p>
<h3 id="将hashCode-的返回值转化为一个数组索引"><a href="#将hashCode-的返回值转化为一个数组索引" class="headerlink" title="将hashCode()的返回值转化为一个数组索引"></a>将hashCode()的返回值转化为一个数组索引</h3><p>因为我们需要的是数组的索引而不是一个 32 位的整数，我们在实现中会将默认的 hashCode() 方法和除留余数法结合起来产生一个 0 到M-1 的整数，方法如下：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Key x)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> (x.hashCode() &amp; <span class="number">0x7fffffff</span>) % M; &#125;</span><br></pre></td></tr></table></figure>

<p>这段代码会将符号位屏蔽（将一个 32 位整数变为一个 31 位非负整数），然后用除留余数法计算它除以M 的余数。在使用这样的代码时我们一般会将数组的大小 M 取为素数 以充分利用原散列值的所有位。  </p>
<h3 id="自定义的hashCode-方法"><a href="#自定义的hashCode-方法" class="headerlink" title="自定义的hashCode()方法"></a>自定义的hashCode()方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Transaction</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String who;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Date when;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">double</span> amount;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> hash = <span class="number">17</span>;</span><br><span class="line">hash = <span class="number">31</span> * hash + who.hashCode();</span><br><span class="line">hash = <span class="number">31</span> * hash + when.hashCode();</span><br><span class="line">hash = <span class="number">31</span> * hash+ ((Double) amount).hashCode();</span><br><span class="line"><span class="keyword">return</span> hash;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自定义类型中 hashCode() 方法的实现  </p>
<p>对于原始类型的对象，可以将其转化为对应的数据类型然后再调用 hashCode() 方法。和以前一样，系数的具体值（这里是 31）并不是很重要。  </p>
<h3 id="软缓存"><a href="#软缓存" class="headerlink" title="软缓存"></a>软缓存</h3><p>如果散列值的计算很耗时，那么我们或许可以将每个键的散列值缓存起来 ，即在每个键中使用一个hash 变量来保存它的 hashCode() 的返回值（请见练习 3.4.25）。第一次调用 hashCode() 方法时，我们需要计算对象的散列值，但之后对 hashCode() 方法的调用会直接返回 hash 变量的值。<br>Java 的 String 对象的 hashCode() 方法就使用了这种方法来减少计算量。  </p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>DataStructure</tag>
      </tags>
  </entry>
  <entry>
    <title>指针</title>
    <url>/2020/05/04/%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<h1 id="10-1-指针变量"><a href="#10-1-指针变量" class="headerlink" title="10.1 指针变量"></a>10.1 指针变量</h1><p> 由于通过地址能访问指定的内存存储单元。可以说地址“指向”该内存单元。地址可以形象地称为指针，意思是通过指针能够找到内存单元。<br> <a id="more"></a></p>
<h2 id="1一个变量的地址称为该变量的指针，如果有一个变量专门用来存放另一个变量的地址，那么它就是指针变量。"><a href="#1一个变量的地址称为该变量的指针，如果有一个变量专门用来存放另一个变量的地址，那么它就是指针变量。" class="headerlink" title="1一个变量的地址称为该变量的指针，如果有一个变量专门用来存放另一个变量的地址，那么它就是指针变量。"></a>1一个变量的地址称为该变量的指针，如果有一个变量专门用来存放另一个变量的地址，那么它就是指针变量。</h2><p>一般形式为：<br>类型说明 * 变量名<br>int * q;<br>C语言中提供了地址运算符“&amp;”来表示变量的地址。其中一般形式为：<br>&amp;变量名;</p>
<h2 id="2给指针变量赋值一般有俩个方法"><a href="#2给指针变量赋值一般有俩个方法" class="headerlink" title="2给指针变量赋值一般有俩个方法"></a>2给指针变量赋值一般有俩个方法</h2><p>1   </p>
<pre><code>int a;
int *p=&amp;a</code></pre><p>2       </p>
<pre><code>int a;
int *p;
p=&amp;a;</code></pre><h2 id="3-指针变量的引用"><a href="#3-指针变量的引用" class="headerlink" title="3 指针变量的引用"></a>3 指针变量的引用</h2><p>引用指针变量是对变量进行间接访问的一种形式</p>
<p>对指针变量的引用形式如下：</p>
<p>*指针变量 其含义是引用指针变量所指向的值</p>
<h2 id="4-amp-和-的区别"><a href="#4-amp-和-的区别" class="headerlink" title="4 &amp; 和 *的区别"></a>4 &amp; 和 *的区别</h2><p> &amp;运算符是一个返回操作数地址的单目运算符，叫做取地址运算符</p>
<p> *运算符是返回指定的地址内的变量的值，叫做指针运算符。</p>
<h2 id="5-指针自增和自减运算"><a href="#5-指针自增和自减运算" class="headerlink" title="5 指针自增和自减运算"></a>5 指针自增和自减运算</h2><p>基本整型变量i在内存中占4个字节，指针P是指向变量i的地址的，p++是指向下一个存放基本整型数的地址。</p>
<h2 id="6-数组与指针"><a href="#6-数组与指针" class="headerlink" title="6 数组与指针"></a>6 数组与指针</h2><p>在定义一个一维数组时，系统会在内存中为该数组分配一个存储空间，其数组的名称就是数组在内存中的首地址。<br>例如：</p>
<p>1      </p>
<pre><code>int *p,a[10]; 
 p=a;</code></pre><p>或</p>
<p>2   </p>
<pre><code>int *p,a[10]; 
p=&amp;a[0];</code></pre><h2 id="7-二维数组与指针"><a href="#7-二维数组与指针" class="headerlink" title="7 二维数组与指针"></a>7 二维数组与指针</h2><p>表示二维数组中元素地址的方法：</p>
<p>&amp;a[0][0]可以看作数组0行0列的首地址，也可以看作二维数组的首地址。</p>
<p>&amp;a[m][n]就是第m行n列元素的地址。而a[0]+n表示第0行第n个元素的地址。</p>
<h2 id="8指针变量作为函数参数"><a href="#8指针变量作为函数参数" class="headerlink" title="8指针变量作为函数参数"></a>8指针变量作为函数参数</h2><p>指针变量也可以作为函数参数</p>
<p>例<br>在swap（int <em>a,int</em> b)中</p>
<p>在函数调用的过程中，主调用函数与被调用函数之间有一个数值传递的过程。函数调用中发生的数据传递是单向的，只能把实际参数的值传递给形式参数，在函数调用的过程中，形式参数的值发生改变，但是实际参数的值不会发生变化。如果swap(int a,int b) 则不能实现x与y值的互换。</p>
<p>通过指针传递参数可以减少值传递带来的开销，也可以使函数调用不产生值传递。</p>
<h2 id="9返回指针值的函数"><a href="#9返回指针值的函数" class="headerlink" title="9返回指针值的函数"></a>9返回指针值的函数</h2><p>返回的值的类型为指针类型，返回指针值的函数简称为指针函数</p>
<p>定义指针函数的一般形式为 </p>
<p>类型名 *函数名（参数列表） </p>
<p>如   int *fun(int x,int y)</p>
<p>如 </p>
<pre><code>int *per(int a,int b)
{
 int *p;
 p=&amp;Perimeter;
 Perimeter=(a+b)*2;
 return p; 
}</code></pre>]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>时间复杂度</title>
    <url>/2020/05/05/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/</url>
    <content><![CDATA[<h1 id="算法时间复杂度"><a href="#算法时间复杂度" class="headerlink" title="算法时间复杂度"></a>算法时间复杂度</h1><h2 id="算法时间复杂度定义"><a href="#算法时间复杂度定义" class="headerlink" title="算法时间复杂度定义"></a>算法时间复杂度定义</h2><ul>
<li><p>O()来体现算法时间复杂度的记法</p>
<a id="more"></a>

<h2 id="推导大O阶的方法"><a href="#推导大O阶的方法" class="headerlink" title="推导大O阶的方法"></a>推导大O阶的方法</h2><ol>
<li><p>用常数1代替所有加法常数</p>
</li>
<li><p>在修改后的运行次数函数中，只保留最高阶项</p>
</li>
<li><p>如果最高阶项存在且不是1，则去除这个项相乘的常数</p>
<p>得到的结果就是大O阶.</p>
<h3 id="举例说明："><a href="#举例说明：" class="headerlink" title="举例说明："></a>举例说明：</h3><h4 id="常数阶"><a href="#常数阶" class="headerlink" title="常数阶"></a>常数阶</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> sum=<span class="number">0</span>,n=<span class="number">100</span>; <span class="comment">//执行1次</span></span><br><span class="line">sum=(<span class="number">1</span>+n)*n/<span class="number">2</span>; <span class="comment">//执行2次</span></span><br><span class="line">sum=(<span class="number">1</span>+n)*n/<span class="number">2</span>; <span class="comment">//</span></span><br><span class="line">sum=(<span class="number">1</span>+n)*n/<span class="number">2</span>; <span class="comment">//</span></span><br><span class="line">sum=(<span class="number">1</span>+n)*n/<span class="number">2</span>; <span class="comment">//</span></span><br><span class="line">...</span><br><span class="line">sum=(<span class="number">1</span>+n)*n/<span class="number">2</span>; <span class="comment">//执行10次</span></span><br></pre></td></tr></table></figure>

<p>事实上无论n为多少，上面代码就是1次，2次，10次的差别，这种与问题大小无关（与n的大小无关）执行时间恒定的算法。称为O(1)阶，又叫常数阶</p>
<h4 id="线性阶"><a href="#线性阶" class="headerlink" title="线性阶"></a>线性阶</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 时间复杂度为O(1)的程序     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
</li>
</ul>
<p>​               循环的时间复杂度为O(n)</p>
<h4 id="对数阶"><a href="#对数阶" class="headerlink" title="对数阶"></a>对数阶</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int count&#x3D;1;</span><br><span class="line">while (count &lt;n)</span><br><span class="line">&#123;</span><br><span class="line">count &#x3D;count *2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2^x=n  x=log2 n   所以这个循环的时间复杂度为O(log n).</p>
<h4 id="平方阶"><a href="#平方阶" class="headerlink" title="平方阶"></a>平方阶</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i,j;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">/*时间复杂度为O(1)的程序步骤序列      */</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度为O(m*n)</p>
<p>又如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i,j;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(j=i;j&lt;n;j++)</span><br><span class="line">&#123;</span><br><span class="line"> <span class="comment">/* 时间复杂度为O(1)的程序*/</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行总次数 n+n-1+(n-2)+…+1=n(n+1)/2   时间复杂度为O(n^2) </p>
<h4 id="常见的时间复杂度"><a href="#常见的时间复杂度" class="headerlink" title="常见的时间复杂度"></a>常见的时间复杂度</h4><p>常用时间复杂度耗费时间比对：</p>
<p>O(1)&lt;O(log n)&lt;O(n)&lt;O(nlogn)&lt;O(n^2)&lt;O(n^3)&lt;O(2^n)&lt;O(n!)&lt;O(n^n)</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>DataStructure</tag>
      </tags>
  </entry>
  <entry>
    <title>树</title>
    <url>/2020/05/07/%E6%A0%91/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>树的相关概念</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h2 id="树的相关概念"><a href="#树的相关概念" class="headerlink" title="树的相关概念"></a>树的相关概念</h2><h3 id="度"><a href="#度" class="headerlink" title="度"></a>度</h3><ul>
<li>结点拥有的子树树称为结点的度</li>
<li>度为0的结点称为叶结点（Leaf）或者终端结点。</li>
<li>度不为0的结点称为非终端结点或者分支结点</li>
<li>树的度是树内各结点度的最大值</li>
</ul>
<h3 id="深度（Depth-或高度"><a href="#深度（Depth-或高度" class="headerlink" title="深度（Depth)或高度"></a>深度（Depth)或高度</h3><ul>
<li>层次：结点的层次从根开始定义起，根为第一层，根的孩子为第二层，以此类推</li>
<li>树中结点的最大层次被称为树的深度（Depth）或者高度。</li>
</ul>
<h3 id="有序树和无序树"><a href="#有序树和无序树" class="headerlink" title="有序树和无序树"></a>有序树和无序树</h3><p>如果将树中结点的各子树看成从左至右是由次序的，不能互换的，那么该树为有序树，否则为无序树。</p>
<h3 id="森林"><a href="#森林" class="headerlink" title="森林"></a>森林</h3><p>森林是m（m&gt;=0)颗互不相交的树的集合。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>DataStructure</tag>
      </tags>
  </entry>
  <entry>
    <title>策略模式</title>
    <url>/2020/05/14/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍策略模式。</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h2 id="策略模式："><a href="#策略模式：" class="headerlink" title="策略模式："></a>策略模式：</h2><p><img src="https://photos.alitaalice.cn/image/20200514101320.png" alt=""></p>
<p><img src="https://photos.alitaalice.cn/image/20200527205338.png" alt=""></p>
<p><img src="https://photos.alitaalice.cn/image/20200527205407.png" alt=""></p>
]]></content>
      <categories>
        <category>理论</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>工厂模式</title>
    <url>/2020/05/22/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍工厂模式</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>工厂方法模式：通过让子类决定该创建的对象是什么，来达到将对象创建的过程封装的目的。</p>
<p>创造者（Creator）类   抽象创建者类。定义抽象的工厂方法，让子类实现此方法制造产品。</p>
<p>产品类  具体的产品，实际能制造的东西</p>
<p><img src="https://photos.alitaalice.cn/image/20200525105633.png" alt=""> </p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>类加载的过程</title>
    <url>/2020/05/25/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%9A%84%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍类加载的过程</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p><img src="https://photos.alitaalice.cn/image/20200525210206.png" alt=""></p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>线性表</title>
    <url>/2020/05/05/%E7%BA%BF%E6%80%A7%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h1><h2 id="线性表的定义："><a href="#线性表的定义：" class="headerlink" title="线性表的定义："></a>线性表的定义：</h2><ul>
<li>线性表：零个或多个数据元素的有限序列</li>
<li>线性表元素的个数n 定义为线性表的长度，当n=0时，称为空表<a id="more"></a>

</li>
</ul>
<h2 id="线性表的顺序存储结构"><a href="#线性表的顺序存储结构" class="headerlink" title="线性表的顺序存储结构"></a>线性表的顺序存储结构</h2><ul>
<li><p>顺序存储定义： 线性表的顺序存储结构，指的是用一段地址连续的存储单元依次存储线性表的数据元素</p>
<h3 id="顺序存储方式"><a href="#顺序存储方式" class="headerlink" title="顺序存储方式"></a>顺序存储方式</h3><ul>
<li><p>顺序存储的结构代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 20 </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemType data[MAXSIZE];</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">&#125;SqList;</span><br></pre></td></tr></table></figure>

<p>MAXSIZE：数组长度</p>
<p>length： 线性表当前的长度</p>
<p>另外以数组data进行存储</p>
</li>
<li><p>线性表中的地址</p>
<p>存储器中的每个存储单元都有自己的编号，这个编号称为地址。</p>
<h3 id="顺序存储结构的插入与删除"><a href="#顺序存储结构的插入与删除" class="headerlink" title="顺序存储结构的插入与删除"></a>顺序存储结构的插入与删除</h3><h4 id="获得元素操作"><a href="#获得元素操作" class="headerlink" title="获得元素操作"></a>获得元素操作</h4><p>我们实现GetElem操作，即把线性表L中的第i个元素值返回。只要i的数值在数组范围内，就是把数组的第i-1下标返回即可。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR 0 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status; <span class="comment">/*函数的类型 */</span></span><br><span class="line"><span class="function">Status <span class="title">GetElem</span><span class="params">(SqList L,<span class="keyword">int</span> i,ElemType *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L.length==<span class="number">0</span> ||i&lt;<span class="number">1</span> ||i&gt;L.length)</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    *e=L.data[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h4><p>算法思路：</p>
<ul>
<li><p>插入位置不合理</p>
</li>
<li><p>线性表长度大于数组长度</p>
</li>
<li><p>从最后一个元素遍历到第i个元素</p>
</li>
<li><p>将要插入的元素填到位置i处</p>
</li>
<li><p>表长+1</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ListInsert</span><span class="params">(SqList *L,<span class="keyword">int</span> i,ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> k;</span><br><span class="line"><span class="keyword">if</span>(L-&gt;length==MAXSIZE)</span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line"><span class="keyword">if</span>(i&lt;<span class="number">1</span>||i&gt;L-&gt;length+<span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line"><span class="keyword">if</span>(i&lt;=L-&gt;length)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(k=L-&gt;length<span class="number">-1</span>;k&gt;=i<span class="number">-1</span>;k--)</span><br><span class="line">&#123;</span><br><span class="line">L-&gt;data[k+<span class="number">1</span>]=L-&gt;data[k];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">L-&gt;data[i<span class="number">-1</span>]=e;</span><br><span class="line">L-&gt;length++;</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>DataStructure</tag>
      </tags>
  </entry>
  <entry>
    <title>线程安全性</title>
    <url>/2020/05/17/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍线程安全性</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="1-并发与并行"><a href="#1-并发与并行" class="headerlink" title="1 并发与并行"></a>1 并发与并行</h3><p>你吃饭吃到一半，电话来了，你一直到吃完了以后才去接，这就说明你不支持并发也不支持并行。<br>你吃饭吃到一半，电话来了，你停了下来接了电话，接完后继续吃饭，这说明你支持并发。<br>你吃饭吃到一半，电话来了，你一边打电话一边吃饭，这说明你支持并行。</p>
<p>并发的关键是你有处理多个任务的能力，不一定要同时。<br>并行的关键是你有同时处理多个任务的能力。</p>
<p>所以我认为它们最关键的点就是：是否是『同时』。</p>
<h3 id="2-原子性"><a href="#2-原子性" class="headerlink" title="2 原子性"></a>2 原子性</h3><p><strong>即一个操作或者多个操作，要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。原子性就像数据库里面的事务一样，他们是一个团队，同生共死。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">i = <span class="number">0</span>;       <span class="comment">//1</span></span><br><span class="line">j = i ;      <span class="comment">//2</span></span><br><span class="line">i++;         <span class="comment">//3</span></span><br><span class="line">i = j + <span class="number">1</span>;   <span class="comment">//4</span></span><br></pre></td></tr></table></figure>

<p>上面四个操作，有哪个几个是原子操作，那几个不是？如果不是很理解，可能会认为都是原子性操作，其实只有1才是原子操作，其余均不是。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>在Java中，对基本数据类型的变量和赋值操作都是原子性操作； </span><br><span class="line"><span class="number">2</span>中包含了两个操作：读取i，将i值赋值给j </span><br><span class="line"><span class="number">3</span>中包含了三个操作：读取i值、i + <span class="number">1</span> 、将+<span class="number">1</span>结果赋值给i； </span><br><span class="line"><span class="number">4</span>中同三一样</span><br></pre></td></tr></table></figure>

<p>在单线程环境下我们可以认为整个步骤都是原子性操作，但是在多线程环境下则不同，Java只保证了基本数据类型的变量和赋值操作才是原子性的（注：在32位的JDK环境下，对64位数据的读取不是原子性操作*，如long、double）。</p>
<p>要想在多线程环境下保证原子性，则可以通过锁、synchronized来确保。volatile是无法保证复合操作的原子性。</p>
<h3 id="3可见性"><a href="#3可见性" class="headerlink" title="3可见性"></a>3可见性</h3><p><strong>可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//线程1执行的代码</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">i = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程2执行的代码</span></span><br><span class="line">j = i;</span><br></pre></td></tr></table></figure>

<p>假若执行线程1的是CPU1，执行线程2的是CPU2。由上面的分析可知，当线程1执行 i = 10这句时，会先把i的初始值加载到CPU1的高速缓存中，然后赋值为10，那么在CPU1的高速缓存当中i的值变为10了，却没有立即写入到主存当中。此时线程2执行 j = i，它会先去主存读取i的值并加载到CPU2的缓存当中，注意此时内存当中i的值还是0，那么就会使得j的值为0，而不是10。这就是可见性问题，线程1对变量i修改了之后，线程2没有立即看到线程1修改的值。</p>
<p>在上面已经分析了，在多线程环境下，一个线程对共享变量的操作对其他线程是不可见的。<br>对于可见性，Java提供了volatile关键字来保证可见性。当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。另外，通过synchronized和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。</p>
<h3 id="4有序性"><a href="#4有序性" class="headerlink" title="4有序性"></a>4有序性</h3><p><strong>程序执行的顺序按照代码的先后顺序执行</strong></p>
<p><strong>在Java里面，可以通过volatile关键字来保证一定的“有序性”</strong>。另外可以通过synchronized和Lock来保证有序性，很显然，synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。</p>
<h4 id="3-竞态条件"><a href="#3-竞态条件" class="headerlink" title="3 竞态条件"></a>3 竞态条件</h4><p>在并发编程中，这种由于不恰当的执行时序而出现不正确的结果是一种非常。重要的情况，它有一个正式的名字：竞态条件  </p>
<p>最常见的竞态条件类型就是“先检查后执行（Check-Then-Act）”操作，即通过一个可能失效的观测结果来决定下一步的动作  </p>
]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>网络基础TCP/IP</title>
    <url>/2020/05/13/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80TCP-IP/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍网络基础TCP/IP</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h2 id="1-TCP-IP的定义"><a href="#1-TCP-IP的定义" class="headerlink" title="1 TCP/IP的定义"></a>1 TCP/IP的定义</h2><p>定义：计算机与网络设备要相互通信，双方就必须基于相同的方法。比如，如何探测到通信目标、由哪一边先发起通信、使用哪种语言进行通信、怎样结束通信等规则都需要事先确定。不同的硬件、操作系统之间的通信，所有的这一切都需要一种规则。而我们就把这种规则称为协议（protocol）。  </p>
<p><img src="https://photos.alitaalice.cn/image/20200513211754.png" alt=""></p>
<p>图：TCP/IP 是互联网相关的各类协议族的总称  </p>
<h2 id="2-TCP-IP的分层管理"><a href="#2-TCP-IP的分层管理" class="headerlink" title="2 TCP/IP的分层管理"></a>2 TCP/IP的分层管理</h2><p>TCP/IP 协议族里重要的一点就是分层。TCP/IP 协议族按层次分别分为以下 4 层：应用层、传输层、网络层和数据链路层。  </p>
<p>把 TCP/IP 层次化是有好处的。比如，如果互联网只由一个协议统筹，某个地方需要改变设计时，就必须把所有部分整体替换掉。而分层之后只需把变动的层替换掉即可。把各层之间的接口部分规划好之后，每个层次内部的设计就能够自由改动了。  </p>
<h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><p><strong>应用层决定了向用户提供应用服务时通信的活动。</strong><br>TCP/IP 协议族内预存了各类通用的应用服务。比如，FTP（File Transfer Protocol，文件传输协议）和DNS（Domain Name System，域名系统）服务就是其中两类。<br>HTTP 协议也处于该层。  </p>
<h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><p>传输层对上层应用层，提供处于网络连接中的两台计算机之间的数据传输。<strong>在传输层有两个性质不同的协议：TCP（Transmission Control Protocol，传输控制协议）和 UDP（User Data Protocol，用户数据报协议）</strong>  </p>
<h2 id="网络层（又名网络互连层）"><a href="#网络层（又名网络互连层）" class="headerlink" title="网络层（又名网络互连层）"></a>网络层（又名网络互连层）</h2><p>网络层用来处理在网络上流动的数据包。数据包是网络传输的最小数据单位。<strong>该层规定了通过怎样的路径（所谓的传输路线）到达对方计算机，并把数据包传送给对方。</strong><br>与对方计算机之间通过多台计算机或网络设备进行传输时，网络层所起的作用就是在众多的选项内选择一条传输路线。  </p>
<h2 id="链路层（又名数据链路层，网络接口层）"><a href="#链路层（又名数据链路层，网络接口层）" class="headerlink" title="链路层（又名数据链路层，网络接口层）"></a>链路层（又名数据链路层，网络接口层）</h2><p>用来处理连接网络的硬件部分。包括控制操作系统、硬件的设备驱动、NIC（Network Interface Card，网络适配器，即网卡），及光纤等物理可见部分（还包括连接器等一切传输媒介）。硬件上的范畴均在链<br>路层的作用范围之内。  </p>
<h2 id="3-流程"><a href="#3-流程" class="headerlink" title="3 流程"></a>3 流程</h2><p><img src="https://photos.alitaalice.cn/image/20200513213825.png" alt=""></p>
<p>利用 TCP/IP 协议族进行网络通信时，会通过分层顺序与对方进行通信。发送端从应用层往下走，接收端则往应用层往上走。<br>我们用 HTTP 举例来说明，首先作为发送端的客户端在应用层（HTTP 协议）发出一个想看某个 Web 页面的 HTTP 请求。</p>
<p>接着，为了传输方便，在传输层（TCP 协议）把从应用层处收到的数据（HTTP 请求报文）进行分割，并在各个报文上打上标记序号及端口号后转发给网络层。</p>
<p>在网络层（IP 协议），增加作为通信目的地的 MAC 地址后转发给链路层。这样一来，发往网络的通信请求就准备齐全了。<br>接收端的服务器在链路层接收到数据，按序往上层发送，一直到应用层。当传输到应用层，才能算真正接收到由客户端发送过来的 HTTP 请求。  </p>
<p><img src="https://photos.alitaalice.cn/image/20200513214119.png" alt=""></p>
<p>发送端在层与层之间传输数据时，每经过一层时必定会被打上一个该层所属的首部信息。反之，接收端在层与层传输数据时，每经过一层时会把对应的首部消去。<br>这种把数据信息包装起来的做法称为封装（encapsulate）  </p>
<h2 id="4-IP-TCP-DNS"><a href="#4-IP-TCP-DNS" class="headerlink" title="4 IP.TCP.DNS"></a>4 IP.TCP.DNS</h2><h3 id="4-1-IP"><a href="#4-1-IP" class="headerlink" title="4.1 IP"></a>4.1 IP</h3><p>按层次分，IP（Internet Protocol）网际协议位于网络层。  可能有人会把“IP”和“IP 地址”搞混，“IP”其实是一种协议的名称  </p>
<p>IP 协议的作用是把各种数据包传送给对方。而要保证确实传送到对方那里，则需要满足各类条件。其中两个重要的条件是 IP 地址和 MAC 地址（Media Access Control Address）  </p>
<p>IP 地址指明了节点被分配到的地址，MAC 地址是指网卡所属的固定地址。IP 地址可以和 MAC 地址进行配对。IP 地址可变换，但 MAC 地址基本上不会更改。  </p>
]]></content>
      <categories>
        <category>计网</category>
      </categories>
      <tags>
        <tag>TCP/IP</tag>
      </tags>
  </entry>
  <entry>
    <title>装饰者模式</title>
    <url>/2020/05/18/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍装饰者模式。</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="装饰者模式定义"><a href="#装饰者模式定义" class="headerlink" title="装饰者模式定义"></a>装饰者模式定义</h3><p><img src="https://photos.alitaalice.cn/image/20200518102539.png" alt=""></p>
<p>设计原则：</p>
<p>类应该对扩展开放，对修改关闭。</p>
<p>我们的目标是允许类容易扩展，在不修改现有代码的情况下，就可搭配新的行为。如果能实现这样的目标，有什么好处呢？这样的设计具有弹性可以应对改变，可以接受新的功能来应对改变的需求。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>观察者模式</title>
    <url>/2020/05/14/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍观察者模式</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p><img src="https://photos.alitaalice.cn/image/20200527204326.png" alt="">)<img src="C:%5CUsers%5C16508%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200527204301788.png" alt="image-20200527204301788"></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>词法分析</title>
    <url>/2020/05/21/%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2>]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>编译原理</tag>
      </tags>
  </entry>
  <entry>
    <title>语法分析消除回溯</title>
    <url>/2020/05/20/%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E6%B6%88%E9%99%A4%E5%9B%9E%E6%BA%AF/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p><img src="https://photos.alitaalice.cn/image/20200520110241.png" alt=""></p>
<p><img src="https://photos.alitaalice.cn/image/20200520110725.png" alt=""></p>
<p><img src="https://photos.alitaalice.cn/image/20200520110909.png" alt=""></p>
<p><img src="https://photos.alitaalice.cn/image/20200520111151.png" alt=""></p>
<p><img src="C:%5CUsers%5C16508%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200520111712012.png" alt="image-20200520111712012"></p>
<p><img src="https://photos.alitaalice.cn/image/20200520112422.png" alt=""></p>
<p><img src="https://photos.alitaalice.cn/image/20200520112834.png" alt=""> </p>
<p><img src="https://photos.alitaalice.cn/image/20200520113021.png" alt=""></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    public boolean Judge(List&lt;String&gt; list)&#123;</span><br><span class="line">         ArrayList&lt;node&gt; analy &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">        for (int i &#x3D; 0; i &lt; list.size(); i++) &#123;</span><br><span class="line">            node aa &#x3D; new node(list.get(i).charAt(0),list.get(i).substring(3));</span><br><span class="line">            analy.add(aa);</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i&#x3D;0;i&lt;analy.size();i++)&#123;</span><br><span class="line">            if(analy.get(i).left &#x3D;&#x3D; analy.get(i).right.charAt(0))&#123;   &#x2F;&#x2F;当产生式的左部等于右部第一个符号，则具有左递归</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    class node&#123;          &#x2F;&#x2F;用于方便查找产生式的左部与右部</span><br><span class="line">    public char left;</span><br><span class="line">    public String right;</span><br><span class="line">    public node(char left,String right)&#123;</span><br><span class="line">        this.left&#x3D;left;</span><br><span class="line">        this.right&#x3D;right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>编译原理</tag>
      </tags>
  </entry>
  <entry>
    <title>语法分析</title>
    <url>/2020/05/19/%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p><img src="https://photos.alitaalice.cn/image/20200519182456.png" alt=""> </p>
<p><img src="https://photos.alitaalice.cn/image/20200519182209.png" alt=""></p>
<p><img src="https://photos.alitaalice.cn/image/20200519182733.png" alt=""></p>
<p><img src="https://photos.alitaalice.cn/image/20200519183255.png" alt=""></p>
<h3 id="自上而下分析面临的问题"><a href="#自上而下分析面临的问题" class="headerlink" title="自上而下分析面临的问题"></a>自上而下分析面临的问题<img src="https://photos.alitaalice.cn/image/20200519183424.png" alt=""></h3><h3 id="单词没向下进行，而语法树一直生成，死循环"><a href="#单词没向下进行，而语法树一直生成，死循环" class="headerlink" title="单词没向下进行，而语法树一直生成，死循环"></a><strong>单词没向下进行，而语法树一直生成，死循环</strong></h3><p><img src="https://photos.alitaalice.cn/image/20200519183702.png" alt=""></p>
<p><img src="https://photos.alitaalice.cn/image/20200519184233.png" alt=""></p>
<p><img src="https://photos.alitaalice.cn/image/20200519184615.png" alt=""></p>
<p> <img src="https://photos.alitaalice.cn/image/20200519185010.png" alt=""></p>
<p><img src="https://photos.alitaalice.cn/image/20200519185526.png" alt=""></p>
<p><img src="https://photos.alitaalice.cn/image/20200519190630.png" alt=""></p>
<p><img src="https://photos.alitaalice.cn/image/20200519190602.png" alt=""></p>
<p>通用消除左递归的方法</p>
<p><img src="https://photos.alitaalice.cn/image/20200519190928.png" alt=""></p>
<p><img src="https://photos.alitaalice.cn/image/20200519191437.png" alt=""></p>
]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>编译原理</tag>
      </tags>
  </entry>
  <entry>
    <title>归并排序</title>
    <url>/2020/05/14/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍归并排序</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>在本节中我们所讨论的算法都基于归并 这个简单的操作，即将两个有序的数组归并成一个更大的有序数组。很快人们就根据这个操作发明了一种简单的递归排序算法：<strong>归并排序</strong> 。  </p>
<p><img src="https://photos.alitaalice.cn/image/20200514103423.png" alt=""></p>
<p>​                                         归并排序示意图  </p>
<h2 id="原地归并"><a href="#原地归并" class="headerlink" title="原地归并"></a>原地归并</h2>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>DataStructure</tag>
      </tags>
  </entry>
  <entry>
    <title>实习</title>
    <url>/2020/05/08/%E5%AE%9E%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍实习</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>本日是5.8日  6.15日正式开始面试</p>
<p>需要学习的内容有：</p>
<p>1 数据结构</p>
<p>2 JAVA集合</p>
<p>3 JAVA并发</p>
<p>4 JVM</p>
<p>5 mysql</p>
<p>6 Spring</p>
<p>7 计网和操作系统面经内容。</p>
<p>8 redis了解。</p>
<ul>
<li><p>JAVASE 数据结构算法 mysql 这三个是一类</p>
</li>
<li><p>设计模式 JVM  这两个是一类  能大概谈谈每种设计模式是什么就可以了</p>
</li>
<li><p>剑指offer 这个单独一类 </p>
</li>
</ul>
<p>先定位好去什么样的公司吧，如果想试试大厂，那么后端大数据都无所谓，基础要非常好，</p>
<p>然后大数据/后端 一两个框架搞熟，如果去那种普通的公司，算法啥的，简单看看就行，多搞点项目经验，对框架好熟悉</p>
<p>java做初+中的，mysql建议全做，不会的看答案，然后自己写</p>
<p>做个SSM和Boot的CRUD项目就可以了。<br>            不要花太多精力在上面。<br>几天时间吧。<br>boot估计一天不到。<br>主要是熟悉整个流程。<br>找个手感<br><a href="https://leetcode-cn.com/" target="_blank" rel="noopener">https://leetcode-cn.com/</a><br>没事刷刷题<br>java做初+中的，mysql建议全做，不会的看答案，然后自己写</p>
<ul>
<li>2018~2019 </li>
</ul>
<p>​      拿不出就在网上找，，找个牛批的项目，学习一下，，思考一下技术选型，架构，过程中遇到过什么难题等等，，。没做过不重要，会扯就行。crud太low了。，找个牛批的项目</p>
<p>不用等到完全准备好才投简历，，因为一般人永远觉得自己还没准备好，，，准备个差不多就投简历，，，就算通过不了，也能及时发现自己的不足，然后补上</p>
]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>链表</title>
    <url>/2020/05/07/%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>线性表的链式存储结构详解</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>单链表存储状态图示：</p>
<p>Node由存放数据元素的数据域和存放后继结点地址的指针域组成。</p>
<p>头结点的数据域可以不存储任何信息。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">ElemType data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;Node;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">LinkList</span>;</span></span><br></pre></td></tr></table></figure>

<p>假设p是指向线性表第i个元素的指针，则该结点ai的数据域 可以用p-&gt;data 来表示</p>
<p>结点ai的指针域用p-&gt;next来表示。p-&gt;next指向第i-1个元素，即指向ai+1的指针。即p-&gt;data=ai</p>
<p>那么p-&gt;next-&gt;data=ai+1</p>
<p><img src="%E9%93%BE%E8%A1%A801.png" alt=""></p>
<h2 id="单链表的读取"><a href="#单链表的读取" class="headerlink" title="单链表的读取"></a>单链表的读取</h2><p>算法思路：<br>从第一个头结点开始，指针域p-&gt; next一直向下指向第i个元素的指针域。</p>
<ol>
<li>声明指针p指向链表的第一个结点 ，初始化从1开始</li>
<li>当j&lt;i时就遍历链表，p不断向后移动，j++</li>
<li>当链表末尾p为空时，则说明第i个结点不存在</li>
<li>若查找成功，那么返回结点p的数据。</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">GetElem</span><span class="params">(LinkList L,<span class="keyword">int</span> i,ElemType *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> j;</span><br><span class="line">  LinkList p;</span><br><span class="line">  p=L-&gt;next;</span><br><span class="line">  j=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(p&amp;&amp;j&lt;i)</span><br><span class="line">  &#123;</span><br><span class="line">  p=p-&gt;next;</span><br><span class="line">  j++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(!p || j&gt;i)</span><br><span class="line">  <span class="keyword">return</span> ERROR；</span><br><span class="line">  *e=p-&gt;data;</span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="单链表的插入与删除"><a href="#单链表的插入与删除" class="headerlink" title="单链表的插入与删除"></a>单链表的插入与删除</h2><h3 id="单链表插入"><a href="#单链表插入" class="headerlink" title="单链表插入"></a>单链表插入</h3><p>思路：在俩节点之间再插入一个结点</p>
<p>图示：</p>
<p><img src="%E9%93%BE%E8%A1%A802.png" alt=""></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">s-&gt;next=p-&gt;next;</span><br><span class="line">p-next=s;   <span class="comment">/*单链表插入标准语句 */</span></span><br></pre></td></tr></table></figure>

<p>实现插入操作的具体思路：</p>
<ol>
<li></li>
<li></li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ListInsert</span><span class="params">(LinkList *L,<span class="keyword">int</span> i,ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(p&amp;&amp;j&lt;i)</span><br><span class="line">    &#123;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">        ++j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!p||j&gt;i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    s=(LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    s-&gt;data=e;</span><br><span class="line">    s-&gt;next=p-&gt;next;</span><br><span class="line">    p-&gt;next=s;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>malloc  函数，生成一个新的结点，其类型与Node一样的，其实质就是在内存中找一小块空地，准备用来存放数据e的s结点。</p>
<h2 id="单链表的删除："><a href="#单链表的删除：" class="headerlink" title="单链表的删除："></a>单链表的删除：</h2><p>图示：</p>
<p><img src="%E9%93%BE%E8%A1%A803.png" alt=""></p>
<p>实际上就是p-&gt;next=p-&gt;next-&gt;next;</p>
<p>如果用q来表示p-&gt;next即</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">q=p-&gt;next;</span><br><span class="line">p-&gt;next=q-&gt;next;</span><br></pre></td></tr></table></figure>

<p>思路：</p>
<p>具体实现代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ListDelete</span><span class="params">(LinkList *L,<span class="keyword">int</span> i,ElemType *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> j;</span><br><span class="line">LinkList p,q;</span><br><span class="line">p=*L;</span><br><span class="line">j=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(p-&gt;next &amp;&amp; j&lt;i)</span><br><span class="line">&#123;</span><br><span class="line">p=p-&gt;next;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!(p-&gt;next)||j&gt;i)</span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line">q=p-&gt;next;</span><br><span class="line">p-&gt;next=q-&gt;next;</span><br><span class="line">*e=q-&gt;data;</span><br><span class="line"><span class="built_in">free</span>(q);<span class="comment">/* 回收一个Node结点 */</span></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>DataStructure</tag>
      </tags>
  </entry>
  <entry>
    <title>验证二叉搜索树</title>
    <url>/2020/05/25/%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h4 id="98-验证二叉搜索树"><a href="#98-验证二叉搜索树" class="headerlink" title="98. 验证二叉搜索树"></a><a href="https://leetcode-cn.com/problems/validate-binary-search-tree/" target="_blank" rel="noopener">98. 验证二叉搜索树</a></h4><p>难度中等589</p>
<p>给定一个二叉树，判断其是否是一个有效的二叉搜索树。</p>
<p>假设一个二叉搜索树具有如下特征：</p>
<ul>
<li>节点的左子树只包含<strong>小于</strong>当前节点的数。</li>
<li>节点的右子树只包含<strong>大于</strong>当前节点的数。</li>
<li>所有左子树和右子树自身必须也是二叉搜索树。</li>
</ul>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">    2</span><br><span class="line">   &#x2F; \</span><br><span class="line">  1   3</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">    5</span><br><span class="line">   &#x2F; \</span><br><span class="line">  1   4</span><br><span class="line">     &#x2F; \</span><br><span class="line">    3   6</span><br><span class="line">输出: false</span><br><span class="line">解释: 输入为: [5,1,4,null,null,3,6]。</span><br><span class="line">     根节点的值为 5 ，但是其右子节点值为 4 。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
</search>
