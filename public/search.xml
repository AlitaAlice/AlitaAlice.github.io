<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>JAVA_String_API</title>
    <url>/2020/05/06/JAVA-String-API/</url>
    <content><![CDATA[<p>String API</p>
<ul>
<li>append()</li>
</ul>
<p>  在由许多小段的字符串构建一个字符串时，则使用StringBuilder类（字符串构造器）</p>
<p>  首先构造一个空的字符串构造器：<br>  <a id="more"></a></p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StringBuilder builder =<span class="keyword">new</span> StringBuilder();</span><br></pre></td></tr></table></figure>

<p>  当需要添加一部分内容时，调用append()方法</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">builder.append(ch);</span><br><span class="line">builder.append(str);</span><br><span class="line">String completedString=builder.toString(); <span class="comment">/*调用toString()方法，得到String对象。*/</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>char charAt(int index)</p>
<p>返回给定位置的代码单元。</p>
</li>
<li><p>int length()</p>
</li>
</ul>
<p>​         返回字符串代码单元的个数</p>
<ul>
<li><p>String repeat(int count)</p>
<p>返回一个字符串，将当前字符重复count次</p>
</li>
<li><p>boolean equals() </p>
<p>用来检测俩个字符串是否相等</p>
<p>boolean equalsIgnoreCase() </p>
<p>用来检测俩个字符串是否相等（不区分大小写）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="string">"hello"</span>.equals(greeting);</span><br><span class="line"><span class="string">"HELLO"</span>.equalsIgnoreCase(<span class="string">"hello"</span>); <span class="comment">/* 不区分大小写 */</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>注意：</p>
<p><strong>不要用==运算符检测是否相等。</strong></p>
<p><strong>这个运算符只能够确定俩个字符串是否存放在同一个位置上。</strong>当然如果字符串存放在同一个位置上，它们必然相等，但是完全有可能把内容相同的多个字符串副本放置在不同的位置上。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String greeting=<span class="string">"Hello"</span>;</span><br><span class="line"><span class="keyword">if</span>(greeting ==<span class="string">"Hello"</span>)</span><br><span class="line">  -- <span class="keyword">true</span></span><br><span class="line"> <span class="keyword">if</span>(greeting.substring(<span class="number">0</span>,<span class="number">3</span>)==<span class="string">"Hel"</span>)</span><br><span class="line">  --<span class="keyword">false</span></span><br></pre></td></tr></table></figure>

<p>实际上只有字符串字面量共享，而+或者substring操作得到的字符串并不共享。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>JAVASE</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA和C++的区别</title>
    <url>/2020/05/11/JAVA%E5%92%8CC++%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍JAVA和C++的区别</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h2 id="JAVA和C-的区别"><a href="#JAVA和C-的区别" class="headerlink" title="JAVA和C++的区别"></a>JAVA和C++的区别</h2><ul>
<li>都是面向对象的语言，并且都支持封装，继承和多态</li>
<li>指针：JAVA不提供指针来直接访问内存，程序更加安全。</li>
<li>继承：JAVA中的类是单继承的，但是C++允许多继承，JAVA中允许一个类实现多个接口来实现C++中的多冲继承。</li>
<li>内存：JAVA有自动内存管理机制，不需要程序员手动释放无用内存。</li>
</ul>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>JAVASE</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA容器分类</title>
    <url>/2020/05/06/JAVA%E5%AE%B9%E5%99%A8%E5%88%86%E7%B1%BB/</url>
    <content><![CDATA[<h2 id="Java容器可分为两大类："><a href="#Java容器可分为两大类：" class="headerlink" title="Java容器可分为两大类："></a>Java容器可分为两大类：</h2><ul>
<li><p>Collection接口 继承JAVA.lang.Object</p>
<ul>
<li>List接口<ul>
<li><strong>ArrayList</strong></li>
<li>LinkedList<a id="more"></a></li>
<li>Vector(了解，已过时)</li>
</ul>
</li>
<li>Set接口<ul>
<li>HashSet<ul>
<li>LinkedHashSet</li>
</ul>
</li>
<li>TreeSet</li>
</ul>
</li>
</ul>
</li>
<li><p>Map接口  继承JAVA.lang.Object</p>
<ul>
<li><p><strong>HashMap</strong></p>
<ul>
<li>LinkedHashMap</li>
</ul>
</li>
<li><p>TreeMap</p>
</li>
<li><p>ConcurrentHashMap</p>
</li>
<li><p>Hashtable(了解，，已过时)</p>
</li>
</ul>
</li>
</ul>
<h2 id="Collection接口："><a href="#Collection接口：" class="headerlink" title="Collection接口："></a>Collection接口：</h2><ul>
<li><p>Collection接口的常用方法</p>
</li>
<li><p>添加功能</p>
<ul>
<li><table>
<thead>
<tr>
<th>boolean add(Object obj)</th>
<th>添加一个元素</th>
</tr>
</thead>
<tbody><tr>
<td>boolean  addAll(Collection c)</td>
<td>添加一个集合的元素</td>
</tr>
</tbody></table>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">static</span> Collection c = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"add:"</span>+c.add(<span class="string">"hello"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/* 输出为 add:true */</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<p>​             </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> Collection c1 = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    <span class="keyword">static</span> Collection c2 = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        c1.add(<span class="string">"xxxx"</span>);</span><br><span class="line">        System.out.println(<span class="string">"add:"</span> + c1.add(<span class="string">"hello"</span>));</span><br><span class="line">        System.out.println(<span class="string">"addAll:"</span> + c2.addAll(c1));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/* 输出add:true</span></span><br><span class="line"><span class="comment">addAll:true */</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>删除功能</p>
<ul>
<li><table>
<thead>
<tr>
<th>void clear()</th>
<th>移除所有元素</th>
</tr>
</thead>
<tbody><tr>
<td>boolean remove(Object o)</td>
<td>移除一个元素</td>
</tr>
<tr>
<td>boolean removeAll(Object o)</td>
<td>移除一个集合的所有元素</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>判断功能</p>
<ul>
<li><table>
<thead>
<tr>
<th>boolean contains(Object o)</th>
<th>判断集合中是否包含指定的元素</th>
</tr>
</thead>
<tbody><tr>
<td>boolean containsAll(Object o)</td>
<td>判断集合中是否包含指定的集合元素（一个集合中的所有元素</td>
</tr>
<tr>
<td>boolean isEmpty()</td>
<td>判断集合是否为空</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p><strong>获取功能</strong></p>
<p>重点：迭代器（Iterator） 下一篇中我们详细解释。</p>
<p>itetator()   返回在此 Collection 的元素上进行迭代的迭代器。用于遍历集合中的对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Muster</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Collection&lt;String&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">"a"</span>);</span><br><span class="line">        list.add(<span class="string">"b"</span>);</span><br><span class="line">        list.add(<span class="string">"c"</span>);</span><br><span class="line">        Iterator&lt;String&gt; it=list.iterator();</span><br><span class="line">        <span class="keyword">while</span>(it.hasNext())</span><br><span class="line">        &#123;</span><br><span class="line">            String str=(String) it.next();</span><br><span class="line">            System.out.println(str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>JAVASE</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA泛型</title>
    <url>/2020/05/12/JAVA%E6%B3%9B%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2>]]></content>
  </entry>
  <entry>
    <title>JAVA中的输入与输出</title>
    <url>/2020/05/06/JAVA%E4%B8%AD%E7%9A%84%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA/</url>
    <content><![CDATA[<h1 id="JAVA中的输入"><a href="#JAVA中的输入" class="headerlink" title="JAVA中的输入"></a>JAVA中的输入</h1><h2 id="读取输入"><a href="#读取输入" class="headerlink" title="读取输入"></a>读取输入</h2><p>  要想通过输入台进行输入，首先需要构造一个与“标准输入流”System.in关联的Scanner对象。<br>  <a id="more"></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Scanner scanner=<span class="keyword">new</span> Scanner(System.in);</span><br></pre></td></tr></table></figure>

<p>Scanner类中的方法：</p>
<p>API  JAVA.util.Scanner</p>
<table>
<thead>
<tr>
<th>String nextLine()</th>
<th>读取输入的下一行内容  以enter作为结束符  能得到带空格的字符串</th>
</tr>
</thead>
<tbody><tr>
<td>String next()</td>
<td>读取输入的下一个单词（以空格作为分隔符）空格视而不见</td>
</tr>
<tr>
<td>int nextInt()</td>
<td>只读取int值</td>
</tr>
<tr>
<td>double nextDouble()</td>
<td>只读取double值</td>
</tr>
<tr>
<td>boolean hasNext()</td>
<td>检测输入中是否还有其他的单词</td>
</tr>
<tr>
<td>boolean hasNextInt()</td>
<td>检测输入中是否还有表示整数</td>
</tr>
<tr>
<td>boolean hasNextDouble()</td>
<td>检测输入中是否还有表示浮点数</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>JAVASE</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA的静态方法不能被重写</title>
    <url>/2020/05/06/JAVA%E7%9A%84%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E4%B8%8D%E8%83%BD%E8%A2%AB%E9%87%8D%E5%86%99/</url>
    <content><![CDATA[<h1 id="JAVA的静态方法不能被重写"><a href="#JAVA的静态方法不能被重写" class="headerlink" title="JAVA的静态方法不能被重写"></a>JAVA的静态方法不能被重写</h1><p>堆区：</p>
<ul>
<li>存储的全部都是对象，每个对象都包含一个与之对应的class信息。<a id="more"></a>

</li>
</ul>
<p>栈区:</p>
<p>方法区：</p>
<ul>
<li>方法区包含所有的class和static变量  class可以直接调用static</li>
</ul>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>JAVASE</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA多态</title>
    <url>/2020/05/06/JAVA%E5%A4%9A%E6%80%81/</url>
    <content><![CDATA[<h1 id="JAVA多态"><a href="#JAVA多态" class="headerlink" title="JAVA多态"></a>JAVA多态</h1><p>JAVA的三大特性为：</p>
<ul>
<li><p>封装</p>
</li>
<li><p>继承</p>
</li>
<li><p>多态</p>
<p>今天我们就来说一说到底什么是多态，以及多态到底有什么用。</p>
<a id="more"></a>

<h2 id="多态的定义"><a href="#多态的定义" class="headerlink" title="多态的定义"></a>多态的定义</h2><p>定义： <strong>事物的不同形态。</strong>多态多应用在向上转型。</p>
<p>多态的用处：在实际开发中，如果发现某个类的方法可以做出改进，但工程已经交付给用户使用，但是不想影响其他部分对于该方法的调用。那么通过创建子类对象，对于父类方法进行<strong>重写</strong>（Override）。<strong>但是此时父类的其他成员方法和成员属性却不能进行利用</strong>。此时就需要用到<strong>向上转型</strong>，将子类向上转换为父类，此时程序的相应方法做出了改进，程序的其他地方也不会受此影响。</p>
</li>
</ul>
<h2 id="多态的三个前提："><a href="#多态的三个前提：" class="headerlink" title="多态的三个前提："></a>多态的三个前提：</h2><ul>
<li><p>存在继承关系，子类继承父类</p>
</li>
<li><p>子类要重写父类的方法 </p>
<p>子类重写父类的成员方法。</p>
</li>
<li><p>父类数据类型的引用要指向子类对象 （向上转型）</p>
<p>如 Animal am=new Cat();</p>
<h2 id="多态的弊端"><a href="#多态的弊端" class="headerlink" title="多态的弊端"></a>多态的弊端</h2><p>向上转型之后，<strong>不能够引用子类特有的成员属性和子类特有的成员方法</strong>。</p>
</li>
</ul>
<p>  <strong>注意：静态方法不能被重写，所以也不存在多态，即使向上转型，子类重写了父类的静态方法，子类调用父类的静态方法，输出依然是父类静态方法中的值。</strong></p>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>JAVASE</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA中this和super的用法总结</title>
    <url>/2020/05/09/JAVA%E4%B8%ADthis%E5%92%8Csuper%E7%9A%84%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍这几天看到类在继承时会用到<strong>this</strong>和<strong>super</strong>，这里就做了一点总结，与各位共同交流，有错误请各位指正~</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p><strong>this</strong></p>
<p>this是自身的一个对象，代表对象本身，可以理解为：指向对象本身的一个指针。</p>
<h2 id="this的用法在java中大体可以分为3种："><a href="#this的用法在java中大体可以分为3种：" class="headerlink" title="this的用法在java中大体可以分为3种："></a>this的用法在java中大体可以分为3种：</h2><p><strong>1.普通的直接引用</strong></p>
<p>这种就不用讲了，this相当于是指向当前对象本身。</p>
<p><strong>2.形参与成员名字重名，用this来区分：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age = <span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"初始化年龄："</span>+age);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">GetAge</span><span class="params">(<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person Harry = <span class="keyword">new</span> Person();</span><br><span class="line">        System.out.println(<span class="string">"Harry's age is "</span>+Harry.GetAge(<span class="number">12</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果：</strong></p>
<p><strong>初始化年龄：10</strong><br><strong>Harry’s age is 12</strong></p>
<p>可以看到，这里age是GetAge成员方法的形参，this.age是Person类的成员变量。</p>
<p><strong>3.引用构造函数</strong></p>
<p>这个和super放在一起讲，见下面。</p>
<h2 id="super"><a href="#super" class="headerlink" title="super"></a><strong>super</strong></h2><p>super可以理解为是指向自己超（父）类对象的一个指针，而这个超类指的是离自己最近的一个父类。</p>
<h3 id="super也有三种用法："><a href="#super也有三种用法：" class="headerlink" title="super也有三种用法："></a>super也有三种用法：</h3><p>1.普通的直接引用</p>
<p>与this类似，super相当于是指向当前对象的父类，这样就可以用super.xxx来引用父类的成员。</p>
<p>2.子类中的成员变量或方法与父类中的成员变量或方法同名</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Country</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       name = <span class="string">"China"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">City</span> <span class="keyword">extends</span> <span class="title">Country</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    name = <span class="string">"Shanghai"</span>;</span><br><span class="line">    <span class="keyword">super</span>.value();      <span class="comment">//调用父类的方法</span></span><br><span class="line">    System.out.println(name);</span><br><span class="line">    System.out.println(<span class="keyword">super</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       City c=<span class="keyword">new</span> City();</span><br><span class="line">       c.value();</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果：</strong></p>
<p><strong>Shanghai</strong><br><strong>China</strong></p>
<p>可以看到，这里既调用了父类的方法，也调用了父类的变量。若不调用父类方法value()，只调用父类变量name的话，则父类name值为默认值null。</p>
<p>3.引用构造函数</p>
<p>super（参数）：调用父类中的某一个构造函数（应该为构造函数中的第一条语句）。</p>
<p>this（参数）：调用本类中另一种形式的构造函数（应该为构造函数中的第一条语句）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prt</span><span class="params">(String s)</span> </span>&#123; </span><br><span class="line">       System.out.println(s); </span><br><span class="line">    &#125; </span><br><span class="line">   </span><br><span class="line">    Person() &#123; </span><br><span class="line">       prt(<span class="string">"父类·无参数构造方法： "</span>+<span class="string">"A Person."</span>); </span><br><span class="line">    &#125;<span class="comment">//构造方法(1) </span></span><br><span class="line">    </span><br><span class="line">    Person(String name) &#123; </span><br><span class="line">       prt(<span class="string">"父类·含一个参数的构造方法： "</span>+<span class="string">"A person's name is "</span> + name); </span><br><span class="line">    &#125;<span class="comment">//构造方法(2) </span></span><br><span class="line">&#125; </span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Chinese</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123; </span><br><span class="line">    Chinese() &#123; </span><br><span class="line">       <span class="keyword">super</span>(); <span class="comment">// 调用父类构造方法（1） </span></span><br><span class="line">       prt(<span class="string">"子类·调用父类”无参数构造方法“： "</span>+<span class="string">"A chinese coder."</span>); </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    Chinese(String name) &#123; </span><br><span class="line">       <span class="keyword">super</span>(name);<span class="comment">// 调用父类具有相同形参的构造方法（2） </span></span><br><span class="line">       prt(<span class="string">"子类·调用父类”含一个参数的构造方法“： "</span>+<span class="string">"his name is "</span> + name); </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    Chinese(String name, <span class="keyword">int</span> age) &#123; </span><br><span class="line">       <span class="keyword">this</span>(name);<span class="comment">// 调用具有相同形参的构造方法（3） </span></span><br><span class="line">       prt(<span class="string">"子类：调用子类具有相同形参的构造方法：his age is "</span> + age); </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">       Chinese cn = <span class="keyword">new</span> Chinese(); </span><br><span class="line">       cn = <span class="keyword">new</span> Chinese(<span class="string">"codersai"</span>); </span><br><span class="line">       cn = <span class="keyword">new</span> Chinese(<span class="string">"codersai"</span>, <span class="number">18</span>); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果：</strong></p>
<p><strong>父类·无参数构造方法： A Person.</strong><br><strong>子类·调用父类”无参数构造方法“： A chinese coder.</strong><br><strong>父类·含一个参数的构造方法： A person’s name is codersai</strong><br><strong>子类·调用父类”含一个参数的构造方法“： his name is codersai</strong><br><strong>父类·含一个参数的构造方法： A person’s name is codersai</strong><br><strong>子类·调用父类”含一个参数的构造方法“： his name is codersai</strong><br><strong>子类：调用子类具有相同形参的构造方法：his age is 18</strong></p>
<p>从本例可以看到，可以用super和this分别调用父类的构造方法和本类中其他形式的构造方法。</p>
<p>例子中Chinese类第三种构造方法调用的是本类中第二种构造方法，而第二种构造方法是调用父类的，因此也要先调用父类的构造方法，再调用本类中第二种，最后是重写第三种构造方法。</p>
<p><strong>super和this的异同：</strong></p>
<ul>
<li>super（参数）：调用基类中的某一个构造函数（应该为构造函数中的第一条语句） </li>
<li>this（参数）：调用本类中另一种形成的构造函数（应该为构造函数中的第一条语句）</li>
<li>super:　它引用当前对象的直接父类中的成员（用来访问直接父类中被隐藏的父类中成员数据或函数，基类与派生类中有相同成员定义时如：super.变量名  super.成员函数据名（实参）</li>
<li>this：它代表当前对象名（在程序中易产生二义性之处，应使用this来指明当前对象；如果函数的形参与类中的成员数据同名，这时需用this来指明成员变量名）</li>
<li>调用super()必须写在子类构造方法的第一行，否则编译不通过。每个子类构造方法的第一条语句，都是隐含地调用super()，如果父类没有这种形式的构造函数，那么在编译的时候就会报错。</li>
<li>super()和this()类似,区别是，super()从子类中调用父类的构造方法，this()在同一类内调用其它方法。</li>
<li>super()和this()均需放在构造方法内第一行。</li>
<li>尽管可以用this调用一个构造器，但却不能调用两个。</li>
<li>this和super不能同时出现在一个构造函数里面，因为this必然会调用其它的构造函数，其它的构造函数必然也会有super语句的存在，所以在同一个构造函数里面有相同的语句，就失去了语句的意义，编译器也不会通过。</li>
<li>this()和super()都指的是对象，所以，均不可以在static环境中使用。包括：static变量,static方法，static语句块。</li>
<li>从本质上讲，this是一个指向本对象的指针, 然而super是一个Java关键字。</li>
</ul>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>JAVASE</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA编译和运行的过程</title>
    <url>/2020/05/11/JAVA%E7%BC%96%E8%AF%91%E5%92%8C%E8%BF%90%E8%A1%8C%E7%9A%84%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍JAVA编译和运行的过程</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><ul>
<li><p>JAVA程序源码 </p>
</li>
<li><p>——-&gt; JAVA字节码（经过编译器编译)</p>
</li>
<li><p>——-&gt;JVM （对字节码进行解释和运行）</p>
<p>编译只进行一次，但是解释在每次运行程序时都会运行，编译的字节码采用一种针对JVM优化过度机器码的形式进行保存</p>
</li>
<li><p>——&gt;机器码（虚拟机将字节码解释为机器码，在计算机上运行）</p>
<p><img src="/2020/05/11/JAVA%E7%BC%96%E8%AF%91%E5%92%8C%E8%BF%90%E8%A1%8C%E7%9A%84%E8%BF%87%E7%A8%8B/Screenshot.png" alt></p>
</li>
</ul>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>JAVASE</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA注解</title>
    <url>/2020/05/11/JAVA%E6%B3%A8%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍 JAVA注解</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h2 id="1-注解的概述"><a href="#1-注解的概述" class="headerlink" title="1.注解的概述"></a>1.注解的概述</h2><p>注解的语法： @注解名称</p>
<p>注解的作用:  替代xml配置文件</p>
<p>我们以前总是要写一些配置文件，如web.xml 里面要写<servlet> 和<sevlet-mapping></sevlet-mapping></servlet></p>
<p>tomcat用来读取配置文件</p>
<p>而在servlet3.0中可以使用注解来代替配置文件，@WebServlet 用来代替该配置文件</p>
<h2 id="2-JAVA中的注解"><a href="#2-JAVA中的注解" class="headerlink" title="2. JAVA中的注解"></a>2. JAVA中的注解</h2><ul>
<li>@Override</li>
<li>@Deprecated: 作用在方法上，标记该方法为作废方法 （已经过时的方法）</li>
<li>@SuppressWarning :作用在方法上，压制警告@SuppressWarnings(“all”)压制所有警告</li>
</ul>
<h2 id="3-注解的使用"><a href="#3-注解的使用" class="headerlink" title="3. 注解的使用"></a>3. 注解的使用</h2><ul>
<li>定义注解类：框架的工作</li>
<li>使用注解类：我们的工作</li>
<li>读取注解（反射）：框架的工作</li>
</ul>
<h2 id="4-自定义注解类"><a href="#4-自定义注解类" class="headerlink" title="4.自定义注解类"></a>4.自定义注解类</h2><p><strong>@interface</strong></p>
<p>eg:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnn&#123;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-使用注解的目标"><a href="#5-使用注解的目标" class="headerlink" title="5.使用注解的目标"></a>5.使用注解的目标</h2><p>注解可以使用在类（接口或者枚举），属性，方法，构造器，包，参数，局部变量</p>
<p>eg:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@MyAnn</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="meta">@MyAnn</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> a;</span><br><span class="line"><span class="meta">@MyAnn</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyClass</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;&#125;</span><br><span class="line"><span class="meta">@MyAnn</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;&#125;</span><br><span class="line"><span class="meta">@MyAnn</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun2</span><span class="params">(@MyAnn String s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="meta">@MyAnn</span></span><br><span class="line">    <span class="keyword">int</span> n=<span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-注解的属性"><a href="#6-注解的属性" class="headerlink" title="6.注解的属性"></a>6.注解的属性</h2><p>定义注解时，也可以给出属性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnn</span><br><span class="line">&#123;</span><br><span class="line"><span class="function">String <span class="title">value</span><span class="params">()</span></span>;  <span class="keyword">default</span> <span class="string">"hello world"</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">value1</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中value就是属性，你可能会说value是一个方法，没错，它是一个方法，但是我们非要称之为属性，是因为把它当作属性更好理解:</p>
<p>eg:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@MyAnn</span>(value1=<span class="number">100</span>,value=<span class="string">"hello"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></span><br><span class="line"><span class="class"></span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>注解的属性后面要有一对圆括号，而且圆括号内不能给出东西。就像是无参的方法一样；<br>注解的属性类型只能是：基本类型、String、Enum、Class、注解类型、以上类型的一维数组类型；<br>注解的属性可以有默认值，例如：int a() default 100;<br>数组的属性默认值：int[] arr() default {1,2,3}，这里不能使用new int[]{1,2,3}<br>使用注解时，在给数组属性赋值时的格式：@MyAnn(arr={1,2,3})；</li>
</ul>
<h2 id="7-元注解"><a href="#7-元注解" class="headerlink" title="7.元注解"></a>7.元注解</h2><p><strong>元注解：用于描述注解的注解</strong></p>
<p>@Target ：描述注解作用的位置</p>
<ul>
<li>ElementType取值：</li>
<li>TYPE：作用在类上</li>
<li>METHOD ：作用在方法上</li>
<li>FIELD ：作用在成员变量上</li>
</ul>
<p>eg：</p>
<p>Target 注解的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Target &#123;  </span><br><span class="line">    ElementType[] value();  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> ElementType &#123;  </span><br><span class="line">  TYPE,FIELD,METHOD,PARAMETED,CONSTRUCTOR,LOCAL_VARIABLE,ANNOCATION_TYPE,PACKAGE  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在定义注解时，可以使用@Target 注解来限制注解的作用目标</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE,ElementType.METHOD&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnn</span><br><span class="line">&#123;&#125;  <span class="comment">/* 该注解定义在类和方法上 */</span></span><br><span class="line"><span class="meta">@MyAnn</span>()  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;  </span><br><span class="line">    <span class="meta">@MyAnn</span>()  <span class="comment">//报错  </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a;  </span><br><span class="line">      </span><br><span class="line">    <span class="meta">@MyAnn</span>()  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123;&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-注解的保留策略"><a href="#8-注解的保留策略" class="headerlink" title="8.注解的保留策略"></a>8.注解的保留策略</h2><ul>
<li><p>注解的保留策略是指</p>
<ul>
<li>注解保留在源代码（SOURCE)上</li>
<li>注解保留在class文件上（CLASS）</li>
<li>注解保留在类运行时（RUNTIME），可以被类加载器加载到内存中</li>
</ul>
</li>
<li><p>如果希望注解被反射，那么注解就是保留到运行时，而不是源代码或者类文件上</p>
</li>
<li><p>指定注解的保留策略需要使用元注解@Retention ，它有一个value属性，类型为RetentionPolicy</p>
<p>RetentionPolicy是枚举类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Retention &#123;  </span><br><span class="line">    <span class="function">RetentionPolicy <span class="title">value</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> RetentionPolicy &#123;  </span><br><span class="line">    SOURCE, CLASS, RUNTIME  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>eg：指定注解保留到运行时</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetionOPlicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE,ElementType.METHOD&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnn</span><br><span class="line">&#123;</span><br><span class="line"><span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> "hello"</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">value1</span><span class="params">()</span> <span class="keyword">default</span> 100</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="9-注解处理器"><a href="#9-注解处理器" class="headerlink" title="9.注解处理器"></a>9.注解处理器</h2>]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>JAVASE</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA集合面试</title>
    <url>/2020/05/12/JAVA%E9%9B%86%E5%90%88%E9%9D%A2%E8%AF%95/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍JAVA集合面试</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p><strong>1）说说常见的集合有哪些吧？</strong></p>
<p>答：Map 接口和 Collection 接口是所有集合框架的父接口：</p>
<ol>
<li>Collection 接口的子接口包括：Set 接口和 List 接口；</li>
<li>Map 接口的实现类主要有：HashMap、TreeMap、Hashtable、ConcurrentHashMap 以及 Properties 等；</li>
<li>Set 接口的实现类主要有：HashSet、TreeSet、LinkedHashSet 等；</li>
<li>List 接口的实现类主要有：ArrayList、LinkedList、Stack 以及 Vector 等。</li>
</ol>
<p><strong>（2）HashMap 和 Hashtable 的区别有哪些？（必问）</strong></p>
<p>答：</p>
<ol>
<li>HashMap 没有考虑同步，是线程不安全的；Hashtable 使用了 synchronized 关键字，是线程安全的；</li>
<li>前者允许 null 作为 Key；后者不允许 null 作为 Key。</li>
</ol>
<p><strong>6）List 和 Set 的区别是啥？</strong></p>
<p>答：List 元素是有序的，可以重复；Set 元素是无序的，不可以重复。</p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>JAVASE</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA面试</title>
    <url>/2020/05/11/JAVA%E9%9D%A2%E8%AF%95/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p><img src="/2020/05/11/JAVA%E9%9D%A2%E8%AF%95/E:%5Cdev%5CMYBLOG%5Cblog%5Csource_posts%5CJAVA%E9%9D%A2%E8%AF%95%5C2020-05-11_205422.png" alt></p>
]]></content>
  </entry>
  <entry>
    <title>JDK中常用的包有哪些？</title>
    <url>/2020/05/11/JDK%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E5%8C%85%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍JDK中常用的包</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>JDK中常用的包有哪些？</p>
<ul>
<li>JAVA.lang  java语言的核心类，如String,Math,Interger,System,和Thread</li>
<li>java.io 提供多种输入/输出功能的类</li>
<li>java.net 包括执行与网络相关的操作的类</li>
<li>java.util 包括一些实用的工具类，如定义系统的特性，与日期日历相关的方法</li>
<li>java.awt 抽象窗口工具集，用来构建和管理应用程序的GUI</li>
<li>java.applet 包含applet运行所需的类</li>
<li>java.swing 用来建立图形用户界面</li>
</ul>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>JAVASE</tag>
      </tags>
  </entry>
  <entry>
    <title>Map</title>
    <url>/2020/05/08/Map/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍Map</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h2 id="一-Map的定义"><a href="#一-Map的定义" class="headerlink" title="一.Map的定义"></a>一.Map的定义</h2><p>Map是一种依照键（key）存储元素的容器，键（key）很像下标。在List里下标是整数，而在Map中键（key）可以是任意类型的对象。Map中不能有重复的键（key），每个键都有一个对应的值（value)</p>
<p>一个键（key）和它对应的值（value)构成Map集合中的一个元素。</p>
<p>Map中的元素是俩个对象，一个对象作为键，一个对象作为值，<strong>键不可以重复，但是值可以重复。</strong></p>
<h2 id="二-Map常用方法"><a href="#二-Map常用方法" class="headerlink" title="二.Map常用方法"></a>二.Map常用方法</h2><ul>
<li><p>添加</p>
<table>
<thead>
<tr>
<th>put(key,Value)</th>
<th>可以添加相同的key值，但是添加的value值会覆盖前面的value值。返回的是oldValue（返回被覆盖的值）,如果没有就返回null</th>
</tr>
</thead>
<tbody><tr>
<td>putAll</td>
<td>从指定映射中将所有映射关系复制到此映射中去。</td>
</tr>
</tbody></table>
</li>
<li><p>删除</p>
<table>
<thead>
<tr>
<th>remove(key)</th>
<th>删除指定key的键值对，返回被删除的key关联的value，不存在返回null</th>
</tr>
</thead>
<tbody><tr>
<td>remove(key,value)</td>
<td>删除指定键值对，成功返回true</td>
</tr>
<tr>
<td>clear()</td>
<td>删除map中所有的键值对</td>
</tr>
</tbody></table>
</li>
<li><p>获取</p>
<table>
<thead>
<tr>
<th>get(key)</th>
<th>返回指定key所对应的value，不存在则返回null</th>
</tr>
</thead>
<tbody><tr>
<td>Int size()</td>
<td>获取长度</td>
</tr>
</tbody></table>
</li>
<li><p>判断</p>
<table>
<thead>
<tr>
<th>boolean isEmpty()</th>
<th>长度为0返回true，否则false</th>
</tr>
</thead>
<tbody><tr>
<td>boolean containsKey(Object key)</td>
<td>判断集合中是否包含指定的key</td>
</tr>
<tr>
<td>boolean containsValue(Object value)</td>
<td>判断集合中是否包含指定的value</td>
</tr>
</tbody></table>
</li>
</ul>
<p>示例：</p>
<p>添加：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This program demonstrates</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Alita Alice</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: Created in 13:48 2020/5/9</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo7</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Integer&gt; map1 = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map1.put(<span class="string">"jack"</span>, <span class="number">20</span>);</span><br><span class="line">        map1.put(<span class="string">"rose"</span>, <span class="number">18</span>);</span><br><span class="line">        map1.put(<span class="string">"lucy"</span>, <span class="number">17</span>);</span><br><span class="line">        map1.put(<span class="string">"java"</span>, <span class="number">25</span>);</span><br><span class="line">        System.out.println(<span class="string">"map11"</span>+map1);</span><br><span class="line"></span><br><span class="line">        Map&lt;String,Integer&gt; map2=<span class="keyword">new</span> HashMap();</span><br><span class="line">        map2.put(<span class="string">"张三丰"</span>, <span class="number">100</span>);</span><br><span class="line">        map2.put(<span class="string">"虚竹"</span>, <span class="number">20</span>);</span><br><span class="line">        System.out.println(<span class="string">"map2"</span>+map2);</span><br><span class="line">        <span class="comment">//从指定映射种将所有的映射关系复制到此映射种</span></span><br><span class="line">        map1.putAll(map2);</span><br><span class="line">        System.out.println(<span class="string">"map1"</span>+map1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* out</span></span><br><span class="line"><span class="comment">map11&#123;java=25, rose=18, lucy=17, jack=20&#125;</span></span><br><span class="line"><span class="comment">map2&#123;张三丰=100, 虚竹=20&#125;</span></span><br><span class="line"><span class="comment">map1&#123;java=25, 张三丰=100, rose=18, lucy=17, jack=20, 虚竹=20&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>删除：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This program demonstrates</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Alita Alice</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: Created in 13:48 2020/5/9</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo7</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Integer&gt; map1 = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map1.put(<span class="string">"jack"</span>, <span class="number">20</span>);</span><br><span class="line">        map1.put(<span class="string">"rose"</span>, <span class="number">18</span>);</span><br><span class="line">        map1.put(<span class="string">"lucy"</span>, <span class="number">17</span>);</span><br><span class="line">        map1.put(<span class="string">"java"</span>, <span class="number">25</span>);</span><br><span class="line">        System.out.println(map1);</span><br><span class="line">        System.out.println(<span class="string">"delete value:"</span>+map1.remove(<span class="string">"java"</span>));</span><br><span class="line">        map1.clear();</span><br><span class="line">        System.out.println(<span class="string">"map1"</span>+map1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* out</span></span><br><span class="line"><span class="comment">&#123;java=25, rose=18, lucy=17, jack=20&#125;</span></span><br><span class="line"><span class="comment">delete value:25</span></span><br><span class="line"><span class="comment">map1&#123;&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>获取：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This program demonstrates</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Alita Alice</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: Created in 13:48 2020/5/9</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo7</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Integer&gt; map1 = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map1.put(<span class="string">"jack"</span>, <span class="number">20</span>);</span><br><span class="line">        map1.put(<span class="string">"rose"</span>, <span class="number">18</span>);</span><br><span class="line">        map1.put(<span class="string">"lucy"</span>, <span class="number">17</span>);</span><br><span class="line">        map1.put(<span class="string">"java"</span>, <span class="number">25</span>);</span><br><span class="line">        System.out.println(map1);</span><br><span class="line">        System.out.println(<span class="string">"value:"</span>+map1.get(<span class="string">"jack"</span>));</span><br><span class="line">        System.out.println(<span class="string">"map.size:"</span>+map1.size());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* out</span></span><br><span class="line"><span class="comment">&#123;java=25, rose=18, lucy=17, jack=20&#125;</span></span><br><span class="line"><span class="comment">value:20</span></span><br><span class="line"><span class="comment">map.size:4</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>判断：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This program demonstrates</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Alita Alice</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: Created in 13:48 2020/5/9</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo7</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Integer&gt; map1 = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map1.put(<span class="string">"jack"</span>, <span class="number">20</span>);</span><br><span class="line">        map1.put(<span class="string">"rose"</span>, <span class="number">18</span>);</span><br><span class="line">        map1.put(<span class="string">"lucy"</span>, <span class="number">17</span>);</span><br><span class="line">        map1.put(<span class="string">"java"</span>, <span class="number">25</span>);</span><br><span class="line">        System.out.println(map1);</span><br><span class="line">        System.out.println(<span class="string">"isEmpty"</span>+map1.isEmpty());</span><br><span class="line">        System.out.println(<span class="string">"containskey"</span>+map1.containsKey(<span class="string">"jack"</span>));</span><br><span class="line">        System.out.println(<span class="string">"containsvaluse"</span>+map1.containsValue(<span class="number">100</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* out</span></span><br><span class="line"><span class="comment">&#123;java=25, rose=18, lucy=17, jack=20&#125;</span></span><br><span class="line"><span class="comment">isEmptyfalse</span></span><br><span class="line"><span class="comment">containskeytrue</span></span><br><span class="line"><span class="comment">containsvalusefalse</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="三-遍历Map的方式"><a href="#三-遍历Map的方式" class="headerlink" title="三.遍历Map的方式"></a>三.遍历Map的方式</h3><ul>
<li><p><strong>使用KeySet</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This program demonstrates</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Alita Alice</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: Created in 13:48 2020/5/9</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo7</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Integer&gt; map1 = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map1.put(<span class="string">"jack"</span>, <span class="number">20</span>);</span><br><span class="line">        map1.put(<span class="string">"rose"</span>, <span class="number">18</span>);</span><br><span class="line">        map1.put(<span class="string">"lucy"</span>, <span class="number">17</span>);</span><br><span class="line">        map1.put(<span class="string">"java"</span>, <span class="number">25</span>);</span><br><span class="line">        System.out.println(map1);</span><br><span class="line">        Set&lt;String&gt; ks=map1.keySet();</span><br><span class="line">        Iterator&lt;String&gt; it=ks.iterator();</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext())</span><br><span class="line">        &#123;</span><br><span class="line">            String key=it.next();</span><br><span class="line">            Integer value = map1.get(key);</span><br><span class="line">            System.out.println(<span class="string">"key="</span>+key+<span class="string">" value="</span>+value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* out</span></span><br><span class="line"><span class="comment">&#123;java=25, rose=18, lucy=17, jack=20&#125;</span></span><br><span class="line"><span class="comment">key=java value=25</span></span><br><span class="line"><span class="comment">key=rose value=18</span></span><br><span class="line"><span class="comment">key=lucy value=17</span></span><br><span class="line"><span class="comment">key=jack value=20</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>将Map转换成Set集合，通过Set的迭代器取出Set集合中的每一个元素（Iterator)就是Map集合中所有的键，再通过get方法获取键对应的值。</p>
</li>
<li><p>通过values获取所有的值，不能获取到key对象</p>
<p>Collection<V> values()</V></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo7</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Integer&gt; map1 = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map1.put(<span class="string">"jack"</span>, <span class="number">20</span>);</span><br><span class="line">        map1.put(<span class="string">"rose"</span>, <span class="number">18</span>);</span><br><span class="line">        map1.put(<span class="string">"lucy"</span>, <span class="number">17</span>);</span><br><span class="line">        map1.put(<span class="string">"java"</span>, <span class="number">25</span>);</span><br><span class="line">        Collection&lt;Integer&gt; vs=map1.values();  <span class="comment">//values方法获取所有的值但是不能获取到KEY对象。</span></span><br><span class="line">        Iterator&lt;Integer&gt; it = vs.iterator();</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext())</span><br><span class="line">        &#123;</span><br><span class="line">            Integer value=it.next();</span><br><span class="line">            System.out.println(<span class="string">"valuse="</span> +value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Map.Entry</p>
<p>面向对象的思想将Map集合中的键和值映射关系打包成一个对象，就是Map.Entry</p>
<p>将该对象存入Set集合，Map.Entry是一个对象，那么该对象具备的getKey ，getValue获得键和值。（<strong>通过Map中的entrySet()方法获取存放Map.Entry&lt;K,V&gt;对象的Set集合</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo7</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer,String&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="number">1</span>,<span class="string">"aaaa"</span>);</span><br><span class="line">        map.put(<span class="number">2</span>,<span class="string">"bbb"</span>);</span><br><span class="line">        map.put(<span class="number">3</span>, <span class="string">"cccc"</span>);</span><br><span class="line">        System.out.println(map);</span><br><span class="line"></span><br><span class="line">        Set&lt;Map.Entry&lt;Integer,String&gt;&gt; es=map.entrySet();</span><br><span class="line">        Iterator&lt;Map.Entry&lt;Integer,String&gt;&gt; it=es.iterator();</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext())</span><br><span class="line">        &#123;</span><br><span class="line">            Map.Entry&lt;Integer,String&gt; en =it.next();</span><br><span class="line">            Integer key=en.getKey();</span><br><span class="line">            String value=en.getValue();</span><br><span class="line">            System.out.println(<span class="string">"key="</span>+key+<span class="string">"value="</span>+value);</span><br><span class="line">        &#125;a</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* out</span></span><br><span class="line"><span class="comment">&#123;1=aaaa, 2=bbb, 3=cccc&#125;</span></span><br><span class="line"><span class="comment">key=1value=aaaa</span></span><br><span class="line"><span class="comment">key=2value=bbb</span></span><br><span class="line"><span class="comment">key=3value=cccc</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p>底层是哈希表数据结构，线程是不同步的，可以存入null键。</p>
<p>要保证键的唯一性，需要覆盖hashCode方法 和equals方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This program demonstrates</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Alita Alice</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: Created in 22:09 2020/5/10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;Person,String&gt; hm=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        hm.put(<span class="keyword">new</span> Person(<span class="string">"jack"</span>, <span class="number">20</span>), <span class="string">"1001"</span>);</span><br><span class="line">        hm.put(<span class="keyword">new</span> Person(<span class="string">"rose"</span>, <span class="number">18</span>), <span class="string">"1002"</span>);</span><br><span class="line">        hm.put(<span class="keyword">new</span> Person(<span class="string">"lucy"</span>, <span class="number">19</span>), <span class="string">"1003"</span>);</span><br><span class="line">        hm.put(<span class="keyword">new</span> Person(<span class="string">"hmm"</span>, <span class="number">17</span>), <span class="string">"1004"</span>);</span><br><span class="line">        hm.put(<span class="keyword">new</span> Person(<span class="string">"ll"</span>, <span class="number">17</span>), <span class="string">"1005"</span>);</span><br><span class="line">        System.out.println(hm);</span><br><span class="line">        System.out.println(hm.put(<span class="keyword">new</span> Person(<span class="string">"rose"</span>, <span class="number">18</span>), <span class="string">"1006"</span>));</span><br><span class="line">        Set&lt;Map.Entry&lt;Person,String&gt;&gt; entrySet =hm.entrySet();</span><br><span class="line">        Iterator&lt;Map.Entry&lt;Person,String&gt;&gt; it= entrySet.iterator();</span><br><span class="line">        <span class="keyword">while</span>  (it.hasNext())</span><br><span class="line">        &#123;</span><br><span class="line">            Map.Entry&lt;Person,String&gt; next=it.next();</span><br><span class="line">            Person key =next.getKey();</span><br><span class="line">            String value=next.getValue();</span><br><span class="line">            System.out.println(key+ <span class="string">"="</span> +value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span>  String name;</span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">int</span> age;</span><br><span class="line">    Person()</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Person)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Person person = (Person) o;</span><br><span class="line">        <span class="keyword">return</span> getAge() == person.getAge() &amp;&amp;</span><br><span class="line">                getName().equals(person.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(getName(), getAge());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* out </span></span><br><span class="line"><span class="comment">&#123;Person&#123;name='ll', age=17&#125;=1005, Person&#123;name='jack', age=20&#125;=1001, Person&#123;name='hmm', age=17&#125;=1004, Person&#123;name='lucy', age=19&#125;=1003, Person&#123;name='rose', age=18&#125;=1002&#125;</span></span><br><span class="line"><span class="comment">1002</span></span><br><span class="line"><span class="comment">Person&#123;name='ll', age=17&#125;=1005</span></span><br><span class="line"><span class="comment">Person&#123;name='jack', age=20&#125;=1001</span></span><br><span class="line"><span class="comment">Person&#123;name='hmm', age=17&#125;=1004</span></span><br><span class="line"><span class="comment">Person&#123;name='lucy', age=19&#125;=1003</span></span><br><span class="line"><span class="comment">Person&#123;name='rose', age=18&#125;=1006</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h2><p>TreeMap的排序，TreeMap 可以对集合中的键进行排序，如何实现对键的排序？</p>
<h3 id="方式1：-元素自身具备比较性"><a href="#方式1：-元素自身具备比较性" class="headerlink" title="方式1： 元素自身具备比较性"></a>方式1： 元素自身具备比较性</h3><p>和TreeSet一样原理，需要让存储在键位置的对象实现Comparable接口。重写compareTo方法，也就是让元素自身具备比较性，这种方式叫做元素的自然排序也叫默认排序。</p>
<h3 id="方式2：容器具备比较性"><a href="#方式2：容器具备比较性" class="headerlink" title="方式2：容器具备比较性"></a>方式2：容器具备比较性</h3><p>当元素自身不具备比较性，或者自身具备的比较性不是所需要的，那么此时可以让<strong>容器自身具备</strong>，需要定义一个类<strong>实现接口Compatator，重写compare方法，并将该接口的子类实例对象作为参数传递给TreeMap集合的构造方法。</strong></p>
<p>注意：当Comparable比较方式和Comparator比较方式同时存在时，以Comparator的比较方式为主。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This program demonstrates</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Alita Alice</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: Created in 22:09 2020/5/10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       TreeMap&lt;String,Integer&gt; tree=<span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">        tree.put(<span class="string">"张三"</span>,<span class="number">19</span>);</span><br><span class="line">        tree.put(<span class="string">"李四"</span>,<span class="number">20</span>);</span><br><span class="line">        tree.put(<span class="string">"王五"</span>,<span class="number">21</span>);</span><br><span class="line">        tree.put(<span class="string">"赵留"</span>,<span class="number">21</span>);</span><br><span class="line">        System.out.println(tree);</span><br><span class="line">        System.out.println(<span class="string">"张三"</span>.compareTo(<span class="string">"李四"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自定义元素排序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This program demonstrates</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Alita Alice</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: Created in 22:09 2020/5/10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">     TreeMap&lt;Person,String&gt; hm=<span class="keyword">new</span> TreeMap&lt;Person, String&gt;(<span class="keyword">new</span> MyComparator());<span class="comment">//该接口的子类实例对象作为参数传递给TreeMap集合的构造方法。</span></span><br><span class="line">        hm.put(<span class="keyword">new</span> Person(<span class="string">"jack"</span>,<span class="number">20</span>),<span class="string">"1001"</span>);</span><br><span class="line">        hm.put(<span class="keyword">new</span> Person(<span class="string">"rose"</span>, <span class="number">18</span>), <span class="string">"1002"</span>);</span><br><span class="line">        hm.put(<span class="keyword">new</span> Person(<span class="string">"lucy"</span>, <span class="number">19</span>), <span class="string">"1003"</span>);</span><br><span class="line">        hm.put(<span class="keyword">new</span> Person(<span class="string">"hmm"</span>, <span class="number">17</span>), <span class="string">"1004"</span>);</span><br><span class="line">        System.out.println(hm);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Set&lt;Map.Entry&lt;Person,String&gt;&gt; entrySet=hm.entrySet();</span><br><span class="line">        Iterator&lt;Map.Entry&lt;Person,String&gt;&gt; it=entrySet.iterator();</span><br><span class="line">        <span class="keyword">while</span>  (it.hasNext())</span><br><span class="line">        &#123;</span><br><span class="line">            Map.Entry&lt;Person,String&gt; next=it.next();</span><br><span class="line">            Person key=next.getKey();</span><br><span class="line">            String value=next.getValue();</span><br><span class="line">            System.out.println(key+ <span class="string">"="</span> +value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Person</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Person p1,Person p2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p1.getAge()&gt;p2.getAge())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p1.getAge()&lt;p2.getAge())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p1.getName().compareTo(p2.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Person</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">  Person()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Person)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Person person = (Person) o;</span><br><span class="line">        <span class="keyword">return</span> getAge() == person.getAge() &amp;&amp;</span><br><span class="line">                getName().equals(person.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(getName(), getAge());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Person p)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(<span class="keyword">this</span>.age&gt;p.age) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.age&lt;p.age)</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name.compareTo(p.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* out</span></span><br><span class="line"><span class="comment">&#123;Person&#123;name='jack', age=20&#125;=1001, Person&#123;name='lucy', age=19&#125;=1003, Person&#123;name='rose', age=18&#125;=1002, Person&#123;name='hmm', age=17&#125;=1004&#125;</span></span><br><span class="line"><span class="comment">Person&#123;name='jack', age=20&#125;=1001</span></span><br><span class="line"><span class="comment">Person&#123;name='lucy', age=19&#125;=1003</span></span><br><span class="line"><span class="comment">Person&#123;name='rose', age=18&#125;=1002</span></span><br><span class="line"><span class="comment">Person&#123;name='hmm', age=17&#125;=1004</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>注意：Set元素不可重复，Map的键不可重复</p>
<p>​           如果存入重复元素如何处理?</p>
<p>Set元素重复元素不能存入add方法，返回false;</p>
<p>Map的重复键将覆盖旧键，将旧值返回。</p>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>JAVA源码</tag>
      </tags>
  </entry>
  <entry>
    <title>JDK和JRE</title>
    <url>/2020/05/09/JDK%E5%92%8CJRE/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍JDK和JRE的区别，他们的作用分别是什么？</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h2 id="JDK"><a href="#JDK" class="headerlink" title="JDK"></a>JDK</h2><p>JDK是JAVA Development Kit (JAVA开发套件) ，是JAVA的开发工具包。主要包含了类库和工具。</p>
<p>JDK中包含了JRE 而且在JDK安装目录/JRE/bin/server 文件夹下包含jvm.dll</p>
<p><img src="/2020/05/09/JDK%E5%92%8CJRE/QQ20200509115538.png" alt></p>
<p>这说明JDK提供了一个虚拟机。</p>
<p>另外JDK的bin目录下有各种JAVA程序需要用到的命令。</p>
<p>与JRE明显的区别就饿死JDK文件下才会有javac</p>
<p><img src="/2020/05/09/JDK%E5%92%8CJRE/QQ20200509115836.png" alt></p>
<p>因为JRE只是一个运行环境，与开发无关。</p>
<h2 id="JRE"><a href="#JRE" class="headerlink" title="JRE"></a>JRE</h2><p>JRE是JAVA Runtime Environment的缩写。是JAVA程序的运行环境。既然是运行，那么当然要包含JVM,也就是JAVA虚拟机，还有所有JAVA类库的class文件，都在lib下，并且被打包成了jar </p>
<p><img src="/2020/05/09/JDK%E5%92%8CJRE/Screenshot.png" alt></p>
<h2 id="问题：jdk里的jre与外面jre的区别"><a href="#问题：jdk里的jre与外面jre的区别" class="headerlink" title="问题：jdk里的jre与外面jre的区别"></a>问题：jdk里的jre与外面jre的区别</h2><p>分析：如果我们安装了JDK，那么我们的电脑中将会有C:\Program Files (x86)\Java\jdk1.8.0_05文件夹 ，这个文件夹里面有一个jre文件夹。然后我们再安装jre，此时我们的电脑中有C:\Program Files (x86)\Java\jre8文件夹。</p>
<p>通过对比jre和jre8文件夹中的东西，我们发现基本是一样的，那么这俩文件夹到底有啥区别呢？</p>
<p>我们暂且称jre为自带jdk-jre，jre8为公共jre。</p>
<p>jdk-jre与公共jre的主要区别在于jdk-jre多了一个server的vm执行选项。</p>
<p>sever与client使用不同的vm虚拟机。如果电脑运行一个java程序的时候，会自动调用client vm。但是如果开发java程序时使用的就是server vm（server vm启动时间较长，占用内存较多，但是启动后执行性能更高，适合开发）。</p>
<p><strong>换句话说：公共jre是给普通电脑用户使用的，假如你安装了一个java程序，这个java程序启动运行的时候就会调用jre（java runtime environment）；如果你是一个java开发者，那么你就需要安装jdk（java development kit），这时你开发调试java程序的时候就会调用jdk里面的jre。</strong></p>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>JAVASE</tag>
      </tags>
  </entry>
  <entry>
    <title>List集合</title>
    <url>/2020/05/07/List%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>List集合包括List接口和List接口所有的实现类</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h2 id="List接口定义的方法"><a href="#List接口定义的方法" class="headerlink" title="List接口定义的方法"></a>List接口定义的方法</h2><p>除了继承Collection外，List接口还有俩个重要的方法。</p>
<table>
<thead>
<tr>
<th>get(int index)</th>
<th>获得指定索引位置的元素</th>
</tr>
</thead>
<tbody><tr>
<td>set(int index,Object obj)</td>
<td>将集合中指定索引位置的对象修改为指定的对象</td>
</tr>
</tbody></table>
<h2 id="List接口的实现类"><a href="#List接口的实现类" class="headerlink" title="List接口的实现类"></a>List接口的实现类</h2><ul>
<li><p>ArrayList</p>
<p>实现了可变的数组，允许保存所有元素包括null .并且可以根据索引的位置对集合进行快速的随机访问，缺点是向指向的索引位置插入对象或删除对象时的速度较慢</p>
</li>
<li><p>LinkedList </p>
<p>采用链表的结构保存对象。优点是便于向集合中插入和删除对象</p>
<p>分别用ArrayList 和LinkedList来实例化集合</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;E&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">List&lt;E&gt; list=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p>E是合法的JAVA数据类型，也可以是字符串String</p>
</li>
</ul>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>JAVASE</tag>
      </tags>
  </entry>
  <entry>
    <title>Java值传递和引用传递基础分析</title>
    <url>/2020/05/11/Java%E5%80%BC%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92%E5%9F%BA%E7%A1%80%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍JAVA的值传递和引用传递</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h2 id="java内的基础类型数据传递都是值传递-java中实例对象的传递是引用传递。"><a href="#java内的基础类型数据传递都是值传递-java中实例对象的传递是引用传递。" class="headerlink" title="java内的基础类型数据传递都是值传递. java中实例对象的传递是引用传递。"></a>java内的基础类型数据传递都是值传递. java中实例对象的传递是引用传递。</h2><p><strong>值传递是对基本型变量而言的,传递的是该变量的一个副本,改变副本不影响原变量。引用传递一般是对于对象型变量而言的,传递的是该对象地址的一个副本, 并不是原对象本身 。</strong></p>
<p>首先，不要纠结于 Pass By Value 和 Pass By Reference 的字面上的意义，否则很容易陷入所谓的“一切传引用其实本质上是传值”这种并不能解决问题无意义论战中。<br>更何况，要想知道Java到底是传值还是传引用，起码你要先知道传值和传引用的准确含义吧？可是如果你已经知道了这两个名字的准确含义，那么你自己就能判断Java到底是传值还是传引用。</p>
<h2 id="一：搞清楚-基本类型-和-引用类型的不同之处"><a href="#一：搞清楚-基本类型-和-引用类型的不同之处" class="headerlink" title="一：搞清楚 基本类型 和 引用类型的不同之处"></a>一：搞清楚 基本类型 和 引用类型的不同之处</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line">String str = <span class="string">"hello"</span>;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/11/Java%E5%80%BC%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92%E5%9F%BA%E7%A1%80%E5%88%86%E6%9E%90/2020-05-12_112353.png" alt></p>
<p>如图所示，num是基本类型，值就直接保存在变量中。而str是引用类型，变量中保存的只是实际对象的地址。一般称这种变量为”引用”，引用指向实际对象，实际对象中保存着内容。</p>
<p>二：搞清楚赋值运算符（=）的作用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">num &#x3D; 20;</span><br><span class="line">str &#x3D; &quot;java&quot;;</span><br></pre></td></tr></table></figure>

<p>对于基本类型 num ，赋值运算符会直接改变变量的值，原来的值被覆盖掉。<br>对于引用类型 str，赋值运算符会改变引用中所保存的地址，原来的地址被覆盖掉。但是原来的对象不会被改变（重要）。<br>如上图所示，”hello” 字符串对象没有被改变。（没有被任何引用所指向的对象是垃圾，会被垃圾回收器回收）</p>
<p><img src="/2020/05/11/Java%E5%80%BC%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92%E5%9F%BA%E7%A1%80%E5%88%86%E6%9E%90/2020-05-12_112409.png" alt></p>
<h2 id="三：调用方法时发生了什么？参数传递基本上就是赋值操作"><a href="#三：调用方法时发生了什么？参数传递基本上就是赋值操作" class="headerlink" title="三：调用方法时发生了什么？参数传递基本上就是赋值操作"></a>三：调用方法时发生了什么？参数传递基本上就是赋值操作</h2><p>第一个例子：基本类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    value = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">foo(num); <span class="comment">// num 没有被改变</span></span><br></pre></td></tr></table></figure>

<p>第二个例子：没有提供改变自身方法的引用类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(String text)</span> </span>&#123;</span><br><span class="line">    text = <span class="string">"windows"</span>;  <span class="comment">//String没改变是因为赋值新的字符串直接导致新new了一个String</span></span><br><span class="line">&#125;</span><br><span class="line">foo(str); <span class="comment">// str 也没有被改变</span></span><br></pre></td></tr></table></figure>

<p>第三个例子：提供改变自身方法的引用类型</p>
<p>builder的引用对象也是StringBuilder</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="string">"iphone"</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(StringBuilder builder)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    builder.append(<span class="string">"4"</span>); <span class="comment">//没有生成新的stringBuilder对象</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">foo(sb); <span class="comment">// sb 被改变了，变成了"iphone4"。</span></span><br></pre></td></tr></table></figure>

<p>第四个例子：提供了改变自身方法的引用类型，但是不使用，而是使用赋值运算符。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="string">"iphone"</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(StringBuilder builder)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    builder = <span class="keyword">new</span> StringBuilder(<span class="string">"ipad"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(sb); <span class="comment">// sb 没有被改变，还是 "iphone"。</span></span><br></pre></td></tr></table></figure>

<p>重点理解为什么，第三个例子和第四个例子结果不同？</p>
<p>下面是第三个例子的图解：</p>
<p><img src="/2020/05/11/Java%E5%80%BC%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92%E5%9F%BA%E7%A1%80%E5%88%86%E6%9E%90/2020-05-12_112424.png" alt></p>
<p>builder = new StringBuilder(“ipad”); 之后</p>
<p><img src="/2020/05/11/Java%E5%80%BC%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92%E5%9F%BA%E7%A1%80%E5%88%86%E6%9E%90/2020-05-12_112435.png" alt></p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>JAVASE</tag>
      </tags>
  </entry>
  <entry>
    <title>Set</title>
    <url>/2020/05/08/Set/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍Set</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p><strong>SET:注重独一无二的性质，该体系集合知道某物是否已经存在于集合中，不会存储重复的元素。</strong></p>
<p>用于存储无序（存入和取出的顺序不一定相同）元素，值不能重复</p>
<p>Set集合继承了Collection接口。</p>
<h2 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h2><p>哈希表里面存放的是哈希值。HashSet存储元素的顺序并不是按照存入时的顺序（和List 显然不同）是按照哈希值来存，所以取也是按照哈希值来取得。</p>
<p><strong>元素的哈希值是通过元素的hashcode方法来获取的，HashSet首先判断俩个元素的哈希值，如果哈希值一样，那么接着比较equals方法，如果equals结果为true。HashSet就会视作同一个元素。如果equals为false 就不是同一个元素。</strong></p>
<h3 id="哈希值相同equals为flase的元素是怎么存储的呢？"><a href="#哈希值相同equals为flase的元素是怎么存储的呢？" class="headerlink" title="哈希值相同equals为flase的元素是怎么存储的呢？"></a>哈希值相同equals为flase的元素是怎么存储的呢？</h3><p>就是在同样的哈希值下顺延。也就是哈希值一样的存一列。</p>
<p>HashTable</p>
<p><img src="/2020/05/08/Set/hashtable.png" alt></p>
<p>图1：hashCode值不相同的情况</p>
<p>图2：hashCode值相同，但equals不相同的情况。</p>
<h3 id="HashSet到底是如何判断俩个元素重复"><a href="#HashSet到底是如何判断俩个元素重复" class="headerlink" title="HashSet到底是如何判断俩个元素重复"></a>HashSet到底是如何判断俩个元素重复</h3><p>通过hashCode方法和equals方法来保证元素的唯一性，add()返回的是boolean类型</p>
<p>判断两个元素是否相同，先要判断元素的hashCode值是否一致，只有在该值一致的情况下，才会判断equals方法，如果存储在HashSet中的两个对象hashCode方法的值相同equals方法返回的结果是true，那么HashSet认为这两个元素是相同元素，只存储一个（重复元素无法存入）。</p>
<p>注意：HashSet集合在判断元素是否相同先判断hashCode方法，如果相同才会判断equals。如果不相同，是不会调用equals方法的。</p>
<h3 id="HashSet-和ArrayList集合都有判断元素是否相同的方法"><a href="#HashSet-和ArrayList集合都有判断元素是否相同的方法" class="headerlink" title="HashSet 和ArrayList集合都有判断元素是否相同的方法"></a>HashSet 和ArrayList集合都有判断元素是否相同的方法</h3><p>boolean contains(Object o)</p>
<p>HashSet使用hashCode和equals方法，ArrayList使用了equals方法</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Set hs=<span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        hs.add(<span class="string">"jack"</span>);</span><br><span class="line">        hs.add(<span class="string">"rose"</span>);</span><br><span class="line">        hs.add(<span class="string">"2020"</span>);</span><br><span class="line">        hs.add(<span class="string">"trip"</span>);</span><br><span class="line">        System.out.println(hs.size());</span><br><span class="line">        <span class="keyword">boolean</span> add=hs.add(<span class="string">"jack"</span>); <span class="comment">/* 如果set尚未包含指定元素，那么 返回true 此时返回false; */</span></span><br><span class="line">        System.out.println(add);</span><br><span class="line">        Iterator it=hs.iterator();</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext())</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(it.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This program demonstrates</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Alita Alice</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: Created in 21:13 2020/5/8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HashSet hs = <span class="keyword">new</span> HashSet();</span><br><span class="line">        hs.add(<span class="keyword">new</span> Person(<span class="string">"jack"</span>, <span class="number">20</span>));</span><br><span class="line">        hs.add(<span class="keyword">new</span> Person(<span class="string">"rose"</span>,<span class="number">20</span>));</span><br><span class="line">        hs.add(<span class="keyword">new</span> Person(<span class="string">"rose"</span>,<span class="number">20</span>));</span><br><span class="line">        Iterator it= hs.iterator();</span><br><span class="line">        <span class="keyword">while</span>(it.hasNext())</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(it.next());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    Person()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name,<span class="keyword">int</span> age)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age=age;</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Person)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Person person = (Person) o;</span><br><span class="line">        <span class="keyword">return</span> getAge() == person.getAge() &amp;&amp;</span><br><span class="line">                getName().equals(person.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(getName(), getAge());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>其中在HashSet中存储自定义的对象，并尝试添加重复元素，需要override hashCode()和equls()方法。</strong></p>
<h2 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h2><p>现在有一批数据，要求不能重复存储元素，而且要排序。</p>
<p>ArrayList ，LinkList不能去除重复数据，HashSet可以去除重复，但是无序。</p>
<p>示例：使用TreeSet集合存储字符串元素，并且遍历。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo5</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TreeSet treeSet=<span class="keyword">new</span> TreeSet();</span><br><span class="line">        treeSet.add(<span class="string">"aaa"</span>);</span><br><span class="line">        treeSet.add(<span class="string">"bbb"</span>);</span><br><span class="line">        treeSet.add(<span class="string">"ccc"</span>);</span><br><span class="line">        treeSet.add(<span class="string">"ddd"</span>);</span><br><span class="line">        System.out.println(treeSet);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 输出</span></span><br><span class="line"><span class="comment">[aaa, bbb, ccc, ddd]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="俩种比较器接口"><a href="#俩种比较器接口" class="headerlink" title="俩种比较器接口"></a>俩种比较器接口</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Comparable </span><br><span class="line">         compareTo(Object o)  元素自身具备比较性</span><br><span class="line">Comparator</span><br><span class="line">         compare(Object o1,Object o2) 给容器传入比较器</span><br></pre></td></tr></table></figure>

<h3 id="TreeSet集合排序的俩种方式"><a href="#TreeSet集合排序的俩种方式" class="headerlink" title="TreeSet集合排序的俩种方式"></a>TreeSet集合排序的俩种方式</h3><ul>
<li><p>让元素自身具备比较性</p>
<p>元素需要实现Comparable接口，覆盖compareTo(Object o) 方法</p>
<p>这种方式也被称为元素的自然排序，也可以称为默认排序</p>
<p>年龄按照首要条件，年龄相同再比姓名</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sun.reflect.generics.tree.Tree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"><span class="keyword">import</span> java.util.TreeSet;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This program demonstrates</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Alita Alice</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: Created in 10:23 2020/5/9</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TreeSet ts=<span class="keyword">new</span> TreeSet();</span><br><span class="line">        ts.add(<span class="keyword">new</span> Person(<span class="string">"aa"</span>, <span class="number">20</span>, <span class="string">"男"</span>));</span><br><span class="line">        ts.add(<span class="keyword">new</span> Person(<span class="string">"bb"</span>, <span class="number">18</span>, <span class="string">"女"</span>));</span><br><span class="line">        ts.add(<span class="keyword">new</span> Person(<span class="string">"cc"</span>, <span class="number">17</span>, <span class="string">"男"</span>));</span><br><span class="line">        ts.add(<span class="keyword">new</span> Person(<span class="string">"dd"</span>, <span class="number">17</span>, <span class="string">"女"</span>));</span><br><span class="line">        ts.add(<span class="keyword">new</span> Person(<span class="string">"dd"</span>, <span class="number">15</span>, <span class="string">"女"</span>));</span><br><span class="line">        ts.add(<span class="keyword">new</span> Person(<span class="string">"dd"</span>, <span class="number">15</span>, <span class="string">"女"</span>));</span><br><span class="line">        System.out.println(ts);</span><br><span class="line">        System.out.println(ts.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Comparable</span></span></span><br><span class="line"><span class="class"> </span>&#123;</span><br><span class="line">     <span class="keyword">private</span> String name;</span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">     <span class="keyword">private</span> String gender;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age, String gender)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">this</span>.name = name;</span><br><span class="line">         <span class="keyword">this</span>.age = age;</span><br><span class="line">         <span class="keyword">this</span>.gender = gender;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> name;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">this</span>.name = name;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> age;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">this</span>.age = age;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> String <span class="title">getGender</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> gender;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setGender</span><span class="params">(String gender)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">this</span>.gender = gender;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="string">"Person&#123;"</span> +</span><br><span class="line">                 <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                 <span class="string">", age="</span> + age +</span><br><span class="line">                 <span class="string">", gender='"</span> + gender + <span class="string">'\''</span> +</span><br><span class="line">                 <span class="string">'&#125;'</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">         <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Person)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">         Person person = (Person) o;</span><br><span class="line">         <span class="keyword">return</span> getAge() == person.getAge() &amp;&amp;</span><br><span class="line">                 getName().equals(person.getName()) &amp;&amp;</span><br><span class="line">                 getGender().equals(person.getGender());</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> Objects.hash(getName(), getAge(), getGender());</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">         Person p = (Person) o;</span><br><span class="line">         System.out.println(<span class="keyword">this</span> + <span class="string">"compareTo:"</span> + p);</span><br><span class="line">         <span class="keyword">if</span> (<span class="keyword">this</span>.age &gt; p.age) &#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> (<span class="keyword">this</span>.age &lt; p.age) &#123;</span><br><span class="line">             <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">this</span>.name.compareTo(p.name);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">/* out</span></span><br><span class="line"><span class="comment">Person&#123;name='aa', age=20, gender='男'&#125;compareTo:Person&#123;name='aa', age=20, gender='男'&#125;</span></span><br><span class="line"><span class="comment">Person&#123;name='bb', age=18, gender='女'&#125;compareTo:Person&#123;name='aa', age=20, gender='男'&#125;</span></span><br><span class="line"><span class="comment">Person&#123;name='cc', age=17, gender='男'&#125;compareTo:Person&#123;name='aa', age=20, gender='男'&#125;</span></span><br><span class="line"><span class="comment">Person&#123;name='cc', age=17, gender='男'&#125;compareTo:Person&#123;name='bb', age=18, gender='女'&#125;</span></span><br><span class="line"><span class="comment">Person&#123;name='dd', age=17, gender='女'&#125;compareTo:Person&#123;name='bb', age=18, gender='女'&#125;</span></span><br><span class="line"><span class="comment">Person&#123;name='dd', age=17, gender='女'&#125;compareTo:Person&#123;name='cc', age=17, gender='男'&#125;</span></span><br><span class="line"><span class="comment">Person&#123;name='dd', age=15, gender='女'&#125;compareTo:Person&#123;name='bb', age=18, gender='女'&#125;</span></span><br><span class="line"><span class="comment">Person&#123;name='dd', age=15, gender='女'&#125;compareTo:Person&#123;name='cc', age=17, gender='男'&#125;</span></span><br><span class="line"><span class="comment">Person&#123;name='dd', age=15, gender='女'&#125;compareTo:Person&#123;name='bb', age=18, gender='女'&#125;</span></span><br><span class="line"><span class="comment">Person&#123;name='dd', age=15, gender='女'&#125;compareTo:Person&#123;name='cc', age=17, gender='男'&#125;</span></span><br><span class="line"><span class="comment">Person&#123;name='dd', age=15, gender='女'&#125;compareTo:Person&#123;name='dd', age=15, gender='女'&#125;</span></span><br><span class="line"><span class="comment">[Person&#123;name='dd', age=15, gender='女'&#125;, Person&#123;name='cc', age=17, gender='男'&#125;, Person&#123;name='dd', age=17, gender='女'&#125;, Person&#123;name='bb', age=18, gender='女'&#125;, Person&#123;name='aa', age=20, gender='男'&#125;]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="二-让容器自身具备比较性，自定义比较器"><a href="#二-让容器自身具备比较性，自定义比较器" class="headerlink" title="二 让容器自身具备比较性，自定义比较器"></a>二 让容器自身具备比较性，自定义比较器</h3><p>需求：当元素自身不具备比较性，或者元素自身具备的比较性不是所需。</p>
<p>那么这时只能让容器自身具备</p>
<p>定义一个类实现Comparetor接口，覆盖compare方法</p>
<p>并将该接口的子类对象作为参数传递给TreeSet集合的构造函数。</p>
<p>当Comparable 比较方式及Comparator比较方式同时存在， 以Com[arator比较方式为主。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"><span class="keyword">import</span> java.util.TreeSet;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This program demonstrates</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Alita Alice</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: Created in 10:54 2020/5/9</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo6</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TreeSet ts=<span class="keyword">new</span> TreeSet(<span class="keyword">new</span> MyComparator());</span><br><span class="line">        ts.add(<span class="keyword">new</span> Book(<span class="string">"think in java"</span>, <span class="number">100</span>));</span><br><span class="line">        ts.add(<span class="keyword">new</span> Book(<span class="string">"java 核心技术"</span>, <span class="number">75</span>));</span><br><span class="line">        ts.add(<span class="keyword">new</span> Book(<span class="string">"现代操作系统"</span>, <span class="number">50</span>));</span><br><span class="line">        ts.add(<span class="keyword">new</span> Book(<span class="string">"java就业教程"</span>, <span class="number">35</span>));</span><br><span class="line">        ts.add(<span class="keyword">new</span> Book(<span class="string">"think in java"</span>, <span class="number">100</span>));</span><br><span class="line">        ts.add(<span class="keyword">new</span> Book(<span class="string">"ccc in java"</span>, <span class="number">100</span>));</span><br><span class="line"></span><br><span class="line">        System.out.println(ts);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Object o1, Object o2)</span> </span>&#123;</span><br><span class="line">                    Book b1=(Book) o1;</span><br><span class="line">                    Book b2=(Book) o2;</span><br><span class="line">        System.out.println(b1+<span class="string">"comparator"</span>+b2);</span><br><span class="line">        <span class="keyword">if</span>(b1.getPrice()&gt;b2.getPrice())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(b1.getPrice()&lt;b2.getPrice())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b1.getName().compareTo(b2.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> price;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Book</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Book</span><span class="params">(String name, <span class="keyword">double</span> price)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPrice</span><span class="params">(<span class="keyword">double</span> price)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Book)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Book book = (Book) o;</span><br><span class="line">        <span class="keyword">return</span> Double.compare(book.getPrice(), getPrice()) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                getName().equals(book.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(getName(), getPrice());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Book&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", price="</span> + price +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* out</span></span><br><span class="line"><span class="comment">Book&#123;name='think in java', price=100.0&#125;comparatorBook&#123;name='think in java', price=100.0&#125;</span></span><br><span class="line"><span class="comment">Book&#123;name='java 核心技术', price=75.0&#125;comparatorBook&#123;name='think in java', price=100.0&#125;</span></span><br><span class="line"><span class="comment">Book&#123;name='现代操作系统', price=50.0&#125;comparatorBook&#123;name='think in java', price=100.0&#125;</span></span><br><span class="line"><span class="comment">Book&#123;name='现代操作系统', price=50.0&#125;comparatorBook&#123;name='java 核心技术', price=75.0&#125;</span></span><br><span class="line"><span class="comment">Book&#123;name='java就业教程', price=35.0&#125;comparatorBook&#123;name='java 核心技术', price=75.0&#125;</span></span><br><span class="line"><span class="comment">Book&#123;name='java就业教程', price=35.0&#125;comparatorBook&#123;name='现代操作系统', price=50.0&#125;</span></span><br><span class="line"><span class="comment">Book&#123;name='think in java', price=100.0&#125;comparatorBook&#123;name='java 核心技术', price=75.0&#125;</span></span><br><span class="line"><span class="comment">Book&#123;name='think in java', price=100.0&#125;comparatorBook&#123;name='think in java', price=100.0&#125;</span></span><br><span class="line"><span class="comment">Book&#123;name='ccc in java', price=100.0&#125;comparatorBook&#123;name='java 核心技术', price=75.0&#125;</span></span><br><span class="line"><span class="comment">Book&#123;name='ccc in java', price=100.0&#125;comparatorBook&#123;name='think in java', price=100.0&#125;</span></span><br><span class="line"><span class="comment">[Book&#123;name='java就业教程', price=35.0&#125;, Book&#123;name='现代操作系统', price=50.0&#125;, Book&#123;name='java 核心技术', price=75.0&#125;, Book&#123;name='ccc in java', price=100.0&#125;, Book&#123;name='think in java', price=100.0&#125;]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="4-LinkedHashSet"><a href="#4-LinkedHashSet" class="headerlink" title="4.LinkedHashSet"></a>4.LinkedHashSet</h3><p>会保存插入的顺序</p>
<p>看到array，就要想到角标</p>
<p>看到link ，就要想到first,last</p>
<p>看到hash,就要想到hashCode，equals</p>
<p>看到tree，就要想到俩个接口。Comparable,Comparator </p>
</li>
</ul>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>JAVASE</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring起步</title>
    <url>/2020/05/10/Spring%E8%B5%B7%E6%AD%A5/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍什么是Spring</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h2 id="什么是Spring"><a href="#什么是Spring" class="headerlink" title="什么是Spring"></a>什么是Spring</h2><ul>
<li><p>Spring 的核心是提供一个容器(container) </p>
<p>通常称为Spring 应用上下文（Spring application context) 应用前后关系，它们会创建和管理应用组件。</p>
<p>这些组件也被称为是bean ，会在Spring应用上下文中装配在一起，从而形成一个完整的应用程序。</p>
<p>这就像砖块，砂浆，木材 ，管道等组合在一起</p>
</li>
</ul>
<ul>
<li><p>将bean装配在一起是通过一种基于依赖注入（dependency injection DI)</p>
<p>举例来说：假设在众多的组件中，有俩个是我们需要处理的：库存服务，和商品服务。</p>
<p>商品服务需要依赖于库存服务。</p>
<p>如图所示阐述了bean和Spring 应用上下文之间的关系。</p>
<p><img src="/2020/05/10/Spring%E8%B5%B7%E6%AD%A5/TIM%E5%9B%BE%E7%89%8720200510124205.png" alt></p>
<p>依赖注入到需要它们的bean中，另外使用依赖注入的应用依赖于单独的实体（容器）来创建和维护所有的组件。</p>
<p> Spring Initializr 是一个基于浏览器的web应用，能够生成Spring 项目结构的骨架。</p>
</li>
</ul>
<h3 id="pom文件"><a href="#pom文件" class="headerlink" title="pom文件"></a>pom文件</h3><h2 id="Springboot的引导类"><a href="#Springboot的引导类" class="headerlink" title="Springboot的引导类"></a>Springboot的引导类</h2><p>@SpringBootApplication  ：是一个组合注解，包括：</p>
<ul>
<li>@SpringBootConfiguration</li>
</ul>
<p>将该类声明为配置类</p>
<ul>
<li>@EnableAutoConfiguration</li>
</ul>
<p>启动Spring BOOT 的自动配置 </p>
<ul>
<li>@ComponentScan </li>
</ul>
<p>启动组件扫描</p>
<p>@Component @Controller @Service 注解声明其他类，Spring会自动发现它们并将它们注册为Spring应用上下文的组件。</p>
]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>char可以存储汉字吗？</title>
    <url>/2020/05/06/char%E5%8F%AF%E4%BB%A5%E5%AD%98%E5%82%A8%E6%B1%89%E5%AD%97%E5%90%97%EF%BC%9F/</url>
    <content><![CDATA[<h2 id="char存储汉字"><a href="#char存储汉字" class="headerlink" title="char存储汉字"></a>char存储汉字</h2><ul>
<li><p>char是按照字符存储的，不管是英文还是中文，JAVA中固定占用2个字符，用来存储Unicode字符，范围在0-65535.</p>
</li>
<li><p>Unicode编码字符集中包含了汉字，所以char类型变量当然可以存储汉字拉。</p>
<a id="more"></a>

<h2 id="char和String的区别"><a href="#char和String的区别" class="headerlink" title="char和String的区别"></a>char和String的区别</h2><ul>
<li>char表示字符，定义时用单引号，只能存储一个字符。如char c=‘x’ ;</li>
<li>String表示的是字符串，可以存储一个或多个字符 如String name=”tom”;</li>
<li>char是基本数据类型，但是String是一个类，具有面向对象的特征,可以调用方法</li>
</ul>
</li>
</ul>
<p>如name.length();</p>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>JAVASE</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql插入数据</title>
    <url>/2020/05/07/mysql%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍如何利用SQL的INSERT语句将数据插入到表中</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h2 id="插入到完整的行"><a href="#插入到完整的行" class="headerlink" title="插入到完整的行"></a>插入到完整的行</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">INSERT INTO Customers</span><br><span class="line">VALUES(<span class="literal">NULL</span>,</span><br><span class="line">       'PEP E.LAPEW',</span><br><span class="line">       '100 MAIN STREET',</span><br><span class="line">        'Los Angeles',</span><br><span class="line">         'CA',</span><br><span class="line">        '90046',</span><br><span class="line">         'USA',</span><br><span class="line">          <span class="literal">NULL</span>,</span><br><span class="line">          <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>

<p>编写INSERT语句的更加安全（不过更加繁琐）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INSERT INTO customers(cust_name,cust_address,cust_city,cust_state,cust_zip,cust_country,cust_contact,cust_email)</span><br><span class="line">VALUSES(&#39;PEP E.LAPEW&#39;,</span><br><span class="line">       &#39;100 MAIN STREET&#39;,</span><br><span class="line">        &#39;Los Angeles&#39;,</span><br><span class="line">         &#39;CA&#39;,</span><br><span class="line">        &#39;90046&#39;,</span><br><span class="line">         &#39;USA&#39;,</span><br><span class="line">          NULL,</span><br><span class="line">          NULL&#39;);</span><br></pre></td></tr></table></figure>

<h3 id="省略列"><a href="#省略列" class="headerlink" title="省略列"></a>省略列</h3><ul>
<li>该列定义为允许null值</li>
<li>在表定义中给出默认值</li>
</ul>
<h3 id="提高整体性能"><a href="#提高整体性能" class="headerlink" title="提高整体性能"></a>提高整体性能</h3><p>如果数据检索是最重要的，那你可以通过在INSERT INTO 之间添加关键字</p>
<p>LOW_PRIORITY 指示Mysql降低INSERT语句的优先级</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INSERT LOW_PRIORITY INTO</span><br></pre></td></tr></table></figure>

<h2 id="插入多个行"><a href="#插入多个行" class="headerlink" title="插入多个行"></a>插入多个行</h2><figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="function">INSERT INTO <span class="title">customers</span><span class="params">(cust_name,cust_address,cust_city,cust_state,cust_zip,cust_country,cust_contact,cust_email)</span></span></span><br><span class="line">VALUSES('PEP E.LAPEW',</span><br><span class="line">       '100 MAIN STREET',</span><br><span class="line">        'Los Angeles',</span><br><span class="line">         'CA',</span><br><span class="line">        '90046',</span><br><span class="line">         'USA',</span><br><span class="line">          <span class="literal">NULL</span>,</span><br><span class="line">          NULL'),</span><br><span class="line">       ('PEP E.LAPEW',</span><br><span class="line">       '100 MAIN STREET',</span><br><span class="line">        'Los Angeles',</span><br><span class="line">         'CA',</span><br><span class="line">        '90046',</span><br><span class="line">         'USA',</span><br><span class="line">          <span class="literal">NULL</span>,</span><br><span class="line">          NULL');</span><br></pre></td></tr></table></figure>

<p>其中单条INSERT语句有多组值，每组值用一对圆括号括起来，用逗号分隔。</p>
<h3 id="插入检索出的数据"><a href="#插入检索出的数据" class="headerlink" title="插入检索出的数据"></a>插入检索出的数据</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="function">INSERT INTO <span class="title">customers</span><span class="params">(cust_id,cust_name,cust_address,cust_city,cust_state,cust_zip,cust_country,cust_contact,cust_email)</span></span></span><br><span class="line">SELECT cust_id,cust_name,cust_address,cust_city,cust_state,cust_zip,cust_country,cust_contact,cust_email FROM custnew;</span><br></pre></td></tr></table></figure>

<p>这个例子中INSERT SELECT 从custnew中将所有数据导入到customer中。</p>
<p><strong>其实MYSQL不关心SELECT返回的列名，它使用的是列的位置，因此SELECT中的第一列用来填充表列中指定的第一列</strong>。</p>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql必知必会</title>
    <url>/2020/05/03/mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/</url>
    <content><![CDATA[<p> 登录mysql -h localhost -u root -p<br> Show databases;<br> Use databasename;<br>Show tables;  //显示行</p>
<a id="more"></a>
<p> Show columns from xxx;   //显示列<br>SELECT DISTINCT  published FROM t_blog ;  DISTINCT此关键字指示只返回不同的值。<br> SELECT id FROM t_blog LIMIT 5;<br> SELECT id FROM t_blog LIMIT 3,3; //从第三行开始的后三行<br> SELECT t_blog.id FROM blog.t_blog;   完全限定的列名和表名 和之前的用法一样。<br> SELECT id,type_id,user_id FROM t_blog ORDER BY type_id,id;  先对type_id排序 再对id进行排序。<br> DESC 降序 ASC 升序  没多大用处<br> SELECT id FROM t_blog ORDER BY type_id LIMIT 1; 此种方式找到了数值最大的一行。<br> 在使用where 过滤时 ，order by 排序要在where的后面<br>  SELECT id FROM t_blog  where id &lt;&gt;10;   &lt;&gt; 不匹配检查<br> 范围值检查<br>  SELECT ID FROM T_BLOG WHERE ID BETWEEN 10 AND 20 :<br> Select id from t_blog where id is null;  空值检查<br> Select id,user_id from t_blog where id &lt;=10 and user_id &lt;=1;<br> Select prod_name,prod_price from products where vend_id=1002 or vend_id =1003 and<br>  Prod_price&gt;=10; SQL处理OR操作符和AND操作符时，优先处理AND操作符。<br> 故先处理 vend_id =1003 and prod_price&gt;=10  或者  vend_id=1002  ；<br>解决方法是<br>Select prod_name,prod_price from products where (vend_id =1002 or vend_id =1003) and prod_price &gt;=10    用( )来明确分组操作符。DBMS 首先过滤圆括号内的OR条件。<br>NOT 在MYSQL中的NOT中 MYSQL支持使用NOT 对IN,BETWEEN 和EXISTS子句取反。这与多数其他DBMS允许使用NOT对各种条件取反有很大区别。<br>######<br>通配符<br>用来匹配值的一部分的特殊字符<br>LIKE 指示MYSQL 后跟的搜索模式利用通配符匹配而不是直接相等匹配比较<br>SELECT prod_name FROM products WHERE prod_name REGEXP ‘[123] Ton’<br>ORDER BY prod_name;<br>正则表达式 [123]Ton 其中[123]定义一组字符<br>它的意思是匹配1或2或3  因此 1ton 和2ton 都匹配且返回了<br>[] 其实是另一种形式的OR语句<br>[1|2|3]Ton 的缩写 为 [123]Ton<br>1|2|3 Ton 的意思是检索出1或2或3 ton<br>[^123] 匹配除这些字符除外的任何东西<br> ^ 是REGEXP的否定符号<br>在匹配范围中<br>0到9  将由[0123456789] 等同于 [0-9]<br>.表示匹配一个字符<br>输入 SELECT vend_name FROM vendors WHERE vend_name REGEXP ‘.’ ORDER BY vend_name<br>.匹配任意字符  这时每一行都被检索出来 为了匹配特殊字符 必须用\ 作为前导<br>如<br>SELECT vend_name FROM vendors WHERE vend_name REGEXP ‘\.’ ORDER BY vend_name<br>这才是期望的输出 \.匹配. 这种处理就是所谓的转义。<br>？ 字符 ？匹配它前面的任何字符的0次或者1次出现。<br> 如 SELECT prod_name FROM products WHERE prod_name REGEXP ‘\([0-9] sticks?\)’<br> ORDER BY prod_name ;<br>Sticks 匹配 stick 和sticks s后的?使s可选<br>另外例如<br>SELECT prod_name FROM products WHERE prod_name REGEXP ‘[[:digit:]]{4}<br>ORDER BY prod_name；<br>[:digit:]匹配任意数字<br>因而它作为数字的一个集合<br>{4} 确切的要求它前面的字符 出现4次<br>匹配特定位置的文本，需要使用表9-4列出的定位符<br>^ 文本的开始<br>$ 文本的结尾<br>[[:&lt;:]] 词的开始<br>[[:&gt;;]] 词的结尾<br>‘^[0-9\.]’ 找出一个数 包括以小数点开始的数开始的所有产品。<br>SELECT prod_name FROM products WHERE prod_name REGEXP ‘^[0-9\.]’<br>ORDER BY prod_name;<br>在第10章 中 创建计算字段<br>MySQL 使用Concat() 函数来实现<br>SELECT Concat(vend_name,’（‘，vend_country,’）’)<br>FROM vendors ORDER BY vend_name;<br>拼接  将值联结到一起构成单个值<br>比如以上的输出为<br>ACME (USA)<br>删除数据右侧多余的空格来整理数据<br>MySQL 的RTrim()可以去掉值右边的所有的空格<br>SELECT Concat(RTrim(vend_name),’(‘,RTrim(vend_country),’)’)<br>FROM vendors<br>ORDER BY vend_name;<br>LTrim() 去掉串左边的空格<br>Trim()去掉左右俩边的空格<br>SELECT Concat (RTrim(vend_name),’(‘,RTrim(vend_country),’)’)AS vend_title FROM vendors ORDER BY vend_name;<br>一个未命名的列不能用于客户机的应用中，因为客户机没有办法去引用它。<br>所以才出现了别名。AS 关键字来赋予别名 任何客户机应用都可以按名来引用这个列，就像它是一个实际的表列一样。</p>
<p>执行算数运算<br>SELECT pro_id,quantity,item_price FROM oderitems WHERE order order_num =20005;<br>在算数运算中 检索200005中的所有物品<br>如果要计算汇总物品的价格<br>SELECT prod_id ,quantity,item_price, quantity*item_price  AS expanded_price FROM oderitems WHERE order_num =20005;<br>此时客户机可以使用这个新计算的列，就像其他列一样。<br>MYSQL 支持基本算术运算符</p>
<ul>
<li><ul>
<li>/ 圆括号可以用来区分优先顺序<br>第十一章 使用数据来处理函数<br>SELECT vend_name,Upper(vend_name) AS  vend_name_upcase FROM vendors ORDER BY vend_name;<br>Upper()将文本转换为大写<br>常用的文本处理函数：<br>Left() 返回串左边的字符<br>Length() 返回串的长度<br>Locate()返回串的一个子串<br>Lower()将串转换为小写<br>LTrim() 去掉左边的空格<br>Right()返回串右边的字符<br>RTrim() 去掉串右边的空格<br>Soundex()返回串的Soundex值<br>SubString() 返回子串的字符<br>Upper() 大写<br>Soundex（） 将任何文本串转换为描述其语音表示的字母数字模式的算法<br>如<br>SELECT cust_name ,cust_contact FROM customers WHERE cust_contact =’Y.Lie’;<br>其联系名是为Y.Lee 此时没办法搜索到<br>但是通过<br>SELECT cust_name,cust_contact FROM customers WHERE Soundex(cust_contact)=Soundex(‘Y.lie);<br>此时可以搜索到Y.Lee<br>日期和时间的处理函数<br>Date() 返回日期部分的日期部分<br>Year() 返回日期部分的年份部分<br>Day()<br>Month()</li>
</ul>
</li>
</ul>
<p>如：<br>SELECT cust_id,oder_num FROM oders WHERE Date(order_date)=’2005-09-01’;<br>SELECT cust_id,order_num FROM orders WHERE Date(order_date) BETWEEN ‘2005-09-01’AND’2005-03-30’;<br>数值处理函数<br>Abs() 返回数的绝对值</p>
<p>Cos() 角度的余弦<br>Exp() 返回一个数的指数值<br>Mod() 操作数的余数<br>……<br>第12章 汇总数据<br>12.1 聚集函数  运行在行组上，计算和返回单个值得函数<br>AVG() 返回某列的平均值<br>COUNT()  返回某列的行数<br>MAX() 返回某列的最大值<br>MIN() 返回某列的最小值<br>SUM() 返回某列值之和<br>SELECT AVG(prod_price) AS avg_price FROM products;<br>AVG() 也可以用来确定列或行当平均值<br>SELECT AVG(prod_price) AS avg_price FROM products WHERE vend_id =1003;<br>COUNT () 函数<br>COUNT(<em>)对表中的行的数目进行技术<br>COUNT(column) 对特定列中具有值的行进行计数<br>例如SELECT COUNT(</em>) AS num_cust FROM customers;<br>利用COUNT(<em>)对所有行计数<br>SELECT COUNT(cust_email) AS num_cust FROM customers;<br>对于cust_email中所有有值的行进行计数<br>MAX() 指定列中的最大值 MAX()要求指定列名。<br>MIN()<br>SUM() 也可以用来合计计算值 用来得出总的订单金额<br>SELECT SUM(item_price  *quantity) AS total_price FROM oderitems WHERE order_num=20005;<br>SUM(item_price *quantity) 返回订单中所有物品价钱之和<br>第13章 分组数据<br>SELECT vend_id ,COUNT(</em>) AS num_prods FROM products GROUP BY vend_id;<br>Vend_id num_prods<br>1001        3<br>1002        2<br>1003        7<br>1005        2<br>上述语句将vend_id进行分组，GROUP BY 对于分组的整个结果集进行聚集<br>使用ROLLUP 使用WITH ROLLUP 关键字，将得到每个分组以及分组汇总级别的值<br>2如何过滤分组?<br>HAVING<br>如： SELECT cust_id ,COUNT(<em>)AS orders FROM orders GROUP BY cust_id<br>HAVING COUNT(</em>) &gt;=2<br>它过滤COUNT(<em>)&gt;=2 的那些分组<br>输入： SELECT vend_id,COUNT(</em>) AS num_prods FROM products WHERE prod_price &gt;=10<br>GROUP BY vend_id HAVING COUNT(<em>)&gt;=2;<br>13.4 分组和排序<br>GROUP BY 和ORDER BY<br>GROUP BY  是在ORDER BY 之前，在where 之后<br>第14章 子查询<br>子查询：嵌套在其他查询中的查询<br>1 检索包含物品TNT2 的所有订单的编号<br> SELECT order_num FROM orderitems WHERE prod_id =’TNT2’；<br>2 检索具有前一步骤列出的订单编号的所有客户的ID<br> SELECT cust_id FROM orders WHERE order_num IN (20005,20007);<br>3 现在把第一个查询变为子查询 组合成俩个查询：<br> SELECT cust_id FROM oders WHERE order_num IN (SELECT order_num FROM orderitems WHERE prod_id =’TNT2’);<br>在SELECT 语句中，子查询总是从内向外查询处理。<br>检索这些客户的ID的客户信息，检索俩列的SQL语句为：<br>SELECT cust_name, cust_contact FROM customers WHERE cust_id IN (10001,10004);<br>则可以转换为：<br>SELECT cust_name ,cust_contact FROM customers WHERE cust_id IN (SELECT cust_id FROM orders WHERE order_num IN (SELECT order_num FROM orderitems WHERE prod_Id =’TNT2’))；<br>计算结果子查询：<br>SELECT cust_name,cust_state,(SELECT COUNT(</em>) FROM oders WHERE orders.cust_id=customers.cust_id)AS orders FROM customers ORDER BY cust_name;<br>第15 章  联结表  join 表<br>外键位某个表中的一列 它包含另一个表的主键值定义了俩个表之间的关系。<br>SELECT vent_name,prod_name,prod_price<br>FROM vendors ,products<br>WHERE vendors.vend_id=products.vend_id;<br>ORDER BY vend_name,prod_name ;<br>此种方法通过WHERE子句来限定了列名 ，如果要给出 vend_id 那么mysql_id 并不知道是哪个<br>存在一种状况是<br>笛卡尔积：<br>在不指定where子句时<br>：<br>SELECT vend_name ,prod_name,prod_price<br>FROM vendors,products ORDER BY vend_name,prod_name;<br>15.2.2 内部联结<br>目前为止所使用的联结称为 等值联结  它基于俩个表之间的相等测试 这种联结也叫内部联结。<br>SELECT vend_name , prod_name , prod_price FROM vendors INNER JOIN products ON vendors.vend_id =products.vend_id ;<br>此时使用的是INNER JOIN  联结条件用的是ON<br>联结多个表：<br>SELECT prod_name,vend_name,prod_price,quantity FROM orderitems,products,vendors WHERE products.vend_id =vendors.vend_id AND orderitems.prod_id =products.prod_id AND order_num =20005;<br>第16章 创建高级联结<br>使用表别名<br>SELECT Concat(RTrim(vend_name)，‘（’，RTrim（vend_country）,’）’) AS vend_title FROM vendors ORDER BY vend_name;<br>内部联结：<br>它基于俩个表之间的相等测试<br>SELECT vend_name .prod_name,prod_price FROM vendors INNER JOIN products ON vendors.vend_id =produces.vend_id;<br>自联结： 引用别名，自己联结自己<br>SELECT p1.prod_id,p1.prod_name FROM products AS p1,products AS p2<br>WHERE p1.vend_id =p2.vend_id AND p2.prod_id =’DTNTR’;<br>此查询种需要的俩个表实际上是相同的表。<br>因此products 表在from 子句中出现了俩次。虽然这是合法的，但是对products 的引用具有二义性。因此使用了别名。（用自联结而不用子查询。有时候处理联结要比处理查询要快的多）<br>自然联结：<br>其中你只能选择那些唯一的列。<br>通过对表使用通配符（SELECT <em>）对所有其他表的列使用明确的子集来完成的。<br>SELECT c.</em>,o.ordr_num,o.order_date,oi.prod_id,oi.quantity,OI.item_price FROM customers AS c,orders AS o,orderitems AS oi WHERE c.cust_id =o.cust_id AND oi.order_num =o.order_num<br>AND prod_id =’FB’;<br>通配符只对第一个表使用，所有其他列明确列出，所以没有重复的列被检索出来。<br>外部联结：<br>许多联结将一个表中的行与另外一个表中的行相关联，但有时候会需要包含没有关联行的那些行，例如  可能需要使用联结来完成以下的工作：<br>1对每个客户下了多少订单进行计数，包括那些至今未下订单的客户。<br>2列出所有产品以及订购数量，包括没有人订购的产品<br>3计算平均销售规模，包括那些至今未下订单的客户<br>联结包含了那些在相关表中没有关联行的行，这种叫做外部联结<br>内部联结检索所有客户及其订单：<br>SELECT customers.cust_id,order.orders.order_num FROM customers INNER JOIN orders ON<br>Customers.cust_id =orders.cust_id;<br>外部联结：<br>SELECT customers.cust_id ,orders.order_num FROM customers LEFT OUTER JOIN oders<br>ON customers.cust_id =orders.cust_id;<br>输出为：<br> cust_id   order_num<br>  10001      20005<br>  10001      20009<br>  10002       null<br> 10003       null<br>此时必须要用RIGHT 或LEFT 关键字指定包括其所有行的表<br>其实就是左外部联结和右外部联结<br>16.3 使用带聚集函数的联结<br>使用了COUNT（）函数的联结<br>SELECT customers.cust_name, customers.cust_id,COUNT(orders.order_num) AS num_ord FROM customers INNER JOIN orders ON customers.cust_id =orders.cust_id GROUP BY customers.cust_id;<br>SELECT 语句使用INNER JOIN 将customers和orders 表互相关联。 GROUP BY 子句按客户分组数据。<br>聚集函数也可以方便地与其他联结一起使用，<br>如 SELECT customers,cust_name,cusomers,cust_id,COUNT(orders,order_num)AS num_ord FROM customers LEFT OUTER JOIN orders ON customers.cust_id =orders.cust_id  GROUP BY customers.cust_id;<br>17 章 组合查询<br>利用UNION 操作符将多条SELECT 语句组合成一个结果集<br>执行多个查询，多个SELECT 语句 并将结果作为单个查询结果集返回。<br>这种称为并（union）或复合查询<br>使用UNION<br>输入<br>SELECT vend_id ,prod_id ,prod_price FROM products WHERE prod_price &lt;=5<br>UNION<br>SELECT vend_id,prod_id,prod_price FROM products WHERE vend_id IN(1001,1002);<br>也可以使用多个where<br>SELECT vend_id ,prod_id,prod_price FROM products WHERE prod_price &lt;=5 OR vend_id IN<br>(1001,1002);<br>从多个表中检索数据的情形，使用UNION 可能会处理更简单。<br>17.2.2 UNION 规则<br> 1   UNION 的每个查询必须包含相同的列，表达式，或聚集函数</p>
<p> 2   UNION 的默认行为，如果想返回所有匹配行 可以使用UNION ALL 而不是UNION<br> 17.2.4 对组合查询结果排序<br>SELECT vend_id ,prod_id,prod_price FROM products WHERE prod_price &lt;=5<br>UNION<br>SELECT vend_id,prod_id,prod_price FROM products WHERE vend_id IN (1001,1002)<br>ORDER BY vend_id ,prod_price ;<br>18章 全文本搜素<br>18.1 理解全文本搜素</p>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql更新和删除数据</title>
    <url>/2020/05/07/mysql%E6%9B%B4%E6%96%B0%E5%92%8C%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍如何利用UPDATA和DELETE语句进一步操控表数据</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h2 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h2><ul>
<li>更新特定行</li>
<li>更新所有行 <strong>特别注意不要省略WHERE子句 稍不注意就会更新表中的所有行</strong></li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">UPDATA customers SET cust_email ='elmer@gmail.com' WHERE cust_id =10005;</span><br></pre></td></tr></table></figure>

<p>更新多个列： 用逗号分隔</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">UPDATE customers SET cust_name='The Fudds',</span><br><span class="line">cust_email='elmer@gmail.com'</span><br><span class="line">WHERE cust_id =<span class="number">10005</span>;</span><br></pre></td></tr></table></figure>

<h3 id="IGNORE关键字"><a href="#IGNORE关键字" class="headerlink" title="IGNORE关键字"></a>IGNORE关键字</h3><p>如果用UPDATE 语句更新多行，并且在更新这些行中的一行或多行时出现一个现错误，则整个UPDATE操作被取消。</p>
<p>为即使是发生错误，也继续进行更新可以使用<strong>IGNORE</strong>关键字</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">UPDATE IGNORE customers...</span><br></pre></td></tr></table></figure>

<h2 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h2><ul>
<li>从表中删除特定的行</li>
<li>从表中删除所有行  <strong>不要省略WHERE子句</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">DELETE FROM customers WHERE cust_id =<span class="number">10006</span>;</span><br></pre></td></tr></table></figure>

<h3 id="更快的删除"><a href="#更快的删除" class="headerlink" title="更快的删除"></a>更快的删除</h3><p>如果想删除所有行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TRUNCATE TABLE</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql全文本搜索</title>
    <url>/2020/05/07/mysql%E5%85%A8%E6%96%87%E6%9C%AC%E6%90%9C%E7%B4%A2/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>Mysql 全文本搜索用法实例及详解。</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h1 id="启用全文本搜索支持"><a href="#启用全文本搜索支持" class="headerlink" title="启用全文本搜索支持"></a>启用全文本搜索支持</h1><p>CREATE  TABLE 接受FULLTEXT子句</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">CREATE TABLE productsnotes</span><br><span class="line">(</span><br><span class="line"> note_id <span class="keyword">int</span> NOT <span class="literal">NULL</span> AUTO_INCREMENT,  <span class="comment">/* auto increment 自动递增主键字段 */</span></span><br><span class="line"> prod_id <span class="keyword">char</span>(<span class="number">10</span>)  NOT <span class="literal">NULL</span>,</span><br><span class="line"> note_date datetime NOT <span class="literal">NULL</span>,</span><br><span class="line"> note_text  <span class="built_in">text</span>  <span class="literal">NULL</span>,</span><br><span class="line"> PRIMARY KEY(note_id),</span><br><span class="line"> FULLTEXT(note_text)</span><br><span class="line"> ) ENGINE=MyISAM;</span><br></pre></td></tr></table></figure>

<p>这条CREATE TABLE 语句定义表productnotes 并列出它所包含的列即可。这些列中有一个名为note_text 的列，为了进行全文本搜素，MySQL根据子句FULLTEXT(note_text)的指示对它进行索引。<br>FULLTEXT索引单个列，如果需要也可以指定多个列。</p>
<h2 id="在索引之后，使用俩个函数Match-和Against-执行全文本搜素"><a href="#在索引之后，使用俩个函数Match-和Against-执行全文本搜素" class="headerlink" title="在索引之后，使用俩个函数Match() 和Against()执行全文本搜素"></a>在索引之后，使用俩个函数Match() 和Against()执行全文本搜素</h2><p>其中Match()指定被搜索的列，Against()指定要使用的搜索表达式</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">SELECT note_text FROM productnotes WHERE Match(not_text) Against('rabbit');</span><br></pre></td></tr></table></figure>

<p>Match(note_text )指示MySQL针对指定的列进行搜索，Against(‘rabbit’) 指定词rabbit作为搜索文本。</p>
<p>使用完整的Match()说明，传递给Match()的值必须与FULLTEXT()定义中的相同。除非使用BINARY 方式，否则全文本搜索不区分大小写。</p>
<ul>
<li>搜索页可以简单地用LIKE子句完成</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">SELECT note_text FROM productnotes WHERE note_text LIKE '%rabbit%';</span><br></pre></td></tr></table></figure>

<ul>
<li>但是却与全文本搜索，各有优劣</li>
</ul>
<ol>
<li></li>
<li>在使用全文本搜索时就会对此结果排序，但是like却不会。</li>
</ol>
<h1 id="全文本布尔操作符"><a href="#全文本布尔操作符" class="headerlink" title="全文本布尔操作符"></a>全文本布尔操作符</h1><ul>
<li>+包含，词必须存在</li>
</ul>
<ul>
<li>-排除，词必须不出现</li>
<li>大于号 包含，而且增加等级值</li>
<li>&lt;包含，且减少等级值</li>
<li>() 把词组成子表达式(允许这些子表达式作为一个组被包含，排除，排列等）</li>
<li>~取消一个词的排序值</li>
</ul>
<ul>
<li>*词尾的通配符</li>
<li>“” 定义一个短语</li>
</ul>
<h2 id="布尔文本搜索"><a href="#布尔文本搜索" class="headerlink" title="布尔文本搜索"></a>布尔文本搜索</h2><p>布尔方式搜索，添加布尔操作符</p>
<p>IN BOOLEAN MODE</p>
<ul>
<li><p>举几个例子：</p>
</li>
<li><pre><code class="c">1 SELECT note_text FROM productnotes WHERE Match(note_text) Against('+rabbit +bait' IN BOOLEAN MODE);
<span class="comment">/*这个搜索匹配包含词rabbit和bait的行 */</span>
2 SELECT note_text FROM productnotes WHERE Match(note_text) Against('rabbit bait' IN BOOLEAN MODE);
<span class="comment">/*没有指定操作符，这个搜索匹配包含rabbit 和bait中的至少一个词的行。*/</span>
3 SELECT note_text FROM productnotes WHERE Match(note_text) Against('"rabbit bait"' IN BOOLEAN MODE);
4 SELECT note_text FROM productnotes WHERE Match(note_text) Against ('&gt;rabbit &lt;carrot' IN BOOLEAN MODE);</code></pre>
</li>
</ul>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>两数之和</title>
    <url>/2020/05/11/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2>]]></content>
  </entry>
  <entry>
    <title>mysql联结表</title>
    <url>/2020/05/08/mysql%E8%81%94%E7%BB%93%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍联结以及高级联结。</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h2 id="创建联结"><a href="#创建联结" class="headerlink" title="创建联结"></a>创建联结</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SELECT vent_name,prod_name,prod_price </span><br><span class="line">FROM vendors ,products </span><br><span class="line">WHERE vendors.vend_id=products.vend_id;</span><br><span class="line">ORDER BY vend_name,prod_name ;</span><br></pre></td></tr></table></figure>

<h2 id="内部联结"><a href="#内部联结" class="headerlink" title="内部联结"></a>内部联结</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SELECT vend_name , prod_name , prod_price FROM vendors INNER JOIN products ON vendors.vend_id =products.vend_id ;</span><br></pre></td></tr></table></figure>

<p>此时使用的是INNER JOIN 联结条件用的是ON</p>
<p>联结多个表：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SELECT prod_name,vend_name,prod_price,quantity FROM orderitems,products,vendors WHERE products.vend_id =vendors.vend_id AND orderitems.prod_id =products.prod_id AND order_num =<span class="number">20005</span>;</span><br></pre></td></tr></table></figure>

<h2 id="创建高级联结"><a href="#创建高级联结" class="headerlink" title="创建高级联结"></a>创建高级联结</h2><h3 id="使用表别名"><a href="#使用表别名" class="headerlink" title="使用表别名"></a>使用表别名</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">SELECT <span class="title">Concat</span><span class="params">(RTrim(vend_name)，‘（’，RTrim（vend_country）,’）’)</span> AS vend_title FROM vendors ORDER BY vend_name</span>;</span><br></pre></td></tr></table></figure>

<h3 id="内部联结："><a href="#内部联结：" class="headerlink" title="内部联结："></a>内部联结：</h3><p>它基于俩个表之间的相等测试</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SELECT vend_name .prod_name,prod_price FROM vendors INNER JOIN products ON vendors.vend_id =produces.vend_id;</span><br></pre></td></tr></table></figure>

<h3 id="自联结：-引用别名，自己联结自己"><a href="#自联结：-引用别名，自己联结自己" class="headerlink" title="自联结： 引用别名，自己联结自己"></a>自联结： 引用别名，自己联结自己</h3><p>假如你发现某物品（其ID为DTNRT)存在问题，因此想知道生产该物品的供应商生产的其他物品是否也存在这些问题。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SELECT p1.prod_id,p1.prod_name FROM products AS p1,products AS p2</span><br><span class="line">WHERE p1.vend_id =p2.vend_id AND p2.prod_id =’DTNTR’;</span><br></pre></td></tr></table></figure>

<p>因此products 表在from 子句中出现了俩次。虽然这是合法的，但是对products 的引用具有二义性。因此使用了别名。（用自联结而不用子查询。有时候处理联结要比处理查询要快的多）</p>
<h3 id="自然联结"><a href="#自然联结" class="headerlink" title="自然联结"></a>自然联结</h3><p><strong>自然联结的意思是排除多次出现，使每个列只返回一次。</strong></p>
<p><strong>我们建立的每个内部联结都是自然联结。</strong></p>
<p>示例通过对表使用通配符（SELECT *）对所有其他表的列使用明确的子集来完成的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SELECT c.*,o.ordr_num,o.order_date,oi.prod_id,oi.quantity,OI.item_price FROM customers AS c,orders AS o,orderitems AS oi WHERE c.cust_id =o.cust_id AND oi.order_num =o.order_num</span><br><span class="line">AND prod_id =’FB’;</span><br></pre></td></tr></table></figure>

<p>通配符只对第一个表使用，所有其他列明确列出，但没有重复的列被检索出来。</p>
<h3 id="外部联结："><a href="#外部联结：" class="headerlink" title="外部联结："></a>外部联结：</h3><p><strong>许多联结将一个表中的行与另外一个表中的行相关联，但有时候会需要包含没有关联行的那些行，</strong>例如 可能需要使用联结来完成以下的工作：</p>
<ul>
<li>对每个客户下了多少订单进行计数，包括那些至今未下订单的客户。</li>
<li>列出所有产品以及订购数量，包括没有人订购的产品</li>
<li>计算平均销售规模，包括那些至今未下订单的客户</li>
</ul>
<p><strong>联结包含了那些在相关表中没有关联行的行，这种叫做外部联结</strong>     </p>
<p>内部联结检索所有客户及其订单：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT customers.cust_id,order.orders.order_num FROM customers INNER JOIN orders ON</span><br><span class="line">Customers.cust_id &#x3D;orders.cust_id;</span><br></pre></td></tr></table></figure>

<p>外部联结：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SELECT customers.cust_id ,orders.order_num FROM customers LEFT OUTER JOIN oders </span><br><span class="line">ON customers.cust_id =orders.cust_id;</span><br></pre></td></tr></table></figure>

<p>输出为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cust_id   order_num</span><br><span class="line"> 10001      20005</span><br><span class="line"> 10001      20009</span><br><span class="line"> 10002       null</span><br><span class="line"> 10003       null</span><br></pre></td></tr></table></figure>

<p>此时必须要用RIGHT 或LEFT 关键字指定包括其所有行的表，如果是<strong>LEFT</strong>，就<strong>指出包括OUTER JOIN左边表的所有行</strong>。示例是包括（customers)表种所有行。</p>
<p>其实就是左外部联结和右外部联结</p>
<h3 id="使用带聚集函数的联结"><a href="#使用带聚集函数的联结" class="headerlink" title="使用带聚集函数的联结"></a>使用带聚集函数的联结</h3><p>使用了COUNT（）函数的联结</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT customers.cust_name, customers.cust_id,COUNT(orders.order_num) AS num_ord FROM customers INNER JOIN orders ON customers.cust_id &#x3D;orders.cust_id GROUP BY customers.cust_id;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT customers,cust_name,cusomers,cust_id,COUNT(orders,order_num)AS num_ord FROM customers LEFT OUTER JOIN orders ON customers.cust_id &#x3D;orders.cust_id  GROUP BY customers.cust_id;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql视图</title>
    <url>/2020/05/09/mysql%E8%A7%86%E5%9B%BE/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍视图究竟是什么，它们怎么样工作，何时使用它们。</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>视图是 虚拟的表，与包含数据的表不一样，视图只包含使用时动态检索数据的查询。</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT cust_name ,cust_contact FROM customers ,orders ,orderitems WHERE customers.cust_id&#x3D;orders.cust_id  AND orderitems.order_num &#x3D;orders.order_num</span><br><span class="line">AND prod_id &#x3D;&#39;TNT2&#39;;</span><br></pre></td></tr></table></figure>

<p>假设把整个查询包装成一个名叫productcustomers的虚拟表，则</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT cust_name,cust_contact FROM productcustomers WHERE prod_id&#x3D;&#39;TNT2&#39;;</span><br></pre></td></tr></table></figure>

<h3 id="为什么使用视图"><a href="#为什么使用视图" class="headerlink" title="为什么使用视图"></a>为什么使用视图</h3><ul>
<li>重用SQL 语句</li>
<li>简化复杂的SQL语句，在编写查询后，可以方便地重用它而不必知道它的基本查询细节。</li>
<li>使用表的组成部分而不是整个表</li>
<li>保护数据，可以给用户授予表的特定部分的访问权限，而不是整个表的访问权限。</li>
<li>更改数据格式和表示。</li>
</ul>
<h3 id="视图的规则和限制"><a href="#视图的规则和限制" class="headerlink" title="视图的规则和限制"></a>视图的规则和限制</h3><ul>
<li>视图必须唯一命名</li>
<li>对于创建的视图数目没有限制</li>
<li>视图可以嵌套</li>
<li>视图不能索引，不能有关联的触发器或者默认值</li>
</ul>
<h3 id="使用视图"><a href="#使用视图" class="headerlink" title="使用视图"></a>使用视图</h3><ul>
<li>视图用CREATE VIEW 来创建 </li>
<li>使用SHOW CREATE VIEW viewname; 来查看创建视图的语句</li>
<li>用DROP 来删除视图。语法为DROP VIEW viewname;</li>
<li>更新视图时，可以 先用DROP 再用CREATE  也可以直接使用CREATE OR REPLACE VIEW</li>
<li>可以先用DROP 再用 CREATE  也可以直接用CREATE OR REPLACE VIEW</li>
</ul>
<h3 id="利用视图简化复杂的联结"><a href="#利用视图简化复杂的联结" class="headerlink" title="利用视图简化复杂的联结"></a>利用视图简化复杂的联结</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">CREATE VIEW productcustomers AS SELECT cust_name,cust_contact,prod_id</span><br><span class="line">FROM customers,orders,orderitems WHERE customers.cust_id=orders.cust_id</span><br><span class="line">AND orderitems.order_num =orders.order_name;</span><br></pre></td></tr></table></figure>

<p>那么为了检索订购产品的TNT2客户</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">SELECT cust_name,cust_contact FROM productcustomers WHERE prod_id ='TNT2';</span><br></pre></td></tr></table></figure>

<h3 id="使用视图重新格式化检索出的数据"><a href="#使用视图重新格式化检索出的数据" class="headerlink" title="使用视图重新格式化检索出的数据"></a>使用视图重新格式化检索出的数据</h3><p>下面的SELECT  语句在单个组合计算列中返回供应商名和位置</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">SELECT <span class="title">Concat</span><span class="params">(RTrim(vend_name),<span class="string">'('</span>,RTrim(vend_country),<span class="string">')'</span>)</span> AS vend_title</span></span><br><span class="line"><span class="function">FROM vendors</span></span><br><span class="line"><span class="function">ORDER BY vend_name</span>;</span><br><span class="line"><span class="comment">/*out </span></span><br><span class="line"><span class="comment">    vend_title</span></span><br><span class="line"><span class="comment">    ACME  (USA)</span></span><br><span class="line"><span class="comment">    Jet Set (England)</span></span><br><span class="line"><span class="comment">    LT Supplies (USA)</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p>现在，假如经常需要这个格式的结果，不必在每次需要时执行联结，创建一个视图</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">CREATE VIEW vendorlocations AS SELECT <span class="title">Concat</span><span class="params">(RTrim(vend_name),<span class="string">'('</span>,RTrim(vend_country),<span class="string">')'</span>)</span> AS vend_title</span></span><br><span class="line"><span class="function">FROM vendors</span></span><br><span class="line"><span class="function">ORDER BY vend_name</span>;</span><br></pre></td></tr></table></figure>

<p>now </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM vendorlocations;</span><br></pre></td></tr></table></figure>

<h3 id="使用视图过滤不想要的数据"><a href="#使用视图过滤不想要的数据" class="headerlink" title="使用视图过滤不想要的数据"></a>使用视图过滤不想要的数据</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE VIEW customeremaillist AS SELECT cust_id,cust_name,cust_email FROM customers WHERE cust_email IS NOT NULL;</span><br></pre></td></tr></table></figure>

<p>在发送电子邮件到邮件列表时，需要排除没有电子邮件地址的用户</p>
<p>现在，可以像使用其他表一样使用视图customeremaillist </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM customeremaillist;</span><br></pre></td></tr></table></figure>

<h3 id="使用视图与计算字段"><a href="#使用视图与计算字段" class="headerlink" title="使用视图与计算字段"></a>使用视图与计算字段</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SELECT prod_id,</span><br><span class="line">       quantity,</span><br><span class="line">       item_price,</span><br><span class="line">       quantity*item_price AS expanded_price</span><br><span class="line">FROM orderitems</span><br><span class="line">WHERE order_num =<span class="number">20005</span>;</span><br></pre></td></tr></table></figure>

<p>现在转换为视图</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE VIEW orderitemsexpanded AS </span><br><span class="line">SELECT order_num,</span><br><span class="line">       prod_id,</span><br><span class="line">       quantity,</span><br><span class="line">       item_price,</span><br><span class="line">       quantity*item_price AS expanded_price</span><br><span class="line">FROM orderitems;</span><br></pre></td></tr></table></figure>

<p>检索订单20005的详细内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM orderitemsexpanded WHERE order_num &#x3D;20005;</span><br></pre></td></tr></table></figure>

<h3 id="更新视图"><a href="#更新视图" class="headerlink" title="更新视图"></a>更新视图</h3><p>视图是可更新的，更新一个视图将更新其基表。如果你对视图增加或者删除行，实际上是对其基表增加或者删除行。</p>
<p>但是并非所有的视图都是可更新的</p>
<ul>
<li>分组 （使用GROUP BY 和 HAVING )</li>
<li>联结</li>
<li>子查询</li>
<li>并</li>
<li>聚集函数 （Min() ,Count(),Sum() 等）；</li>
<li>DISTINCT;  （用于返回不重复的值 ，select distinct name,id from A</li>
<li>导出（计算）列</li>
</ul>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树</title>
    <url>/2020/05/07/%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本文。</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h2 id="二叉树的特点"><a href="#二叉树的特点" class="headerlink" title="二叉树的特点"></a>二叉树的特点</h2><ul>
<li><p>每个结点最多有俩颗子树。所以二叉树中不存在大于2的结点。</p>
</li>
<li><p>左子树和右子树是有顺序的，次序不能随意颠倒。</p>
</li>
<li><p>即使树中某结点只有一颗子树，也要区分它是左子树还是右子树</p>
<h3 id="二叉树的5种形态"><a href="#二叉树的5种形态" class="headerlink" title="二叉树的5种形态"></a>二叉树的5种形态</h3><ul>
<li>空二叉树</li>
<li>只有一个根结点</li>
<li>根节点只有左子树</li>
<li>根节点只有右子树</li>
<li>根节点既有左子树又有右子树</li>
</ul>
</li>
</ul>
<h2 id="特殊二叉树"><a href="#特殊二叉树" class="headerlink" title="特殊二叉树"></a>特殊二叉树</h2><ol>
<li><p>斜树</p>
<p>所有结点都只有左子树的二叉树叫做左斜树</p>
<p>所有结点都只有右子树的二叉树叫做右斜树</p>
<p>俩者统称为斜树</p>
</li>
<li><p>满二叉树</p>
<p>在一颗二叉树中，如果所有分支结点都存在左子树和右子树，并且所有叶子都在同一层上，这样的二叉树叫做满二叉树</p>
</li>
<li><p>完全二叉树</p>
<p>对一颗具有n个结点的二叉树按照层序编号，如果编号为i（1&lt;=i&lt;=n)的结点与同样深度的满二叉树中编号为i的结点在二叉树中位置完全相同，则这颗二叉树称为完全二叉树。</p>
</li>
</ol>
<h2 id="二叉树的性质"><a href="#二叉树的性质" class="headerlink" title="二叉树的性质"></a>二叉树的性质</h2><h3 id="二叉树性质1"><a href="#二叉树性质1" class="headerlink" title="二叉树性质1"></a>二叉树性质1</h3><p>性质1：在二叉树的第i层上至多有2^(i-1) 个结点。（i&gt;=1)</p>
<h3 id="二叉树性质2"><a href="#二叉树性质2" class="headerlink" title="二叉树性质2"></a>二叉树性质2</h3><p>性质2：深度为k的二叉树至多有2^(k) -1个结点 （k&gt;=1)   (<strong>结点的总量</strong>)</p>
<h3 id="二叉树性质3"><a href="#二叉树性质3" class="headerlink" title="二叉树性质3"></a>二叉树性质3</h3><p>性质3：对于任何一颗二叉树T，如果其终端结点数为n0，度为2的结点数为n2，则n0=n2+1</p>
<h3 id="二叉树性质4"><a href="#二叉树性质4" class="headerlink" title="二叉树性质4"></a>二叉树性质4</h3><p>性质4： 具有n个结点的完全二叉树的深度为[log2 n]+1 ([x]表示不大于x的最大整数)</p>
<h3 id="二叉树性质5"><a href="#二叉树性质5" class="headerlink" title="二叉树性质5"></a>二叉树性质5</h3><p><strong>性质5： 如果对一颗有n个结点的完全二叉树（其深度为[log2 n]+1)的结点按层序编号，对任一结点i（1&lt;=i&lt;=n)</strong></p>
<p><strong>有</strong></p>
<ol>
<li><strong>如果i=1,则结点i是二叉树的根，无双亲;如果i&gt;1,则其双亲是结点[i/2]</strong></li>
<li><strong>如果2i&gt;n,则结点i无左孩子（结点i为叶子结点）；否则其左孩子是结点2i</strong></li>
<li><strong>如果2i+1&gt;n,则结点i无右孩子；否则其右孩子是结点2i+1</strong></li>
</ol>
<h2 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h2><h4 id="二叉树的顺序存储结构"><a href="#二叉树的顺序存储结构" class="headerlink" title="二叉树的顺序存储结构"></a>二叉树的顺序存储结构</h4><p>用一维数组存储二叉树的结点，并且结点的位置，也就是数组的下标要能体现结点之间的逻辑关系。</p>
<p>一般来说顺序存储用于完全二叉树</p>
<h4 id="二叉链表"><a href="#二叉链表" class="headerlink" title="二叉链表"></a>二叉链表</h4><p>二叉树的每个结点最多有俩个孩子。所以为它设计一个数据域，和俩个指针域是比较自然的想法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lchid -- data --rchild</span><br></pre></td></tr></table></figure>

<p>lchild 和 rchild 都是指针域</p>
<p><strong>二叉树的二叉链表结点结构定义</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef struct BiTNode</span><br><span class="line">&#123;</span><br><span class="line">   TElemType data; &#x2F;&#x2F;结点数据</span><br><span class="line">   struct BiTNode *lchild ,*rchild;</span><br><span class="line">&#125; BiTNode, *BiTree;</span><br></pre></td></tr></table></figure>

<p>图示：</p>
<h2 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h2><p>二叉树的定义：</p>
<p><strong>二叉树的遍历是指从根节点出发，按照某种次序依次访问二叉树中的所有结点，使得每个结点被访问且仅被访问一次。</strong></p>
<h3 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h3><p>规则：若二叉树为空，则空操作返回，否则先访问根结点，然后前序遍历左子树，再前序遍历右子树。</p>
<p>如图：</p>
<p><img src="/2020/05/07/%E4%BA%8C%E5%8F%89%E6%A0%91/TIM%E5%9B%BE%E7%89%8720200510112558.png" alt></p>
<h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><p>规则： 若树为空，则空操作返回，否则从根节点开始（注意并不是先访问根节点），中序遍历根节点的左子树，然后是访问根节点，最后中序遍历右子树。</p>
<p><img src="/2020/05/07/%E4%BA%8C%E5%8F%89%E6%A0%91/TIM%E5%9B%BE%E7%89%8720200510113141.png" alt></p>
<h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><p>规则： 若树为空，则空操作返回，否则从左到右先叶子后结点的方式遍历访问左右子树，最后是访问根结点。</p>
<p>图示：</p>
<p><img src="/2020/05/07/%E4%BA%8C%E5%8F%89%E6%A0%91/TIM%E5%9B%BE%E7%89%8720200510113343.png" alt></p>
<h3 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h3><p>规则：若树为空，则空操作返回。</p>
<p>否则从树的第一层，也就是根节点开始访问，从上而下逐层遍历，在同一层中，按从左到右的顺序对结点逐个访问。</p>
<p><img src="/2020/05/07/%E4%BA%8C%E5%8F%89%E6%A0%91/TIM%E5%9B%BE%E7%89%8720200510113800.png" alt></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>DataStructure</tag>
      </tags>
  </entry>
  <entry>
    <title>使用存储过程</title>
    <url>/2020/05/10/%E4%BD%BF%E7%94%A8%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2>]]></content>
  </entry>
  <entry>
    <title>二叉树的遍历</title>
    <url>/2020/05/11/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍二叉树的遍历</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h2 id="前序遍历算法"><a href="#前序遍历算法" class="headerlink" title="前序遍历算法"></a>前序遍历算法</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrderTraverse</span><span class="params">(BiTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(T==<span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%c"</span>,T-&gt;data);</span><br><span class="line">    PreOrderTraverse(T-&gt;lchild);</span><br><span class="line">    PreOrderTraverse(T-&gt;rchild);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>递归调用PreOrderTaverse()函数</p>
<h2 id="中序遍历算法"><a href="#中序遍历算法" class="headerlink" title="中序遍历算法"></a>中序遍历算法</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrderTraverse</span><span class="params">(BiTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(T=<span class="literal">NULL</span>)</span><br><span class="line">  <span class="keyword">return</span> ;</span><br><span class="line">  InOrderTraverse(T-&gt;lchild);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%c"</span>,T-&gt;data);</span><br><span class="line">  InOrderTraverse(T-rchild);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>递归调用InOrderTraverse()</p>
<h2 id="后序遍历算法"><a href="#后序遍历算法" class="headerlink" title="后序遍历算法"></a>后序遍历算法</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrderTraverse</span><span class="params">(BiTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(T==<span class="literal">NULL</span>)</span><br><span class="line">  <span class="keyword">return</span> ;</span><br><span class="line">  PostOrderTraverse(T-&gt;lchild);</span><br><span class="line">  PostOrderTraverse(T-&gt;rchild);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%c"</span>,T-&gt;data);</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



































































































































































































































































]]></content>
  </entry>
  <entry>
    <title>内部类</title>
    <url>/2020/05/08/%E5%86%85%E9%83%A8%E7%B1%BB/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍JAVA内部类</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h1 id="JAVA内部类"><a href="#JAVA内部类" class="headerlink" title="JAVA内部类"></a>JAVA内部类</h1><h2 id="为什么需要内部类"><a href="#为什么需要内部类" class="headerlink" title="为什么需要内部类"></a>为什么需要内部类</h2><ul>
<li>内部类可以对同一个包中的其他类隐藏</li>
<li>内部类方法可以访问定义这个类的作用域中的数据，包括原有私有的数据。</li>
</ul>
<p>内部类的特点：</p>
<ul>
<li><p>一个内部类方法可以访问自身的数据字段</p>
</li>
<li><p>可以访问创建它的外围类对象的数据字段</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TalkingClock</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> interval;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> beep;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TalkingClock</span><span class="params">(<span class="keyword">int</span> interval ,<span class="keyword">boolean</span> beep)</span></span></span><br><span class="line"><span class="function">    </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// an inner class</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimePrinter</span> <span class="keyword">implements</span> <span class="title">ActionListener</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent event)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"at the tone,the time is"</span>+Insant.ofEpochMilli(event.getWhen()));</span><br><span class="line">            <span class="keyword">if</span>(beep) Toolkit.getDefaultToolkit().beep();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>TimePrinter类没有实例字段或者名为beep的对象。</p>
<p>实际上为此，<strong>内部类对象总有一个隐式引用，指向创建它的外部类对象。</strong></p>
</li>
</ul>
<p>​       但是这个引用在内部类的定义中是不可见的。我们将外围类对象的引用称为outer</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent event)</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">          System.out.println(<span class="string">"at the tone,the time is"</span>+Insant.ofEpochMilli(event.getWhen()));</span><br><span class="line">          <span class="keyword">if</span>(outer.beep) Toolkit.getDefaultToolkit().beep();</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<h3 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// an inner class</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TimePrinter</span> <span class="keyword">implements</span> <span class="title">ActionListener</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent event)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"at the tone,the time is"</span>+Insant.ofEpochMilli(event.getWhen()));</span><br><span class="line">            <span class="keyword">if</span>(beep) Toolkit.getDefaultToolkit().beep();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> listener =<span class="keyword">new</span> TimePrinter();</span><br><span class="line">    <span class="keyword">var</span> timer=<span class="keyword">new</span> Timer(interval,listener);</span><br><span class="line">    timer.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在示例代码中，只是在start方法中创建这个类型的对象时使用了一次。</p>
<p>当遇到这类情况时，可以在一个方法中局部的定义这个类。</p>
<ul>
<li><p>声明局部类时不能有访问说明符（即public 或者private)</p>
</li>
<li><p>局部类的作用域被限定在声明这个局部类的块中</p>
</li>
<li><p>局部类的优点: 对外部世界完全隐藏。除了start()方法外，没有任何方法知道TimePrinter类的存在。</p>
</li>
<li><p>局部类不仅可以访问外部类的字段，还可以访问局部变量。（必须是事实最终变量）它们一旦赋值就绝对不会改变。</p>
<h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>创建表和操控表</title>
    <url>/2020/05/08/%E5%88%9B%E5%BB%BA%E8%A1%A8%E5%92%8C%E6%93%8D%E6%8E%A7%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍表的创建，更改和删除的基本知识。</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2>]]></content>
  </entry>
  <entry>
    <title>初级排序算法</title>
    <url>/2020/05/12/%E5%88%9D%E7%BA%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>我们关注的主要对象是重新排列数组元素 的算法，其中每个元素都有一个主键 。排序算法的目标就是将所有元素的主键按照某种方式排列（通常是按照大小或是字母顺序）。排序后索引较大的主键大于等于索引较小的主键 . </p>
<h2 id="一-初级排序算法"><a href="#一-初级排序算法" class="headerlink" title="一.初级排序算法"></a>一.初级排序算法</h2><p>排序算法类的模板</p>
<p>排序算法类模版”中的 Example 类展示了我们的习惯约定：我们会将排序代码放在类的 sort() 方法中，该类还将包含辅助函数 less() 和 exch() （可能还有其他辅助函数）以及一个示例用例main() 。Example 类还包含了一些早期调试使用的代码：测试用例 main() 将标准输入得到的字符串排序，并用私有方法 show() 打印字符数组的内容。我们还会在本章中遇到各种用于比较不同算法并研究它们的性能的测试用例。为了区别不同的排序算法，我们为相应的类取了不同的名字，用例可以根据名字调用不同的实现，例如 Insertion.sort() 、Merge.sort() 、Quick.sort() 等。<br>大多数情况下，我们的排序代码只会通过两个方法操作数据：less() 方法对元素进行比较，exch()方法将元素交换位置。exch() 方法的实现很简单，通过 Comparable 接口实现 less() 方法也不困难。将数据操作限制在这两个方法中使得代码的可读性和可移植性更好，更容易验证代码的正确性、分析性能以及排序算法之间的比较。在学习具体的排序算法实现之前，我们先讨论几个对于所有排序算法都很<br>重要的问题。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">/* 请见算法2.1、算法2.2、算法2.3、算法2.4、算法2.5或算法2.7*/</span> &#125;<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">less</span><span class="params">(Comparable v, Comparable w)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> v.compareTo(w) &lt; <span class="number">0</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exch</span><span class="params">(Comparable[] a, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123; Comparable t = a[i]; a[i] = a[j]; a[j] = t; &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(Comparable[] a)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">// 在单行中打印数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++)</span><br><span class="line">StdOut.print(a[i] + <span class="string">" "</span>);</span><br><span class="line">StdOut.println();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSorted</span><span class="params">(Comparable[] a)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">// 测试数组元素是否有序</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; a.length; i++)</span><br><span class="line"><span class="keyword">if</span> (less(a[i], a[i-<span class="number">1</span>])) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">// 从标准输入读取字符串，将它们排序并输出</span></span><br><span class="line">String[] a = In.readStrings();</span><br><span class="line">sort(a);</span><br><span class="line"><span class="function"><span class="keyword">assert</span> <span class="title">isSorted</span><span class="params">(a)</span></span>;</span><br><span class="line">show(a);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="1-java中compareTo-用法详解"><a href="#1-java中compareTo-用法详解" class="headerlink" title="1.java中compareTo()用法详解"></a>1.java中compareTo()用法详解</h2><p>一、字符串比较用compareTo()时:</p>
<p>1，长度相同,从第一位开始比较，如果相同返回0，如果不同则马上返回这两个字符的ascii值的差值。</p>
<p>2，长度不同,直接返回长度差值。</p>
<p>二、Integer比较用compareTo()时：</p>
<p>1，对比数字时相同，返回0。</p>
<p>2，对比数字不同时，返回-1。</p>
<p><strong>对于 v&lt;w 、v=w 和 v&gt;w 三种情况，Java 的习惯是在 v.compareTo(w) 被调用时分别返回一个负整数、零和一个正整数（一般是 -1、0 和 1）</strong></p>
<h2 id="2-实现-Comparable-接口"><a href="#2-实现-Comparable-接口" class="headerlink" title="2.实现 Comparable 接口"></a>2.实现 Comparable 接口</h2><p>在创建自己的数据类型时，我们只要实现 Comparable 接口就能够保证用例代码可以将其排序。要做到这一点，只需要实现一个 compareTo() 方法来定义目标类型对象的自然次序  .</p>
<p><img src="/2020/05/12/%E5%88%9D%E7%BA%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/E:%5Cdev%5CMYBLOG%5Cblog%5Csource_posts%5C%E5%88%9D%E7%BA%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%5C2020-05-12_155201.png" alt></p>
<h2 id="二-选择排序"><a href="#二-选择排序" class="headerlink" title="二.选择排序"></a>二.选择排序</h2><p><strong>定义</strong>：一种最简单的排序算法是这样的：首先，找到数组中最小的那个元素，其次，将它和数组的第一个元素交换位置（如果第一个元素就是最小元素那么它就和自己交换）。再次，在剩下的元素中找到最小的元素，将它与数组的第二个元素交换位置。如此往复，直到将整个数组排序。这种方法叫做选择排序 ，因为它在不断地选择剩余元素之中的最小者。  </p>
<p><strong>选择排序代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Selection</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">// 将a[]按升序排列</span></span><br><span class="line"><span class="keyword">int</span> N = a.length; <span class="comment">// 数组长度for (int i = 0; i &lt; N; i++)</span></span><br><span class="line">&#123; <span class="comment">// 将a[i]和a[i+1..N]中最小的元素交换</span></span><br><span class="line"><span class="keyword">int</span> min = i; <span class="comment">// 最小元素的索引</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; N; j++)</span><br><span class="line"><span class="keyword">if</span> (less(a[j], a[min])) min = j;</span><br><span class="line">exch(a, i, min);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// less()、exch()、isSorted()和main()方法见“排序算法类模板”</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该算法将第 i 小的元素放到 a[i] 之中。数组的第 i 个位置的左边是 i 个最小的元素且它们不会再被访问。  </p>
<h1 id="三-插入排序"><a href="#三-插入排序" class="headerlink" title="三.插入排序"></a>三.插入排序</h1><p>在计算机的实现中，为了给要插入的元素腾出空间，我们需要将其余所有元素在插入之前都向右移动一位。这种算法叫做<strong>插入排序</strong>   </p>
]]></content>
  </entry>
  <entry>
    <title>学习方法</title>
    <url>/2020/05/07/%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>学习方法</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><ul>
<li>慢一点，你理解的越多，需要记的就越少</li>
<li>勤做练习，自己记笔记</li>
<li>上床睡觉之前就不要再看别的书了，或者至少不能再看其他有难度的东西</li>
<li>要喝水，要多喝水</li>
<li>大声说出来</li>
<li>听听你的大脑怎么说（注意大脑是不是负荷太重）</li>
<li>要有点感觉（真正融入到书的故事中）</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>创建和操纵表</title>
    <url>/2020/05/09/%E5%88%9B%E5%BB%BA%E5%92%8C%E6%93%8D%E7%BA%B5%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍表的创建，更改和删除的基本知识</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h2 id="1-创建表"><a href="#1-创建表" class="headerlink" title="1.创建表"></a>1.创建表</h2><p>示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">CREATE TABLE customers</span><br><span class="line">(</span><br><span class="line"> cust_id   <span class="keyword">int</span>  NOT <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line"> cust_name <span class="keyword">char</span>(<span class="number">50</span>) NOT <span class="literal">NULL</span>,</span><br><span class="line"> cust_address <span class="keyword">char</span>(<span class="number">50</span>) NOT <span class="literal">NULL</span>,</span><br><span class="line"> PRIMARY KEY(cust_id)</span><br><span class="line">) ENGINE=InnoDB</span><br></pre></td></tr></table></figure>

<ul>
<li>语句格式化  MYsql语句中忽略空格，可以采用缩进格式，这样以便阅读和编辑。</li>
<li>处理现有的表 在创建新表时，指定的表名必须不存在，否则将出错。如果你仅仅想在一个表不存在时创建它，应该在表名后给出IF NOT EXISTS  如CREATE TABLE customers IF NOT EXISTS</li>
</ul>
<h3 id="使用NULL值"><a href="#使用NULL值" class="headerlink" title="使用NULL值"></a>使用NULL值</h3><p>NULL值就是没有值或者缺值。</p>
<p>NULL为默认值，如果不指定NOT NULL 则认定为是NULL</p>
<h4 id="理解NULL"><a href="#理解NULL" class="headerlink" title="理解NULL"></a>理解NULL</h4><p>不要把NULL和空串相混淆，NULL值是没有值，它不是空串。</p>
<p>如果指定  ‘ ’   （俩个单引号，其间没有字符）</p>
<p>这在<strong>NOT NULL</strong> 列中是允许的</p>
<p>空串 是一个有效的值，它并不是无值</p>
<p>NULL值用关键字NULL而不是空串指定。</p>
<h2 id="2-主键再介绍"><a href="#2-主键再介绍" class="headerlink" title="2.主键再介绍"></a>2.主键再介绍</h2><p>创建多个列组成的主键，应该以逗号分隔的列表给出列名</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">PRIMARY <span class="title">KEY</span><span class="params">(order_num,order_item)</span></span></span><br></pre></td></tr></table></figure>

<p><strong>主键只能使用不允许NULL值的列，允许NULL值的列不能作为唯一标识</strong></p>
<h2 id="3-使用AUTO-INCREMENT"><a href="#3-使用AUTO-INCREMENT" class="headerlink" title="3.使用AUTO_INCREMENT"></a>3.使用AUTO_INCREMENT</h2><p>AUTO_INCREMENT告诉Mysql ，本列每当增加一行时自动增量。每次执行一个INSERT操作时，Mysql自动对该列增量，每个列只允许有一个AUTO_INCREMENT列，而且它必须被索引。（如，通过使它成为主键）</p>
<h2 id="4-使用默认值"><a href="#4-使用默认值" class="headerlink" title="4.使用默认值"></a>4.使用默认值</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE customers</span><br><span class="line">(</span><br><span class="line"> cust_id   int  NOT NULL AUTO_INCREMENT,</span><br><span class="line"> cust_name char(50) NOT NULL,</span><br><span class="line"> cust_address char(50) NOT NULL ,</span><br><span class="line"> quantity int   NOT NULL DEFAULT 1,</span><br><span class="line"> PRIMARY KEY(cust_id)</span><br><span class="line">) ENGINE&#x3D;InnoDB</span><br></pre></td></tr></table></figure>

<p>DEFAULT 1 指示Mysql再未给出数量的情况下，使用数量1</p>
<ul>
<li>不允许函数，Mysql 不允许使用函数作为默认值，它只支持常量</li>
<li>使用默认值而不是NULL值。</li>
</ul>
<h2 id="5-引擎类型"><a href="#5-引擎类型" class="headerlink" title="5.引擎类型"></a>5.引擎类型</h2><p>上述的demo 以ENGINE=InnoDB语句结束。</p>
<p>Mysql有一个具体管理和处理数据的内部引擎，而且MYSQL 具有多种引擎，它打包多个引擎，并且这些引擎都隐藏再Mysql服务器内，全都能执行CREATE TABLE 和SELECT 等命令。</p>
<h3 id="引擎种类"><a href="#引擎种类" class="headerlink" title="引擎种类"></a>引擎种类</h3><table>
<thead>
<tr>
<th>InnoDB</th>
<th>可靠的事务处理引擎，它不支持全文本搜索</th>
</tr>
</thead>
<tbody><tr>
<td>MEMORY</td>
<td>在功能等同于MyISAM,但由于数据存储在内存（不是磁盘中），速度很快（特别适用于临时表）</td>
</tr>
<tr>
<td>MyISAM</td>
<td>性能极高的引擎，它支持全文本搜索，但是不支持事务处理</td>
</tr>
</tbody></table>
<p>如果省略ENGINE=语句，则使用默认引擎（MyISAM）</p>
<p><strong>注意：</strong></p>
<ul>
<li>引擎类型可以混用</li>
<li>外键不能跨引擎，一个引擎的表不能引用具有使用不同引擎的表的外键。</li>
</ul>
<h2 id="6-更新表"><a href="#6-更新表" class="headerlink" title="6.更新表"></a>6.更新表</h2><p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">ALTER TABLE vendors ADD vend_phone <span class="title">CHAR</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ALTER TABLE vendors DROP COLUMN vend_phone;</span><br></pre></td></tr></table></figure>

<p>ALTER TABLE 的一种常见用途是定义外键。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE orderitems ADD CONSTRAINT fk_orderitems_orders FOREIGN KEY (order_num) REFERENCES orders (order_num);</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE orderitems ADD CONSTRAINT fk_orderitems_products FOREIGN KEY (prod_id) REFERENCES products (prod_id);</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE orders ADD CONSTRAINT fk_orders_customers FOREIGN KEY (cust_id)REFERENCES customers (cust_id);</span><br></pre></td></tr></table></figure>

<p>ALTER TABLE要极为小心，应该在改动之前做一个完整的备份</p>
<h3 id="7-删除表"><a href="#7-删除表" class="headerlink" title="7.删除表"></a>7.删除表</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DROP TABLE customers2;</span><br></pre></td></tr></table></figure>

<p>无法撤销，永久删除</p>
<h3 id="8-重命名表"><a href="#8-重命名表" class="headerlink" title="8.重命名表"></a>8.重命名表</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RENAME TABLE customers2 TO customers;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RENAME TABLE backup_customers TO customers,</span><br><span class="line">             backup_vendors TO vendors,</span><br><span class="line">             backup_products TO products;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>实习</title>
    <url>/2020/05/08/%E5%AE%9E%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍实习</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>本日是5.8日  6.15日正式开始面试</p>
<p>需要学习的内容有：</p>
<p>1 数据结构</p>
<p>2 JAVA集合</p>
<p>3 JAVA并发</p>
<p>4 JVM</p>
<p>5 mysql</p>
<p>6 Spring</p>
<p>7 计网和操作系统面经内容。</p>
<p>8 redis了解。</p>
<ul>
<li><p>JAVASE 数据结构算法 mysql 这三个是一类</p>
</li>
<li><p>设计模式 JVM  这两个是一类  能大概谈谈每种设计模式是什么就可以了</p>
</li>
<li><p>剑指offer 这个单独一类 </p>
</li>
</ul>
<p>先定位好去什么样的公司吧，如果想试试大厂，那么后端大数据都无所谓，基础要非常好，</p>
<p>然后大数据/后端 一两个框架搞熟，如果去那种普通的公司，算法啥的，简单看看就行，多搞点项目经验，对框架好熟悉</p>
<p>java做初+中的，mysql建议全做，不会的看答案，然后自己写</p>
<p>做个SSM和Boot的CRUD项目就可以了。<br>不要花太多精力在上面。<br>几天时间吧。<br>boot估计一天不到。<br>主要是熟悉整个流程。<br>找个手感<br><a href="https://leetcode-cn.com/" target="_blank" rel="noopener">https://leetcode-cn.com/</a><br>没事刷刷题<br>java做初+中的，mysql建议全做，不会的看答案，然后自己写</p>
]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>时间复杂度</title>
    <url>/2020/05/05/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/</url>
    <content><![CDATA[<h1 id="算法时间复杂度"><a href="#算法时间复杂度" class="headerlink" title="算法时间复杂度"></a>算法时间复杂度</h1><h2 id="算法时间复杂度定义"><a href="#算法时间复杂度定义" class="headerlink" title="算法时间复杂度定义"></a>算法时间复杂度定义</h2><ul>
<li><p>O()来体现算法时间复杂度的记法</p>
<a id="more"></a>

<h2 id="推导大O阶的方法"><a href="#推导大O阶的方法" class="headerlink" title="推导大O阶的方法"></a>推导大O阶的方法</h2><ol>
<li><p>用常数1代替所有加法常数</p>
</li>
<li><p>在修改后的运行次数函数中，只保留最高阶项</p>
</li>
<li><p>如果最高阶项存在且不是1，则去除这个项相乘的常数</p>
<p>得到的结果就是大O阶.</p>
<h3 id="举例说明："><a href="#举例说明：" class="headerlink" title="举例说明："></a>举例说明：</h3><h4 id="常数阶"><a href="#常数阶" class="headerlink" title="常数阶"></a>常数阶</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> sum=<span class="number">0</span>,n=<span class="number">100</span>; <span class="comment">//执行1次</span></span><br><span class="line">sum=(<span class="number">1</span>+n)*n/<span class="number">2</span>; <span class="comment">//执行2次</span></span><br><span class="line">sum=(<span class="number">1</span>+n)*n/<span class="number">2</span>; <span class="comment">//</span></span><br><span class="line">sum=(<span class="number">1</span>+n)*n/<span class="number">2</span>; <span class="comment">//</span></span><br><span class="line">sum=(<span class="number">1</span>+n)*n/<span class="number">2</span>; <span class="comment">//</span></span><br><span class="line">...</span><br><span class="line">sum=(<span class="number">1</span>+n)*n/<span class="number">2</span>; <span class="comment">//执行10次</span></span><br></pre></td></tr></table></figure>

<p>事实上无论n为多少，上面代码就是1次，2次，10次的差别，这种与问题大小无关（与n的大小无关）执行时间恒定的算法。称为O(1)阶，又叫常数阶</p>
<h4 id="线性阶"><a href="#线性阶" class="headerlink" title="线性阶"></a>线性阶</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 时间复杂度为O(1)的程序     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
</li>
</ul>
<p>​               循环的时间复杂度为O(n)</p>
<h4 id="对数阶"><a href="#对数阶" class="headerlink" title="对数阶"></a>对数阶</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int count&#x3D;1;</span><br><span class="line">while (count &lt;n)</span><br><span class="line">&#123;</span><br><span class="line">count &#x3D;count *2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2^x=n  x=log2 n   所以这个循环的时间复杂度为O(log n).</p>
<h4 id="平方阶"><a href="#平方阶" class="headerlink" title="平方阶"></a>平方阶</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i,j;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">/*时间复杂度为O(1)的程序步骤序列      */</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度为O(m*n)</p>
<p>又如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i,j;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(j=i;j&lt;n;j++)</span><br><span class="line">&#123;</span><br><span class="line"> <span class="comment">/* 时间复杂度为O(1)的程序*/</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行总次数 n+n-1+(n-2)+…+1=n(n+1)/2   时间复杂度为O(n^2) </p>
<h4 id="常见的时间复杂度"><a href="#常见的时间复杂度" class="headerlink" title="常见的时间复杂度"></a>常见的时间复杂度</h4><p>常用时间复杂度耗费时间比对：</p>
<p>O(1)&lt;O(log n)&lt;O(n)&lt;O(nlogn)&lt;O(n^2)&lt;O(n^3)&lt;O(2^n)&lt;O(n!)&lt;O(n^n)</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>DataStructure</tag>
      </tags>
  </entry>
  <entry>
    <title>抽象类和接口的区别详解</title>
    <url>/2020/05/11/%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8C%BA%E5%88%AB%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍抽象类和接口</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>它不能被实例化，只能被用作 子类的超类。抽象类是被用来创建继承层级里子类的模板。</p>
<p>以JDK中的GenericServlet为例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericServlet</span> <span class="keyword">implements</span> <span class="title">Servlet</span>, <span class="title">ServletConfig</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// abstract method</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest req, ServletResponse res)</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Its implementation</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// other method related to Servlet</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当HttpServlet类继承GenericServlet时，它提供了<strong>service</strong>方法的实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpServlet</span> <span class="keyword">extends</span> <span class="title">GenericServlet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest req, ServletResponse res)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// implementation</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Implementation</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Implementation</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// some other methods related to HttpServlet</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>接口是抽象方法的集合，如果一个类实现了某个接口，那么它就继承了这个接口的抽象方法，这就像契约的模式，如果实现了这个接口，那么就必须确保使用了这些方法，接口只是一种形式，它本身不能实现任何方法，以Externalizable接口为例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Externalizable</span> <span class="keyword">extends</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">writeExternal</span><span class="params">(ObjectOutput out)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">readExternal</span><span class="params">(ObjectInput in)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当你继承这个接口时，你就必须实现上面的俩个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Externalizable</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> employeeId;</span><br><span class="line">    String employeeName;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readExternal</span><span class="params">(ObjectInput in)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        employeeId = in.readInt();</span><br><span class="line">        employeeName = (String) in.readObject();</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeExternal</span><span class="params">(ObjectOutput out)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"> </span><br><span class="line">        out.writeInt(employeeId);</span><br><span class="line">        out.writeObject(employeeName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="什么时候使用抽象类和接口？"><a href="#什么时候使用抽象类和接口？" class="headerlink" title="什么时候使用抽象类和接口？"></a>什么时候使用抽象类和接口？</h2><ul>
<li>如果你拥有一些方法，并且想让它们中的一些有默认实现，那么使用抽象类吧</li>
<li>如果你想实现多重继承，那么请使用接口，抽象类不允许多重继承</li>
<li>如果基本功能在不断的进行改变，那么你就需要使用抽象类。如果不断改变基本功能，并且使用接口，那么就需要改变所有实现了该接口的类。</li>
</ul>
<h2 id="JAVA8中的默认方法和静态方法"><a href="#JAVA8中的默认方法和静态方法" class="headerlink" title="JAVA8中的默认方法和静态方法"></a>JAVA8中的默认方法和静态方法</h2><p>Oracle已经开始尝试向接口中引入默认方法和静态方法，依次来减少抽象类和接口之间的差异。</p>
<p>现在我们可以为接口提供默认实现的方法并且不用强制子类来实现它。default方法。</p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>JAVASE</tag>
      </tags>
  </entry>
  <entry>
    <title>树</title>
    <url>/2020/05/07/%E6%A0%91/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>树的相关概念</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h2 id="树的相关概念"><a href="#树的相关概念" class="headerlink" title="树的相关概念"></a>树的相关概念</h2><h3 id="度"><a href="#度" class="headerlink" title="度"></a>度</h3><ul>
<li>结点拥有的子树树称为结点的度</li>
<li>度为0的结点称为叶结点（Leaf）或者终端结点。</li>
<li>度不为0的结点称为非终端结点或者分支结点</li>
<li>树的度是树内各结点度的最大值</li>
</ul>
<h3 id="深度（Depth-或高度"><a href="#深度（Depth-或高度" class="headerlink" title="深度（Depth)或高度"></a>深度（Depth)或高度</h3><ul>
<li>层次：结点的层次从根开始定义起，根为第一层，根的孩子为第二层，以此类推</li>
<li>树中结点的最大层次被称为树的深度（Depth）或者高度。</li>
</ul>
<h3 id="有序树和无序树"><a href="#有序树和无序树" class="headerlink" title="有序树和无序树"></a>有序树和无序树</h3><p>如果将树中结点的各子树看成从左至右是由次序的，不能互换的，那么该树为有序树，否则为无序树。</p>
<h3 id="森林"><a href="#森林" class="headerlink" title="森林"></a>森林</h3><p>森林是m（m&gt;=0)颗互不相交的树的集合。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>DataStructure</tag>
      </tags>
  </entry>
  <entry>
    <title>线性表</title>
    <url>/2020/05/05/%E7%BA%BF%E6%80%A7%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h1><h2 id="线性表的定义："><a href="#线性表的定义：" class="headerlink" title="线性表的定义："></a>线性表的定义：</h2><ul>
<li>线性表：零个或多个数据元素的有限序列</li>
<li>线性表元素的个数n 定义为线性表的长度，当n=0时，称为空表<a id="more"></a>

</li>
</ul>
<h2 id="线性表的顺序存储结构"><a href="#线性表的顺序存储结构" class="headerlink" title="线性表的顺序存储结构"></a>线性表的顺序存储结构</h2><ul>
<li><p>顺序存储定义： 线性表的顺序存储结构，指的是用一段地址连续的存储单元依次存储线性表的数据元素</p>
<h3 id="顺序存储方式"><a href="#顺序存储方式" class="headerlink" title="顺序存储方式"></a>顺序存储方式</h3><ul>
<li><p>顺序存储的结构代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 20 </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemType data[MAXSIZE];</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">&#125;SqList;</span><br></pre></td></tr></table></figure>

<p>MAXSIZE：数组长度</p>
<p>length： 线性表当前的长度</p>
<p>另外以数组data进行存储</p>
</li>
<li><p>线性表中的地址</p>
<p>存储器中的每个存储单元都有自己的编号，这个编号称为地址。</p>
<h3 id="顺序存储结构的插入与删除"><a href="#顺序存储结构的插入与删除" class="headerlink" title="顺序存储结构的插入与删除"></a>顺序存储结构的插入与删除</h3><h4 id="获得元素操作"><a href="#获得元素操作" class="headerlink" title="获得元素操作"></a>获得元素操作</h4><p>我们实现GetElem操作，即把线性表L中的第i个元素值返回。只要i的数值在数组范围内，就是把数组的第i-1下标返回即可。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR 0 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status; <span class="comment">/*函数的类型 */</span></span><br><span class="line"><span class="function">Status <span class="title">GetElem</span><span class="params">(SqList L,<span class="keyword">int</span> i,ElemType *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L.length==<span class="number">0</span> ||i&lt;<span class="number">1</span> ||i&gt;L.length)</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    *e=L.data[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h4><p>算法思路：</p>
<ul>
<li><p>插入位置不合理</p>
</li>
<li><p>线性表长度大于数组长度</p>
</li>
<li><p>从最后一个元素遍历到第i个元素</p>
</li>
<li><p>将要插入的元素填到位置i处</p>
</li>
<li><p>表长+1</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ListInsert</span><span class="params">(SqList *L,<span class="keyword">int</span> i,ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> k;</span><br><span class="line"><span class="keyword">if</span>(L-&gt;length==MAXSIZE)</span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line"><span class="keyword">if</span>(i&lt;<span class="number">1</span>||i&gt;L-&gt;length+<span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line"><span class="keyword">if</span>(i&lt;=L-&gt;length)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(k=L-&gt;length<span class="number">-1</span>;k&gt;=i<span class="number">-1</span>;k--)</span><br><span class="line">&#123;</span><br><span class="line">L-&gt;data[k+<span class="number">1</span>]=L-&gt;data[k];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">L-&gt;data[i<span class="number">-1</span>]=e;</span><br><span class="line">L-&gt;length++;</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>DataStructure</tag>
      </tags>
  </entry>
  <entry>
    <title>设计原则</title>
    <url>/2020/05/08/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍设计原则</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2>]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式</title>
    <url>/2020/05/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2>]]></content>
  </entry>
  <entry>
    <title>指针</title>
    <url>/2020/05/04/%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<h1 id="10-1-指针变量"><a href="#10-1-指针变量" class="headerlink" title="10.1 指针变量"></a>10.1 指针变量</h1><p> 由于通过地址能访问指定的内存存储单元。可以说地址“指向”该内存单元。地址可以形象地称为指针，意思是通过指针能够找到内存单元。<br> <a id="more"></a></p>
<h2 id="1一个变量的地址称为该变量的指针，如果有一个变量专门用来存放另一个变量的地址，那么它就是指针变量。"><a href="#1一个变量的地址称为该变量的指针，如果有一个变量专门用来存放另一个变量的地址，那么它就是指针变量。" class="headerlink" title="1一个变量的地址称为该变量的指针，如果有一个变量专门用来存放另一个变量的地址，那么它就是指针变量。"></a>1一个变量的地址称为该变量的指针，如果有一个变量专门用来存放另一个变量的地址，那么它就是指针变量。</h2><p>一般形式为：<br>类型说明 * 变量名<br>int * q;<br>C语言中提供了地址运算符“&amp;”来表示变量的地址。其中一般形式为：<br>&amp;变量名;</p>
<h2 id="2给指针变量赋值一般有俩个方法"><a href="#2给指针变量赋值一般有俩个方法" class="headerlink" title="2给指针变量赋值一般有俩个方法"></a>2给指针变量赋值一般有俩个方法</h2><p>1   </p>
<pre><code>int a;
int *p=&amp;a</code></pre><p>2       </p>
<pre><code>int a;
int *p;
p=&amp;a;</code></pre><h2 id="3-指针变量的引用"><a href="#3-指针变量的引用" class="headerlink" title="3 指针变量的引用"></a>3 指针变量的引用</h2><p>引用指针变量是对变量进行间接访问的一种形式</p>
<p>对指针变量的引用形式如下：</p>
<p>*指针变量 其含义是引用指针变量所指向的值</p>
<h2 id="4-amp-和-的区别"><a href="#4-amp-和-的区别" class="headerlink" title="4 &amp; 和 *的区别"></a>4 &amp; 和 *的区别</h2><p> &amp;运算符是一个返回操作数地址的单目运算符，叫做取地址运算符</p>
<p> *运算符是返回指定的地址内的变量的值，叫做指针运算符。</p>
<h2 id="5-指针自增和自减运算"><a href="#5-指针自增和自减运算" class="headerlink" title="5 指针自增和自减运算"></a>5 指针自增和自减运算</h2><p>基本整型变量i在内存中占4个字节，指针P是指向变量i的地址的，p++是指向下一个存放基本整型数的地址。</p>
<h2 id="6-数组与指针"><a href="#6-数组与指针" class="headerlink" title="6 数组与指针"></a>6 数组与指针</h2><p>在定义一个一维数组时，系统会在内存中为该数组分配一个存储空间，其数组的名称就是数组在内存中的首地址。<br>例如：</p>
<p>1      </p>
<pre><code>int *p,a[10]; 
 p=a;</code></pre><p>或</p>
<p>2   </p>
<pre><code>int *p,a[10]; 
p=&amp;a[0];</code></pre><h2 id="7-二维数组与指针"><a href="#7-二维数组与指针" class="headerlink" title="7 二维数组与指针"></a>7 二维数组与指针</h2><p>表示二维数组中元素地址的方法：</p>
<p>&amp;a[0][0]可以看作数组0行0列的首地址，也可以看作二维数组的首地址。</p>
<p>&amp;a[m][n]就是第m行n列元素的地址。而a[0]+n表示第0行第n个元素的地址。</p>
<h2 id="8指针变量作为函数参数"><a href="#8指针变量作为函数参数" class="headerlink" title="8指针变量作为函数参数"></a>8指针变量作为函数参数</h2><p>指针变量也可以作为函数参数</p>
<p>例<br>在swap（int <em>a,int</em> b)中</p>
<p>在函数调用的过程中，主调用函数与被调用函数之间有一个数值传递的过程。函数调用中发生的数据传递是单向的，只能把实际参数的值传递给形式参数，在函数调用的过程中，形式参数的值发生改变，但是实际参数的值不会发生变化。如果swap(int a,int b) 则不能实现x与y值的互换。</p>
<p>通过指针传递参数可以减少值传递带来的开销，也可以使函数调用不产生值传递。</p>
<h2 id="9返回指针值的函数"><a href="#9返回指针值的函数" class="headerlink" title="9返回指针值的函数"></a>9返回指针值的函数</h2><p>返回的值的类型为指针类型，返回指针值的函数简称为指针函数</p>
<p>定义指针函数的一般形式为 </p>
<p>类型名 *函数名（参数列表） </p>
<p>如   int *fun(int x,int y)</p>
<p>如 </p>
<pre><code>int *per(int a,int b)
{
 int *p;
 p=&amp;Perimeter;
 Perimeter=(a+b)*2;
 return p; 
}</code></pre>]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>链表</title>
    <url>/2020/05/07/%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>线性表的链式存储结构详解</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>单链表存储状态图示：</p>
<p>Node由存放数据元素的数据域和存放后继结点地址的指针域组成。</p>
<p>头结点的数据域可以不存储任何信息。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">ElemType data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;Node;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">LinkList</span>;</span></span><br></pre></td></tr></table></figure>

<p>假设p是指向线性表第i个元素的指针，则该结点ai的数据域 可以用p-&gt;data 来表示</p>
<p>结点ai的指针域用p-&gt;next来表示。p-&gt;next指向第i-1个元素，即指向ai+1的指针。即p-&gt;data=ai</p>
<p>那么p-&gt;next-&gt;data=ai+1</p>
<p><img src="/2020/05/07/%E9%93%BE%E8%A1%A8/%E9%93%BE%E8%A1%A801.png" alt></p>
<h2 id="单链表的读取"><a href="#单链表的读取" class="headerlink" title="单链表的读取"></a>单链表的读取</h2><p>算法思路：<br>从第一个头结点开始，指针域p-&gt; next一直向下指向第i个元素的指针域。</p>
<ol>
<li>声明指针p指向链表的第一个结点 ，初始化从1开始</li>
<li>当j&lt;i时就遍历链表，p不断向后移动，j++</li>
<li>当链表末尾p为空时，则说明第i个结点不存在</li>
<li>若查找成功，那么返回结点p的数据。</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">GetElem</span><span class="params">(LinkList L,<span class="keyword">int</span> i,ElemType *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> j;</span><br><span class="line">  LinkList p;</span><br><span class="line">  p=L-&gt;next;</span><br><span class="line">  j=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(p&amp;&amp;j&lt;i)</span><br><span class="line">  &#123;</span><br><span class="line">  p=p-&gt;next;</span><br><span class="line">  j++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(!p || j&gt;i)</span><br><span class="line">  <span class="keyword">return</span> ERROR；</span><br><span class="line">  *e=p-&gt;data;</span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="单链表的插入与删除"><a href="#单链表的插入与删除" class="headerlink" title="单链表的插入与删除"></a>单链表的插入与删除</h2><h3 id="单链表插入"><a href="#单链表插入" class="headerlink" title="单链表插入"></a>单链表插入</h3><p>思路：在俩节点之间再插入一个结点</p>
<p>图示：</p>
<p><img src="/2020/05/07/%E9%93%BE%E8%A1%A8/%E9%93%BE%E8%A1%A802.png" alt></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">s-&gt;next=p-&gt;next;</span><br><span class="line">p-next=s;   <span class="comment">/*单链表插入标准语句 */</span></span><br></pre></td></tr></table></figure>

<p>实现插入操作的具体思路：</p>
<ol>
<li></li>
<li></li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ListInsert</span><span class="params">(LinkList *L,<span class="keyword">int</span> i,ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(p&amp;&amp;j&lt;i)</span><br><span class="line">    &#123;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">        ++j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!p||j&gt;i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    s=(LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    s-&gt;data=e;</span><br><span class="line">    s-&gt;next=p-&gt;next;</span><br><span class="line">    p-&gt;next=s;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>malloc  函数，生成一个新的结点，其类型与Node一样的，其实质就是在内存中找一小块空地，准备用来存放数据e的s结点。</p>
<h2 id="单链表的删除："><a href="#单链表的删除：" class="headerlink" title="单链表的删除："></a>单链表的删除：</h2><p>图示：</p>
<p><img src="/2020/05/07/%E9%93%BE%E8%A1%A8/%E9%93%BE%E8%A1%A803.png" alt></p>
<p>实际上就是p-&gt;next=p-&gt;next-&gt;next;</p>
<p>如果用q来表示p-&gt;next即</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">q=p-&gt;next;</span><br><span class="line">p-&gt;next=q-&gt;next;</span><br></pre></td></tr></table></figure>

<p>思路：</p>
<p>具体实现代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ListDelete</span><span class="params">(LinkList *L,<span class="keyword">int</span> i,ElemType *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> j;</span><br><span class="line">LinkList p,q;</span><br><span class="line">p=*L;</span><br><span class="line">j=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(p-&gt;next &amp;&amp; j&lt;i)</span><br><span class="line">&#123;</span><br><span class="line">p=p-&gt;next;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!(p-&gt;next)||j&gt;i)</span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line">q=p-&gt;next;</span><br><span class="line">p-&gt;next=q-&gt;next;</span><br><span class="line">*e=q-&gt;data;</span><br><span class="line"><span class="built_in">free</span>(q);<span class="comment">/* 回收一个Node结点 */</span></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>DataStructure</tag>
      </tags>
  </entry>
</search>
