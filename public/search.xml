<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>JAVA容器分类</title>
    <url>/2020/05/06/JAVA%E5%AE%B9%E5%99%A8%E5%88%86%E7%B1%BB/</url>
    <content><![CDATA[<h2 id="Java容器可分为两大类："><a href="#Java容器可分为两大类：" class="headerlink" title="Java容器可分为两大类："></a>Java容器可分为两大类：</h2><ul>
<li><p>Collection接口 继承JAVA.lang.Object</p>
<ul>
<li>List接口<ul>
<li><strong>ArrayList</strong></li>
<li>LinkedList<a id="more"></a></li>
<li>Vector(了解，已过时)</li>
</ul>
</li>
<li>Set接口<ul>
<li>HashSet<ul>
<li>LinkedHashSet</li>
</ul>
</li>
<li>TreeSet</li>
</ul>
</li>
</ul>
</li>
<li><p>Map接口  继承JAVA.lang.Object</p>
<ul>
<li><p><strong>HashMap</strong></p>
<ul>
<li>LinkedHashMap</li>
</ul>
</li>
<li><p>TreeMap</p>
</li>
<li><p>ConcurrentHashMap</p>
</li>
<li><p>Hashtable(了解，，已过时)</p>
</li>
</ul>
</li>
</ul>
<h2 id="Collection接口："><a href="#Collection接口：" class="headerlink" title="Collection接口："></a>Collection接口：</h2><ul>
<li><p>Collection接口的常用方法</p>
</li>
<li><p>添加功能</p>
<ul>
<li><table>
<thead>
<tr>
<th>boolean add(Object obj)</th>
<th>添加一个元素</th>
</tr>
</thead>
<tbody><tr>
<td>boolean  addAll(Collection c)</td>
<td>添加一个集合的元素</td>
</tr>
</tbody></table>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">static</span> Collection c = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"add:"</span>+c.add(<span class="string">"hello"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/* 输出为 add:true */</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<p>​             </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> Collection c1 = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    <span class="keyword">static</span> Collection c2 = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        c1.add(<span class="string">"xxxx"</span>);</span><br><span class="line">        System.out.println(<span class="string">"add:"</span> + c1.add(<span class="string">"hello"</span>));</span><br><span class="line">        System.out.println(<span class="string">"addAll:"</span> + c2.addAll(c1));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/* 输出add:true</span></span><br><span class="line"><span class="comment">addAll:true */</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>删除功能</p>
<ul>
<li><table>
<thead>
<tr>
<th>void clear()</th>
<th>移除所有元素</th>
</tr>
</thead>
<tbody><tr>
<td>boolean remove(Object o)</td>
<td>移除一个元素</td>
</tr>
<tr>
<td>boolean removeAll(Object o)</td>
<td>移除一个集合的所有元素</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>判断功能</p>
<ul>
<li><table>
<thead>
<tr>
<th>boolean contains(Object o)</th>
<th>判断集合中是否包含指定的元素</th>
</tr>
</thead>
<tbody><tr>
<td>boolean containsAll(Object o)</td>
<td>判断集合中是否包含指定的集合元素（一个集合中的所有元素</td>
</tr>
<tr>
<td>boolean isEmpty()</td>
<td>判断集合是否为空</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p><strong>获取功能</strong></p>
<p>重点：迭代器（Iterator） 下一篇中我们详细解释。</p>
<p>itetator()   返回在此 Collection 的元素上进行迭代的迭代器。用于遍历集合中的对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Muster</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Collection&lt;String&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">"a"</span>);</span><br><span class="line">        list.add(<span class="string">"b"</span>);</span><br><span class="line">        list.add(<span class="string">"c"</span>);</span><br><span class="line">        Iterator&lt;String&gt; it=list.iterator();</span><br><span class="line">        <span class="keyword">while</span>(it.hasNext())</span><br><span class="line">        &#123;</span><br><span class="line">            String str=(String) it.next();</span><br><span class="line">            System.out.println(str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>JAVASE</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA_String_API</title>
    <url>/2020/05/06/JAVA-String-API/</url>
    <content><![CDATA[<p>String API</p>
<ul>
<li>append()</li>
</ul>
<p>  在由许多小段的字符串构建一个字符串时，则使用StringBuilder类（字符串构造器）</p>
<p>  首先构造一个空的字符串构造器：<br>  <a id="more"></a></p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StringBuilder builder =<span class="keyword">new</span> StringBuilder();</span><br></pre></td></tr></table></figure>

<p>  当需要添加一部分内容时，调用append()方法</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">builder.append(ch);</span><br><span class="line">builder.append(str);</span><br><span class="line">String completedString=builder.toString(); <span class="comment">/*调用toString()方法，得到String对象。*/</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>char charAt(int index)</p>
<p>返回给定位置的代码单元。</p>
</li>
<li><p>int length()</p>
</li>
</ul>
<p>​         返回字符串代码单元的个数</p>
<ul>
<li><p>String repeat(int count)</p>
<p>返回一个字符串，将当前字符重复count次</p>
</li>
<li><p>boolean equals() </p>
<p>用来检测俩个字符串是否相等</p>
<p>boolean equalsIgnoreCase() </p>
<p>用来检测俩个字符串是否相等（不区分大小写）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="string">"hello"</span>.equals(greeting);</span><br><span class="line"><span class="string">"HELLO"</span>.equalsIgnoreCase(<span class="string">"hello"</span>); <span class="comment">/* 不区分大小写 */</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>注意：</p>
<p><strong>不要用==运算符检测是否相等。</strong></p>
<p><strong>这个运算符只能够确定俩个字符串是否存放在同一个位置上。</strong>当然如果字符串存放在同一个位置上，它们必然相等，但是完全有可能把内容相同的多个字符串副本放置在不同的位置上。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String greeting=<span class="string">"Hello"</span>;</span><br><span class="line"><span class="keyword">if</span>(greeting ==<span class="string">"Hello"</span>)</span><br><span class="line">  -- <span class="keyword">true</span></span><br><span class="line"> <span class="keyword">if</span>(greeting.substring(<span class="number">0</span>,<span class="number">3</span>)==<span class="string">"Hel"</span>)</span><br><span class="line">  --<span class="keyword">false</span></span><br></pre></td></tr></table></figure>

<p>实际上只有字符串字面量共享，而+或者substring操作得到的字符串并不共享。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>JAVASE</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA多态</title>
    <url>/2020/05/06/JAVA%E5%A4%9A%E6%80%81/</url>
    <content><![CDATA[<h1 id="JAVA多态"><a href="#JAVA多态" class="headerlink" title="JAVA多态"></a>JAVA多态</h1><p>JAVA的三大特性为：</p>
<ul>
<li><p>封装</p>
</li>
<li><p>继承</p>
</li>
<li><p>多态</p>
<p>今天我们就来说一说到底什么是多态，以及多态到底有什么用。</p>
<a id="more"></a>

<h2 id="多态的定义"><a href="#多态的定义" class="headerlink" title="多态的定义"></a>多态的定义</h2><p>定义： <strong>事物的不同形态。</strong>多态多应用在向上转型。</p>
<p>多态的用处：在实际开发中，如果发现某个类的方法可以做出改进，但工程已经交付给用户使用，但是不想影响其他部分对于该方法的调用。那么通过创建子类对象，对于父类方法进行<strong>重写</strong>（Override）。<strong>但是此时父类的其他成员方法和成员属性却不能进行利用</strong>。此时就需要用到<strong>向上转型</strong>，将子类向上转换为父类，此时程序的相应方法做出了改进，程序的其他地方也不会受此影响。</p>
</li>
</ul>
<h2 id="多态的三个前提："><a href="#多态的三个前提：" class="headerlink" title="多态的三个前提："></a>多态的三个前提：</h2><ul>
<li><p>存在继承关系，子类继承父类</p>
</li>
<li><p>子类要重写父类的方法 </p>
<p>子类重写父类的成员方法。</p>
</li>
<li><p>父类数据类型的引用要指向子类对象 （向上转型）</p>
<p>如 Animal am=new Cat();</p>
<h2 id="多态的弊端"><a href="#多态的弊端" class="headerlink" title="多态的弊端"></a>多态的弊端</h2><p>向上转型之后，<strong>不能够引用子类特有的成员属性和子类特有的成员方法</strong>。</p>
</li>
</ul>
<p>  <strong>注意：静态方法不能被重写，所以也不存在多态，即使向上转型，子类重写了父类的静态方法，子类调用父类的静态方法，输出依然是父类静态方法中的值。</strong></p>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>JAVASE</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA的静态方法不能被重写</title>
    <url>/2020/05/06/JAVA%E7%9A%84%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E4%B8%8D%E8%83%BD%E8%A2%AB%E9%87%8D%E5%86%99/</url>
    <content><![CDATA[<h1 id="JAVA的静态方法不能被重写"><a href="#JAVA的静态方法不能被重写" class="headerlink" title="JAVA的静态方法不能被重写"></a>JAVA的静态方法不能被重写</h1><p>堆区：</p>
<ul>
<li>存储的全部都是对象，每个对象都包含一个与之对应的class信息。<a id="more"></a>

</li>
</ul>
<p>栈区:</p>
<p>方法区：</p>
<ul>
<li>方法区包含所有的class和static变量  class可以直接调用static</li>
</ul>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>JAVASE</tag>
      </tags>
  </entry>
  <entry>
    <title>List集合</title>
    <url>/2020/05/07/List%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>List集合包括List接口和List接口所有的实现类</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h2 id="List接口定义的方法"><a href="#List接口定义的方法" class="headerlink" title="List接口定义的方法"></a>List接口定义的方法</h2><p>除了继承Collection外，List接口还有俩个重要的方法。</p>
<table>
<thead>
<tr>
<th>get(int index)</th>
<th>获得指定索引位置的元素</th>
</tr>
</thead>
<tbody><tr>
<td>set(int index,Object obj)</td>
<td>将集合中指定索引位置的对象修改为指定的对象</td>
</tr>
</tbody></table>
<h2 id="List接口的实现类"><a href="#List接口的实现类" class="headerlink" title="List接口的实现类"></a>List接口的实现类</h2><ul>
<li><p>ArrayList</p>
<p>实现了可变的数组，允许保存所有元素包括null .并且可以根据索引的位置对集合进行快速的随机访问，缺点是向指向的索引位置插入对象或删除对象时的速度较慢</p>
</li>
<li><p>LinkedList </p>
<p>采用链表的结构保存对象。优点是便于向集合中插入和删除对象</p>
<p>分别用ArrayList 和LinkedList来实例化集合</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;E&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">List&lt;E&gt; list=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p>E是合法的JAVA数据类型，也可以是字符串String</p>
</li>
</ul>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>JAVASE</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql全文本搜索</title>
    <url>/2020/05/07/mysql%E5%85%A8%E6%96%87%E6%9C%AC%E6%90%9C%E7%B4%A2/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>Mysql 全文本搜索用法实例及详解。</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h1 id="启用全文本搜索支持"><a href="#启用全文本搜索支持" class="headerlink" title="启用全文本搜索支持"></a>启用全文本搜索支持</h1><p>CREATE  TABLE 接受FULLTEXT子句</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">CREATE TABLE productsnotes</span><br><span class="line">(</span><br><span class="line"> note_id <span class="keyword">int</span> NOT <span class="literal">NULL</span> AUTO_INCREMENT,  <span class="comment">/* auto increment 自动递增主键字段 */</span></span><br><span class="line"> prod_id <span class="keyword">char</span>(<span class="number">10</span>)  NOT <span class="literal">NULL</span>,</span><br><span class="line"> note_date datetime NOT <span class="literal">NULL</span>,</span><br><span class="line"> note_text  <span class="built_in">text</span>  <span class="literal">NULL</span>,</span><br><span class="line"> PRIMARY KEY(note_id),</span><br><span class="line"> FULLTEXT(note_text)</span><br><span class="line"> ) ENGINE=MyISAM;</span><br></pre></td></tr></table></figure>

<p>这条CREATE TABLE 语句定义表productnotes 并列出它所包含的列即可。这些列中有一个名为note_text 的列，为了进行全文本搜素，MySQL根据子句FULLTEXT(note_text)的指示对它进行索引。<br>FULLTEXT索引单个列，如果需要也可以指定多个列。</p>
<h2 id="在索引之后，使用俩个函数Match-和Against-执行全文本搜素"><a href="#在索引之后，使用俩个函数Match-和Against-执行全文本搜素" class="headerlink" title="在索引之后，使用俩个函数Match() 和Against()执行全文本搜素"></a>在索引之后，使用俩个函数Match() 和Against()执行全文本搜素</h2><p>其中Match()指定被搜索的列，Against()指定要使用的搜索表达式</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">SELECT note_text FROM productnotes WHERE Match(not_text) Against('rabbit');</span><br></pre></td></tr></table></figure>

<p>Match(note_text )指示MySQL针对指定的列进行搜索，Against(‘rabbit’) 指定词rabbit作为搜索文本。</p>
<p>使用完整的Match()说明，传递给Match()的值必须与FULLTEXT()定义中的相同。除非使用BINARY 方式，否则全文本搜索不区分大小写。</p>
<ul>
<li>搜索页可以简单地用LIKE子句完成</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">SELECT note_text FROM productnotes WHERE note_text LIKE '%rabbit%';</span><br></pre></td></tr></table></figure>

<ul>
<li>但是却与全文本搜索，各有优劣</li>
</ul>
<ol>
<li></li>
<li>在使用全文本搜索时就会对此结果排序，但是like却不会。</li>
</ol>
<h1 id="全文本布尔操作符"><a href="#全文本布尔操作符" class="headerlink" title="全文本布尔操作符"></a>全文本布尔操作符</h1><ul>
<li>+包含，词必须存在</li>
</ul>
<ul>
<li>-排除，词必须不出现</li>
<li>大于号 包含，而且增加等级值</li>
<li>&lt;包含，且减少等级值</li>
<li>() 把词组成子表达式(允许这些子表达式作为一个组被包含，排除，排列等）</li>
<li>~取消一个词的排序值</li>
</ul>
<ul>
<li>*词尾的通配符</li>
<li>“” 定义一个短语</li>
</ul>
<h2 id="布尔文本搜索"><a href="#布尔文本搜索" class="headerlink" title="布尔文本搜索"></a>布尔文本搜索</h2><p>布尔方式搜索，添加布尔操作符</p>
<p>IN BOOLEAN MODE</p>
<ul>
<li><p>举几个例子：</p>
</li>
<li><pre><code class="c">1 SELECT note_text FROM productnotes WHERE Match(note_text) Against('+rabbit +bait' IN BOOLEAN MODE);
<span class="comment">/*这个搜索匹配包含词rabbit和bait的行 */</span>
2 SELECT note_text FROM productnotes WHERE Match(note_text) Against('rabbit bait' IN BOOLEAN MODE);
<span class="comment">/*没有指定操作符，这个搜索匹配包含rabbit 和bait中的至少一个词的行。*/</span>
3 SELECT note_text FROM productnotes WHERE Match(note_text) Against('"rabbit bait"' IN BOOLEAN MODE);
4 SELECT note_text FROM productnotes WHERE Match(note_text) Against ('&gt;rabbit &lt;carrot' IN BOOLEAN MODE);</code></pre>
</li>
</ul>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>char可以存储汉字吗？</title>
    <url>/2020/05/06/char%E5%8F%AF%E4%BB%A5%E5%AD%98%E5%82%A8%E6%B1%89%E5%AD%97%E5%90%97%EF%BC%9F/</url>
    <content><![CDATA[<h2 id="char存储汉字"><a href="#char存储汉字" class="headerlink" title="char存储汉字"></a>char存储汉字</h2><ul>
<li><p>char是按照字符存储的，不管是英文还是中文，JAVA中固定占用2个字符，用来存储Unicode字符，范围在0-65535.</p>
</li>
<li><p>Unicode编码字符集中包含了汉字，所以char类型变量当然可以存储汉字拉。</p>
<a id="more"></a>

<h2 id="char和String的区别"><a href="#char和String的区别" class="headerlink" title="char和String的区别"></a>char和String的区别</h2><ul>
<li>char表示字符，定义时用单引号，只能存储一个字符。如char c=‘x’ ;</li>
<li>String表示的是字符串，可以存储一个或多个字符 如String name=”tom”;</li>
<li>char是基本数据类型，但是String是一个类，具有面向对象的特征,可以调用方法</li>
</ul>
</li>
</ul>
<p>如name.length();</p>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>JAVASE</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA中的输入与输出</title>
    <url>/2020/05/06/JAVA%E4%B8%AD%E7%9A%84%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA/</url>
    <content><![CDATA[<h1 id="JAVA中的输入"><a href="#JAVA中的输入" class="headerlink" title="JAVA中的输入"></a>JAVA中的输入</h1><h2 id="读取输入"><a href="#读取输入" class="headerlink" title="读取输入"></a>读取输入</h2><p>  要想通过输入台进行输入，首先需要构造一个与“标准输入流”System.in关联的Scanner对象。<br>  <a id="more"></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Scanner scanner=<span class="keyword">new</span> Scanner(System.in);</span><br></pre></td></tr></table></figure>

<p>Scanner类中的方法：</p>
<p>API  JAVA.util.Scanner</p>
<table>
<thead>
<tr>
<th>String nextLine()</th>
<th>读取输入的下一行内容  以enter作为结束符  能得到带空格的字符串</th>
</tr>
</thead>
<tbody><tr>
<td>String next()</td>
<td>读取输入的下一个单词（以空格作为分隔符）空格视而不见</td>
</tr>
<tr>
<td>int nextInt()</td>
<td>只读取int值</td>
</tr>
<tr>
<td>double nextDouble()</td>
<td>只读取double值</td>
</tr>
<tr>
<td>boolean hasNext()</td>
<td>检测输入中是否还有其他的单词</td>
</tr>
<tr>
<td>boolean hasNextInt()</td>
<td>检测输入中是否还有表示整数</td>
</tr>
<tr>
<td>boolean hasNextDouble()</td>
<td>检测输入中是否还有表示浮点数</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>JAVASE</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql必知必会</title>
    <url>/2020/05/03/mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/</url>
    <content><![CDATA[<p> 登录mysql -h localhost -u root -p<br> Show databases;<br> Use databasename;<br>Show tables;  //显示行</p>
<a id="more"></a>
<p> Show columns from xxx;   //显示列<br>SELECT DISTINCT  published FROM t_blog ;  DISTINCT此关键字指示只返回不同的值。<br> SELECT id FROM t_blog LIMIT 5;<br> SELECT id FROM t_blog LIMIT 3,3; //从第三行开始的后三行<br> SELECT t_blog.id FROM blog.t_blog;   完全限定的列名和表名 和之前的用法一样。<br> SELECT id,type_id,user_id FROM t_blog ORDER BY type_id,id;  先对type_id排序 再对id进行排序。<br> DESC 降序 ASC 升序  没多大用处<br> SELECT id FROM t_blog ORDER BY type_id LIMIT 1; 此种方式找到了数值最大的一行。<br> 在使用where 过滤时 ，order by 排序要在where的后面<br>  SELECT id FROM t_blog  where id &lt;&gt;10;   &lt;&gt; 不匹配检查<br> 范围值检查<br>  SELECT ID FROM T_BLOG WHERE ID BETWEEN 10 AND 20 :<br> Select id from t_blog where id is null;  空值检查<br> Select id,user_id from t_blog where id &lt;=10 and user_id &lt;=1;<br> Select prod_name,prod_price from products where vend_id=1002 or vend_id =1003 and<br>  Prod_price&gt;=10; SQL处理OR操作符和AND操作符时，优先处理AND操作符。<br> 故先处理 vend_id =1003 and prod_price&gt;=10  或者  vend_id=1002  ；<br>解决方法是<br>Select prod_name,prod_price from products where (vend_id =1002 or vend_id =1003) and prod_price &gt;=10    用( )来明确分组操作符。DBMS 首先过滤圆括号内的OR条件。<br>NOT 在MYSQL中的NOT中 MYSQL支持使用NOT 对IN,BETWEEN 和EXISTS子句取反。这与多数其他DBMS允许使用NOT对各种条件取反有很大区别。<br>######<br>通配符<br>用来匹配值的一部分的特殊字符<br>LIKE 指示MYSQL 后跟的搜索模式利用通配符匹配而不是直接相等匹配比较<br>SELECT prod_name FROM products WHERE prod_name REGEXP ‘[123] Ton’<br>ORDER BY prod_name;<br>正则表达式 [123]Ton 其中[123]定义一组字符<br>它的意思是匹配1或2或3  因此 1ton 和2ton 都匹配且返回了<br>[] 其实是另一种形式的OR语句<br>[1|2|3]Ton 的缩写 为 [123]Ton<br>1|2|3 Ton 的意思是检索出1或2或3 ton<br>[^123] 匹配除这些字符除外的任何东西<br> ^ 是REGEXP的否定符号<br>在匹配范围中<br>0到9  将由[0123456789] 等同于 [0-9]<br>.表示匹配一个字符<br>输入 SELECT vend_name FROM vendors WHERE vend_name REGEXP ‘.’ ORDER BY vend_name<br>.匹配任意字符  这时每一行都被检索出来 为了匹配特殊字符 必须用\ 作为前导<br>如<br>SELECT vend_name FROM vendors WHERE vend_name REGEXP ‘\.’ ORDER BY vend_name<br>这才是期望的输出 \.匹配. 这种处理就是所谓的转义。<br>？ 字符 ？匹配它前面的任何字符的0次或者1次出现。<br> 如 SELECT prod_name FROM products WHERE prod_name REGEXP ‘\([0-9] sticks?\)’<br> ORDER BY prod_name ;<br>Sticks 匹配 stick 和sticks s后的?使s可选<br>另外例如<br>SELECT prod_name FROM products WHERE prod_name REGEXP ‘[[:digit:]]{4}<br>ORDER BY prod_name；<br>[:digit:]匹配任意数字<br>因而它作为数字的一个集合<br>{4} 确切的要求它前面的字符 出现4次<br>匹配特定位置的文本，需要使用表9-4列出的定位符<br>^ 文本的开始<br>$ 文本的结尾<br>[[:&lt;:]] 词的开始<br>[[:&gt;;]] 词的结尾<br>‘^[0-9\.]’ 找出一个数 包括以小数点开始的数开始的所有产品。<br>SELECT prod_name FROM products WHERE prod_name REGEXP ‘^[0-9\.]’<br>ORDER BY prod_name;<br>在第10章 中 创建计算字段<br>MySQL 使用Concat() 函数来实现<br>SELECT Concat(vend_name,’（‘，vend_country,’）’)<br>FROM vendors ORDER BY vend_name;<br>拼接  将值联结到一起构成单个值<br>比如以上的输出为<br>ACME (USA)<br>删除数据右侧多余的空格来整理数据<br>MySQL 的RTrim()可以去掉值右边的所有的空格<br>SELECT Concat(RTrim(vend_name),’(‘,RTrim(vend_country),’)’)<br>FROM vendors<br>ORDER BY vend_name;<br>LTrim() 去掉串左边的空格<br>Trim()去掉左右俩边的空格<br>SELECT Concat (RTrim(vend_name),’(‘,RTrim(vend_country),’)’)AS vend_title FROM vendors ORDER BY vend_name;<br>一个未命名的列不能用于客户机的应用中，因为客户机没有办法去引用它。<br>所以才出现了别名。AS 关键字来赋予别名 任何客户机应用都可以按名来引用这个列，就像它是一个实际的表列一样。</p>
<p>执行算数运算<br>SELECT pro_id,quantity,item_price FROM oderitems WHERE order order_num =20005;<br>在算数运算中 检索200005中的所有物品<br>如果要计算汇总物品的价格<br>SELECT prod_id ,quantity,item_price, quantity*item_price  AS expanded_price FROM oderitems WHERE order_num =20005;<br>此时客户机可以使用这个新计算的列，就像其他列一样。<br>MYSQL 支持基本算术运算符</p>
<ul>
<li><ul>
<li>/ 圆括号可以用来区分优先顺序<br>第十一章 使用数据来处理函数<br>SELECT vend_name,Upper(vend_name) AS  vend_name_upcase FROM vendors ORDER BY vend_name;<br>Upper()将文本转换为大写<br>常用的文本处理函数：<br>Left() 返回串左边的字符<br>Length() 返回串的长度<br>Locate()返回串的一个子串<br>Lower()将串转换为小写<br>LTrim() 去掉左边的空格<br>Right()返回串右边的字符<br>RTrim() 去掉串右边的空格<br>Soundex()返回串的Soundex值<br>SubString() 返回子串的字符<br>Upper() 大写<br>Soundex（） 将任何文本串转换为描述其语音表示的字母数字模式的算法<br>如<br>SELECT cust_name ,cust_contact FROM customers WHERE cust_contact =’Y.Lie’;<br>其联系名是为Y.Lee 此时没办法搜索到<br>但是通过<br>SELECT cust_name,cust_contact FROM customers WHERE Soundex(cust_contact)=Soundex(‘Y.lie);<br>此时可以搜索到Y.Lee<br>日期和时间的处理函数<br>Date() 返回日期部分的日期部分<br>Year() 返回日期部分的年份部分<br>Day()<br>Month()</li>
</ul>
</li>
</ul>
<p>如：<br>SELECT cust_id,oder_num FROM oders WHERE Date(order_date)=’2005-09-01’;<br>SELECT cust_id,order_num FROM orders WHERE Date(order_date) BETWEEN ‘2005-09-01’AND’2005-03-30’;<br>数值处理函数<br>Abs() 返回数的绝对值</p>
<p>Cos() 角度的余弦<br>Exp() 返回一个数的指数值<br>Mod() 操作数的余数<br>……<br>第12章 汇总数据<br>12.1 聚集函数  运行在行组上，计算和返回单个值得函数<br>AVG() 返回某列的平均值<br>COUNT()  返回某列的行数<br>MAX() 返回某列的最大值<br>MIN() 返回某列的最小值<br>SUM() 返回某列值之和<br>SELECT AVG(prod_price) AS avg_price FROM products;<br>AVG() 也可以用来确定列或行当平均值<br>SELECT AVG(prod_price) AS avg_price FROM products WHERE vend_id =1003;<br>COUNT () 函数<br>COUNT(<em>)对表中的行的数目进行技术<br>COUNT(column) 对特定列中具有值的行进行计数<br>例如SELECT COUNT(</em>) AS num_cust FROM customers;<br>利用COUNT(<em>)对所有行计数<br>SELECT COUNT(cust_email) AS num_cust FROM customers;<br>对于cust_email中所有有值的行进行计数<br>MAX() 指定列中的最大值 MAX()要求指定列名。<br>MIN()<br>SUM() 也可以用来合计计算值 用来得出总的订单金额<br>SELECT SUM(item_price  *quantity) AS total_price FROM oderitems WHERE order_num=20005;<br>SUM(item_price *quantity) 返回订单中所有物品价钱之和<br>第13章 分组数据<br>SELECT vend_id ,COUNT(</em>) AS num_prods FROM products GROUP BY vend_id;<br>Vend_id num_prods<br>1001        3<br>1002        2<br>1003        7<br>1005        2<br>上述语句将vend_id进行分组，GROUP BY 对于分组的整个结果集进行聚集<br>使用ROLLUP 使用WITH ROLLUP 关键字，将得到每个分组以及分组汇总级别的值<br>2如何过滤分组?<br>HAVING<br>如： SELECT cust_id ,COUNT(<em>)AS orders FROM orders GROUP BY cust_id<br>HAVING COUNT(</em>) &gt;=2<br>它过滤COUNT(<em>)&gt;=2 的那些分组<br>输入： SELECT vend_id,COUNT(</em>) AS num_prods FROM products WHERE prod_price &gt;=10<br>GROUP BY vend_id HAVING COUNT(<em>)&gt;=2;<br>13.4 分组和排序<br>GROUP BY 和ORDER BY<br>GROUP BY  是在ORDER BY 之前，在where 之后<br>第14章 子查询<br>子查询：嵌套在其他查询中的查询<br>1 检索包含物品TNT2 的所有订单的编号<br> SELECT order_num FROM orderitems WHERE prod_id =’TNT2’；<br>2 检索具有前一步骤列出的订单编号的所有客户的ID<br> SELECT cust_id FROM orders WHERE order_num IN (20005,20007);<br>3 现在把第一个查询变为子查询 组合成俩个查询：<br> SELECT cust_id FROM oders WHERE order_num IN (SELECT order_num FROM orderitems WHERE prod_id =’TNT2’);<br>在SELECT 语句中，子查询总是从内向外查询处理。<br>检索这些客户的ID的客户信息，检索俩列的SQL语句为：<br>SELECT cust_name, cust_contact FROM customers WHERE cust_id IN (10001,10004);<br>则可以转换为：<br>SELECT cust_name ,cust_contact FROM customers WHERE cust_id IN (SELECT cust_id FROM orders WHERE order_num IN (SELECT order_num FROM orderitems WHERE prod_Id =’TNT2’))；<br>计算结果子查询：<br>SELECT cust_name,cust_state,(SELECT COUNT(</em>) FROM oders WHERE orders.cust_id=customers.cust_id)AS orders FROM customers ORDER BY cust_name;<br>第15 章  联结表  join 表<br>外键位某个表中的一列 它包含另一个表的主键值定义了俩个表之间的关系。<br>SELECT vent_name,prod_name,prod_price<br>FROM vendors ,products<br>WHERE vendors.vend_id=products.vend_id;<br>ORDER BY vend_name,prod_name ;<br>此种方法通过WHERE子句来限定了列名 ，如果要给出 vend_id 那么mysql_id 并不知道是哪个<br>存在一种状况是<br>笛卡尔积：<br>在不指定where子句时<br>：<br>SELECT vend_name ,prod_name,prod_price<br>FROM vendors,products ORDER BY vend_name,prod_name;<br>15.2.2 内部联结<br>目前为止所使用的联结称为 等值联结  它基于俩个表之间的相等测试 这种联结也叫内部联结。<br>SELECT vend_name , prod_name , prod_price FROM vendors INNER JOIN products ON vendors.vend_id =products.vend_id ;<br>此时使用的是INNER JOIN  联结条件用的是ON<br>联结多个表：<br>SELECT prod_name,vend_name,prod_price,quantity FROM orderitems,products,vendors WHERE products.vend_id =vendors.vend_id AND orderitems.prod_id =products.prod_id AND order_num =20005;<br>第16章 创建高级联结<br>使用表别名<br>SELECT Concat(RTrim(vend_name)，‘（’，RTrim（vend_country）,’）’) AS vend_title FROM vendors ORDER BY vend_name;<br>内部联结：<br>它基于俩个表之间的相等测试<br>SELECT vend_name .prod_name,prod_price FROM vendors INNER JOIN products ON vendors.vend_id =produces.vend_id;<br>自联结： 引用别名，自己联结自己<br>SELECT p1.prod_id,p1.prod_name FROM products AS p1,products AS p2<br>WHERE p1.vend_id =p2.vend_id AND p2.prod_id =’DTNTR’;<br>此查询种需要的俩个表实际上是相同的表。<br>因此products 表在from 子句中出现了俩次。虽然这是合法的，但是对products 的引用具有二义性。因此使用了别名。（用自联结而不用子查询。有时候处理联结要比处理查询要快的多）<br>自然联结：<br>其中你只能选择那些唯一的列。<br>通过对表使用通配符（SELECT <em>）对所有其他表的列使用明确的子集来完成的。<br>SELECT c.</em>,o.ordr_num,o.order_date,oi.prod_id,oi.quantity,OI.item_price FROM customers AS c,orders AS o,orderitems AS oi WHERE c.cust_id =o.cust_id AND oi.order_num =o.order_num<br>AND prod_id =’FB’;<br>通配符只对第一个表使用，所有其他列明确列出，所以没有重复的列被检索出来。<br>外部联结：<br>许多联结将一个表中的行与另外一个表中的行相关联，但有时候会需要包含没有关联行的那些行，例如  可能需要使用联结来完成以下的工作：<br>1对每个客户下了多少订单进行计数，包括那些至今未下订单的客户。<br>2列出所有产品以及订购数量，包括没有人订购的产品<br>3计算平均销售规模，包括那些至今未下订单的客户<br>联结包含了那些在相关表中没有关联行的行，这种叫做外部联结<br>内部联结检索所有客户及其订单：<br>SELECT customers.cust_id,order.orders.order_num FROM customers INNER JOIN orders ON<br>Customers.cust_id =orders.cust_id;<br>外部联结：<br>SELECT customers.cust_id ,orders.order_num FROM customers LEFT OUTER JOIN oders<br>ON customers.cust_id =orders.cust_id;<br>输出为：<br> cust_id   order_num<br>  10001      20005<br>  10001      20009<br>  10002       null<br> 10003       null<br>此时必须要用RIGHT 或LEFT 关键字指定包括其所有行的表<br>其实就是左外部联结和右外部联结<br>16.3 使用带聚集函数的联结<br>使用了COUNT（）函数的联结<br>SELECT customers.cust_name, customers.cust_id,COUNT(orders.order_num) AS num_ord FROM customers INNER JOIN orders ON customers.cust_id =orders.cust_id GROUP BY customers.cust_id;<br>SELECT 语句使用INNER JOIN 将customers和orders 表互相关联。 GROUP BY 子句按客户分组数据。<br>聚集函数也可以方便地与其他联结一起使用，<br>如 SELECT customers,cust_name,cusomers,cust_id,COUNT(orders,order_num)AS num_ord FROM customers LEFT OUTER JOIN orders ON customers.cust_id =orders.cust_id  GROUP BY customers.cust_id;<br>17 章 组合查询<br>利用UNION 操作符将多条SELECT 语句组合成一个结果集<br>执行多个查询，多个SELECT 语句 并将结果作为单个查询结果集返回。<br>这种称为并（union）或复合查询<br>使用UNION<br>输入<br>SELECT vend_id ,prod_id ,prod_price FROM products WHERE prod_price &lt;=5<br>UNION<br>SELECT vend_id,prod_id,prod_price FROM products WHERE vend_id IN(1001,1002);<br>也可以使用多个where<br>SELECT vend_id ,prod_id,prod_price FROM products WHERE prod_price &lt;=5 OR vend_id IN<br>(1001,1002);<br>从多个表中检索数据的情形，使用UNION 可能会处理更简单。<br>17.2.2 UNION 规则<br> 1   UNION 的每个查询必须包含相同的列，表达式，或聚集函数</p>
<p> 2   UNION 的默认行为，如果想返回所有匹配行 可以使用UNION ALL 而不是UNION<br> 17.2.4 对组合查询结果排序<br>SELECT vend_id ,prod_id,prod_price FROM products WHERE prod_price &lt;=5<br>UNION<br>SELECT vend_id,prod_id,prod_price FROM products WHERE vend_id IN (1001,1002)<br>ORDER BY vend_id ,prod_price ;<br>18章 全文本搜素<br>18.1 理解全文本搜素</p>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>学习方法</title>
    <url>/2020/05/07/%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>学习方法</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><ul>
<li>慢一点，你理解的越多，需要记的就越少</li>
<li>勤做练习，自己记笔记</li>
<li>上床睡觉之前就不要再看别的书了，或者至少不能再看其他有难度的东西</li>
<li>要喝水，要多喝水</li>
<li>大声说出来</li>
<li>听听你的大脑怎么说（注意大脑是不是负荷太重）</li>
<li>要有点感觉（真正融入到书的故事中）</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>mysql联结表</title>
    <url>/2020/05/08/mysql%E8%81%94%E7%BB%93%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍联结以及高级联结。</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h2 id="创建联结"><a href="#创建联结" class="headerlink" title="创建联结"></a>创建联结</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SELECT vent_name,prod_name,prod_price </span><br><span class="line">FROM vendors ,products </span><br><span class="line">WHERE vendors.vend_id=products.vend_id;</span><br><span class="line">ORDER BY vend_name,prod_name ;</span><br></pre></td></tr></table></figure>

<h2 id="内部联结"><a href="#内部联结" class="headerlink" title="内部联结"></a>内部联结</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SELECT vend_name , prod_name , prod_price FROM vendors INNER JOIN products ON vendors.vend_id =products.vend_id ;</span><br></pre></td></tr></table></figure>

<p>此时使用的是INNER JOIN 联结条件用的是ON</p>
<p>联结多个表：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SELECT prod_name,vend_name,prod_price,quantity FROM orderitems,products,vendors WHERE products.vend_id =vendors.vend_id AND orderitems.prod_id =products.prod_id AND order_num =<span class="number">20005</span>;</span><br></pre></td></tr></table></figure>

<h2 id="创建高级联结"><a href="#创建高级联结" class="headerlink" title="创建高级联结"></a>创建高级联结</h2><h3 id="使用表别名"><a href="#使用表别名" class="headerlink" title="使用表别名"></a>使用表别名</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">SELECT <span class="title">Concat</span><span class="params">(RTrim(vend_name)，‘（’，RTrim（vend_country）,’）’)</span> AS vend_title FROM vendors ORDER BY vend_name</span>;</span><br></pre></td></tr></table></figure>

<h3 id="内部联结："><a href="#内部联结：" class="headerlink" title="内部联结："></a>内部联结：</h3><p>它基于俩个表之间的相等测试</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SELECT vend_name .prod_name,prod_price FROM vendors INNER JOIN products ON vendors.vend_id =produces.vend_id;</span><br></pre></td></tr></table></figure>

<h3 id="自联结：-引用别名，自己联结自己"><a href="#自联结：-引用别名，自己联结自己" class="headerlink" title="自联结： 引用别名，自己联结自己"></a>自联结： 引用别名，自己联结自己</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SELECT p1.prod_id,p1.prod_name FROM products AS p1,products AS p2</span><br><span class="line">WHERE p1.vend_id =p2.vend_id AND p2.prod_id =’DTNTR’;</span><br></pre></td></tr></table></figure>

<p>因此products 表在from 子句中出现了俩次。虽然这是合法的，但是对products 的引用具有二义性。因此使用了别名。（用自联结而不用子查询。有时候处理联结要比处理查询要快的多）</p>
<h3 id="自然联结"><a href="#自然联结" class="headerlink" title="自然联结"></a>自然联结</h3><p>其中你只能选择那些唯一的列。</p>
<p>通过对表使用通配符（SELECT *）对所有其他表的列使用明确的子集来完成的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SELECT c.*,o.ordr_num,o.order_date,oi.prod_id,oi.quantity,OI.item_price FROM customers AS c,orders AS o,orderitems AS oi WHERE c.cust_id =o.cust_id AND oi.order_num =o.order_num</span><br><span class="line">AND prod_id =’FB’;</span><br></pre></td></tr></table></figure>

<p>通配符只对第一个表使用，所有其他列明确列出，所以没有重复的列被检索出来。</p>
<h3 id="外部联结："><a href="#外部联结：" class="headerlink" title="外部联结："></a>外部联结：</h3><p>许多联结将一个表中的行与另外一个表中的行相关联，但有时候会需要包含没有关联行的那些行，例如 可能需要使用联结来完成以下的工作：</p>
<p>1对每个客户下了多少订单进行计数，包括那些至今未下订单的客户。</p>
<p>2列出所有产品以及订购数量，包括没有人订购的产品</p>
<p>3计算平均销售规模，包括那些至今未下订单的客户</p>
<p>联结包含了那些在相关表中没有关联行的行，这种叫做外部联结     </p>
<p>内部联结检索所有客户及其订单：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT customers.cust_id,order.orders.order_num FROM customers INNER JOIN orders ON</span><br><span class="line">Customers.cust_id &#x3D;orders.cust_id;</span><br></pre></td></tr></table></figure>

<p>外部联结：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SELECT customers.cust_id ,orders.order_num FROM customers LEFT OUTER JOIN oders </span><br><span class="line">ON customers.cust_id =orders.cust_id;</span><br></pre></td></tr></table></figure>

<p>输出为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cust_id   order_num</span><br><span class="line"> 10001      20005</span><br><span class="line"> 10001      20009</span><br><span class="line"> 10002       null</span><br><span class="line">10003       null</span><br></pre></td></tr></table></figure>

<p>此时必须要用RIGHT 或LEFT 关键字指定包括其所有行的表，其实就是左外部联结和右外部联结</p>
<h3 id="使用带聚集函数的联结"><a href="#使用带聚集函数的联结" class="headerlink" title="使用带聚集函数的联结"></a>使用带聚集函数的联结</h3><p>使用了COUNT（）函数的联结</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT customers.cust_name, customers.cust_id,COUNT(orders.order_num) AS num_ord FROM customers INNER JOIN orders ON customers.cust_id &#x3D;orders.cust_id GROUP BY customers.cust_id;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT customers,cust_name,cusomers,cust_id,COUNT(orders,order_num)AS num_ord FROM customers LEFT OUTER JOIN orders ON customers.cust_id &#x3D;orders.cust_id  GROUP BY customers.cust_id;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql插入数据</title>
    <url>/2020/05/07/mysql%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍如何利用SQL的INSERT语句将数据插入到表中</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h2 id="插入到完整的行"><a href="#插入到完整的行" class="headerlink" title="插入到完整的行"></a>插入到完整的行</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">INSERT INTO Customers</span><br><span class="line">VALUES(<span class="literal">NULL</span>,</span><br><span class="line">       'PEP E.LAPEW',</span><br><span class="line">       '100 MAIN STREET',</span><br><span class="line">        'Los Angeles',</span><br><span class="line">         'CA',</span><br><span class="line">        '90046',</span><br><span class="line">         'USA',</span><br><span class="line">          <span class="literal">NULL</span>,</span><br><span class="line">          <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>

<p>编写INSERT语句的更加安全（不过更加繁琐）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INSERT INTO customers(cust_name,cust_address,cust_city,cust_state,cust_zip,cust_country,cust_contact,cust_email)</span><br><span class="line">VALUSES(&#39;PEP E.LAPEW&#39;,</span><br><span class="line">       &#39;100 MAIN STREET&#39;,</span><br><span class="line">        &#39;Los Angeles&#39;,</span><br><span class="line">         &#39;CA&#39;,</span><br><span class="line">        &#39;90046&#39;,</span><br><span class="line">         &#39;USA&#39;,</span><br><span class="line">          NULL,</span><br><span class="line">          NULL&#39;);</span><br></pre></td></tr></table></figure>

<h3 id="省略列"><a href="#省略列" class="headerlink" title="省略列"></a>省略列</h3><ul>
<li>该列定义为允许null值</li>
<li>在表定义中给出默认值</li>
</ul>
<h3 id="提高整体性能"><a href="#提高整体性能" class="headerlink" title="提高整体性能"></a>提高整体性能</h3><p>如果数据检索是最重要的，那你可以通过在INSERT INTO 之间添加关键字</p>
<p>LOW_PRIORITY 指示Mysql降低INSERT语句的优先级</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INSERT LOW_PRIORITY INTO</span><br></pre></td></tr></table></figure>

<h2 id="插入多个行"><a href="#插入多个行" class="headerlink" title="插入多个行"></a>插入多个行</h2><figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="function">INSERT INTO <span class="title">customers</span><span class="params">(cust_name,cust_address,cust_city,cust_state,cust_zip,cust_country,cust_contact,cust_email)</span></span></span><br><span class="line">VALUSES('PEP E.LAPEW',</span><br><span class="line">       '100 MAIN STREET',</span><br><span class="line">        'Los Angeles',</span><br><span class="line">         'CA',</span><br><span class="line">        '90046',</span><br><span class="line">         'USA',</span><br><span class="line">          <span class="literal">NULL</span>,</span><br><span class="line">          NULL'),</span><br><span class="line">       ('PEP E.LAPEW',</span><br><span class="line">       '100 MAIN STREET',</span><br><span class="line">        'Los Angeles',</span><br><span class="line">         'CA',</span><br><span class="line">        '90046',</span><br><span class="line">         'USA',</span><br><span class="line">          <span class="literal">NULL</span>,</span><br><span class="line">          NULL');</span><br></pre></td></tr></table></figure>

<p>其中单条INSERT语句有多组值，每组值用一对圆括号括起来，用逗号分隔。</p>
<h3 id="插入检索出的数据"><a href="#插入检索出的数据" class="headerlink" title="插入检索出的数据"></a>插入检索出的数据</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="function">INSERT INTO <span class="title">customers</span><span class="params">(cust_id,cust_name,cust_address,cust_city,cust_state,cust_zip,cust_country,cust_contact,cust_email)</span></span></span><br><span class="line">SELECT cust_id,cust_name,cust_address,cust_city,cust_state,cust_zip,cust_country,cust_contact,cust_email FROM custnew;</span><br></pre></td></tr></table></figure>

<p>这个例子中INSERT SELECT 从custnew中将所有数据导入到customer中。</p>
<p><strong>其实MYSQL不关心SELECT返回的列名，它使用的是列的位置，因此SELECT中的第一列用来填充表列中指定的第一列</strong>。</p>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树</title>
    <url>/2020/05/07/%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本文。</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h2 id="二叉树的特点"><a href="#二叉树的特点" class="headerlink" title="二叉树的特点"></a>二叉树的特点</h2><ul>
<li><p>每个结点最多有俩颗子树。所以二叉树中不存在大于2的结点。</p>
</li>
<li><p>左子树和右子树是有顺序的，次序不能随意颠倒。</p>
</li>
<li><p>即使树中某结点只有一颗子树，也要区分它是左子树还是右子树</p>
<h3 id="二叉树的5种形态"><a href="#二叉树的5种形态" class="headerlink" title="二叉树的5种形态"></a>二叉树的5种形态</h3><ul>
<li>空二叉树</li>
<li>只有一个根结点</li>
<li>根节点只有左子树</li>
<li>根节点只有右子树</li>
<li>根节点既有左子树又有右子树</li>
</ul>
</li>
</ul>
<h2 id="特殊二叉树"><a href="#特殊二叉树" class="headerlink" title="特殊二叉树"></a>特殊二叉树</h2><ol>
<li><p>斜树</p>
<p>所有结点都只有左子树的二叉树叫做左斜树</p>
<p>所有结点都只有右子树的二叉树叫做右斜树</p>
<p>俩者统称为斜树</p>
</li>
<li><p>满二叉树</p>
<p>在一颗二叉树中，如果所有分支结点都存在左子树和右子树，并且所有叶子都在同一层上，这样的二叉树叫做满二叉树</p>
</li>
<li><p>完全二叉树</p>
<p>对一颗具有n个结点的二叉树按照层序编号，如果编号为i（1&lt;=i&lt;=n)的结点与同样深度的满二叉树中编号为i的结点在二叉树中位置完全相同，则这颗二叉树称为完全二叉树。</p>
</li>
</ol>
<h2 id="二叉树的性质"><a href="#二叉树的性质" class="headerlink" title="二叉树的性质"></a>二叉树的性质</h2><h3 id="二叉树性质1"><a href="#二叉树性质1" class="headerlink" title="二叉树性质1"></a>二叉树性质1</h3><p>性质1：在二叉树的第i层上至多有2^i-1 个结点。（i&gt;=1)</p>
<h3 id="二叉树性质2"><a href="#二叉树性质2" class="headerlink" title="二叉树性质2"></a>二叉树性质2</h3><p>性质2：深度为k的二叉树至多有2^k -1个结点 （k&gt;=1)</p>
<h3 id="二叉树性质3"><a href="#二叉树性质3" class="headerlink" title="二叉树性质3"></a>二叉树性质3</h3><p>性质3：对于任何一颗二叉树T，如果其终端结点数为n0，度为2的结点数为n2，则n0=n2+1</p>
<h3 id="二叉树性质4"><a href="#二叉树性质4" class="headerlink" title="二叉树性质4"></a>二叉树性质4</h3><p>性质4： 具有n个结点的完全二叉树的深度为[log2 n]+1 ([x]表示不大于x的最大整数)</p>
<h3 id="二叉树性质5"><a href="#二叉树性质5" class="headerlink" title="二叉树性质5"></a>二叉树性质5</h3><p>性质5： 如果对一颗有n个结点的完全二叉树（其深度为[log2 n]+1)的结点按层序编号，，对任一结点i（1&lt;=i&lt;=n)</p>
<p>有</p>
<ol>
<li>如果i=1,则结点i是二叉树的根</li>
</ol>
<h2 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h2><h2 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h2>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>DataStructure</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql更新和删除数据</title>
    <url>/2020/05/07/mysql%E6%9B%B4%E6%96%B0%E5%92%8C%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍如何利用UPDATA和DELETE语句进一步操控表数据</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h2 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h2><ul>
<li>更新特定行</li>
<li>更新所有行 <strong>特别注意不要省略WHERE子句 稍不注意就会更新表中的所有行</strong></li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">UPDATA customers SET cust_email ='elmer@gmail.com' WHERE cust_id =10005;</span><br></pre></td></tr></table></figure>

<p>更新多个列： 用逗号分隔</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">UPDATE customers SET cust_name='The Fudds',</span><br><span class="line">cust_email='elmer@gmail.com'</span><br><span class="line">WHERE cust_id =<span class="number">10005</span>;</span><br></pre></td></tr></table></figure>

<h3 id="IGNORE关键字"><a href="#IGNORE关键字" class="headerlink" title="IGNORE关键字"></a>IGNORE关键字</h3><p>如果用UPDATE 语句更新多行，并且在更新这些行中的一行或多行时出现一个现错误，则整个UPDATE操作被取消。</p>
<p>为即使是发生错误，也继续进行更新可以使用<strong>IGNORE</strong>关键字</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">UPDATE IGNORE customers...</span><br></pre></td></tr></table></figure>

<h2 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h2><ul>
<li>从表中删除特定的行</li>
<li>从表中删除所有行  <strong>不要省略WHERE子句</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">DELETE FROM customers WHERE cust_id =<span class="number">10006</span>;</span><br></pre></td></tr></table></figure>

<h3 id="更快的删除"><a href="#更快的删除" class="headerlink" title="更快的删除"></a>更快的删除</h3><p>如果想删除所有行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TRUNCATE TABLE</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>创建表和操控表</title>
    <url>/2020/05/08/%E5%88%9B%E5%BB%BA%E8%A1%A8%E5%92%8C%E6%93%8D%E6%8E%A7%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本章介绍表的创建，更改和删除的基本知识。</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2>]]></content>
  </entry>
  <entry>
    <title>指针</title>
    <url>/2020/05/04/%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<h1 id="10-1-指针变量"><a href="#10-1-指针变量" class="headerlink" title="10.1 指针变量"></a>10.1 指针变量</h1><p> 由于通过地址能访问指定的内存存储单元。可以说地址“指向”该内存单元。地址可以形象地称为指针，意思是通过指针能够找到内存单元。<br> <a id="more"></a></p>
<h2 id="1一个变量的地址称为该变量的指针，如果有一个变量专门用来存放另一个变量的地址，那么它就是指针变量。"><a href="#1一个变量的地址称为该变量的指针，如果有一个变量专门用来存放另一个变量的地址，那么它就是指针变量。" class="headerlink" title="1一个变量的地址称为该变量的指针，如果有一个变量专门用来存放另一个变量的地址，那么它就是指针变量。"></a>1一个变量的地址称为该变量的指针，如果有一个变量专门用来存放另一个变量的地址，那么它就是指针变量。</h2><p>一般形式为：<br>类型说明 * 变量名<br>int * q;<br>C语言中提供了地址运算符“&amp;”来表示变量的地址。其中一般形式为：<br>&amp;变量名;</p>
<h2 id="2给指针变量赋值一般有俩个方法"><a href="#2给指针变量赋值一般有俩个方法" class="headerlink" title="2给指针变量赋值一般有俩个方法"></a>2给指针变量赋值一般有俩个方法</h2><p>1   </p>
<pre><code>int a;
int *p=&amp;a</code></pre><p>2       </p>
<pre><code>int a;
int *p;
p=&amp;a;</code></pre><h2 id="3-指针变量的引用"><a href="#3-指针变量的引用" class="headerlink" title="3 指针变量的引用"></a>3 指针变量的引用</h2><p>引用指针变量是对变量进行间接访问的一种形式</p>
<p>对指针变量的引用形式如下：</p>
<p>*指针变量 其含义是引用指针变量所指向的值</p>
<h2 id="4-amp-和-的区别"><a href="#4-amp-和-的区别" class="headerlink" title="4 &amp; 和 *的区别"></a>4 &amp; 和 *的区别</h2><p> &amp;运算符是一个返回操作数地址的单目运算符，叫做取地址运算符</p>
<p> *运算符是返回指定的地址内的变量的值，叫做指针运算符。</p>
<h2 id="5-指针自增和自减运算"><a href="#5-指针自增和自减运算" class="headerlink" title="5 指针自增和自减运算"></a>5 指针自增和自减运算</h2><p>基本整型变量i在内存中占4个字节，指针P是指向变量i的地址的，p++是指向下一个存放基本整型数的地址。</p>
<h2 id="6-数组与指针"><a href="#6-数组与指针" class="headerlink" title="6 数组与指针"></a>6 数组与指针</h2><p>在定义一个一维数组时，系统会在内存中为该数组分配一个存储空间，其数组的名称就是数组在内存中的首地址。<br>例如：</p>
<p>1      </p>
<pre><code>int *p,a[10]; 
 p=a;</code></pre><p>或</p>
<p>2   </p>
<pre><code>int *p,a[10]; 
p=&amp;a[0];</code></pre><h2 id="7-二维数组与指针"><a href="#7-二维数组与指针" class="headerlink" title="7 二维数组与指针"></a>7 二维数组与指针</h2><p>表示二维数组中元素地址的方法：</p>
<p>&amp;a[0][0]可以看作数组0行0列的首地址，也可以看作二维数组的首地址。</p>
<p>&amp;a[m][n]就是第m行n列元素的地址。而a[0]+n表示第0行第n个元素的地址。</p>
<h2 id="8指针变量作为函数参数"><a href="#8指针变量作为函数参数" class="headerlink" title="8指针变量作为函数参数"></a>8指针变量作为函数参数</h2><p>指针变量也可以作为函数参数</p>
<p>例<br>在swap（int <em>a,int</em> b)中</p>
<p>在函数调用的过程中，主调用函数与被调用函数之间有一个数值传递的过程。函数调用中发生的数据传递是单向的，只能把实际参数的值传递给形式参数，在函数调用的过程中，形式参数的值发生改变，但是实际参数的值不会发生变化。如果swap(int a,int b) 则不能实现x与y值的互换。</p>
<p>通过指针传递参数可以减少值传递带来的开销，也可以使函数调用不产生值传递。</p>
<h2 id="9返回指针值的函数"><a href="#9返回指针值的函数" class="headerlink" title="9返回指针值的函数"></a>9返回指针值的函数</h2><p>返回的值的类型为指针类型，返回指针值的函数简称为指针函数</p>
<p>定义指针函数的一般形式为 </p>
<p>类型名 *函数名（参数列表） </p>
<p>如   int *fun(int x,int y)</p>
<p>如 </p>
<pre><code>int *per(int a,int b)
{
 int *p;
 p=&amp;Perimeter;
 Perimeter=(a+b)*2;
 return p; 
}</code></pre>]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>树</title>
    <url>/2020/05/07/%E6%A0%91/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>树的相关概念</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h2 id="树的相关概念"><a href="#树的相关概念" class="headerlink" title="树的相关概念"></a>树的相关概念</h2><h3 id="度"><a href="#度" class="headerlink" title="度"></a>度</h3><ul>
<li>结点拥有的子树树称为结点的度</li>
<li>度为0的结点称为叶结点（Leaf）或者终端结点。</li>
<li>度不为0的结点称为非终端结点或者分支结点</li>
<li>树的度是树内各结点度的最大值</li>
</ul>
<h3 id="深度（Depth-或高度"><a href="#深度（Depth-或高度" class="headerlink" title="深度（Depth)或高度"></a>深度（Depth)或高度</h3><ul>
<li>层次：结点的层次从根开始定义起，根为第一层，根的孩子为第二层，以此类推</li>
<li>树中结点的最大层次被称为树的深度（Depth）或者高度。</li>
</ul>
<h3 id="有序树和无序树"><a href="#有序树和无序树" class="headerlink" title="有序树和无序树"></a>有序树和无序树</h3><p>如果将树中结点的各子树看成从左至右是由次序的，不能互换的，那么该树为有序树，否则为无序树。</p>
<h3 id="森林"><a href="#森林" class="headerlink" title="森林"></a>森林</h3><p>森林是m（m&gt;=0)颗互不相交的树的集合。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>DataStructure</tag>
      </tags>
  </entry>
  <entry>
    <title>时间复杂度</title>
    <url>/2020/05/05/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/</url>
    <content><![CDATA[<h1 id="算法时间复杂度"><a href="#算法时间复杂度" class="headerlink" title="算法时间复杂度"></a>算法时间复杂度</h1><h2 id="算法时间复杂度定义"><a href="#算法时间复杂度定义" class="headerlink" title="算法时间复杂度定义"></a>算法时间复杂度定义</h2><ul>
<li><p>O()来体现算法时间复杂度的记法</p>
<a id="more"></a>

<h2 id="推导大O阶的方法"><a href="#推导大O阶的方法" class="headerlink" title="推导大O阶的方法"></a>推导大O阶的方法</h2><ol>
<li><p>用常数1代替所有加法常数</p>
</li>
<li><p>在修改后的运行次数函数中，只保留最高阶项</p>
</li>
<li><p>如果最高阶项存在且不是1，则去除这个项相乘的常数</p>
<p>得到的结果就是大O阶.</p>
<h3 id="举例说明："><a href="#举例说明：" class="headerlink" title="举例说明："></a>举例说明：</h3><h4 id="常数阶"><a href="#常数阶" class="headerlink" title="常数阶"></a>常数阶</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> sum=<span class="number">0</span>,n=<span class="number">100</span>; <span class="comment">//执行1次</span></span><br><span class="line">sum=(<span class="number">1</span>+n)*n/<span class="number">2</span>; <span class="comment">//执行2次</span></span><br><span class="line">sum=(<span class="number">1</span>+n)*n/<span class="number">2</span>; <span class="comment">//</span></span><br><span class="line">sum=(<span class="number">1</span>+n)*n/<span class="number">2</span>; <span class="comment">//</span></span><br><span class="line">sum=(<span class="number">1</span>+n)*n/<span class="number">2</span>; <span class="comment">//</span></span><br><span class="line">...</span><br><span class="line">sum=(<span class="number">1</span>+n)*n/<span class="number">2</span>; <span class="comment">//执行10次</span></span><br></pre></td></tr></table></figure>

<p>事实上无论n为多少，上面代码就是1次，2次，10次的差别，这种与问题大小无关（与n的大小无关）执行时间恒定的算法。称为O(1)阶，又叫常数阶</p>
<h4 id="线性阶"><a href="#线性阶" class="headerlink" title="线性阶"></a>线性阶</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 时间复杂度为O(1)的程序     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
</li>
</ul>
<p>​               循环的时间复杂度为O(n)</p>
<h4 id="对数阶"><a href="#对数阶" class="headerlink" title="对数阶"></a>对数阶</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int count&#x3D;1;</span><br><span class="line">while (count &lt;n)</span><br><span class="line">&#123;</span><br><span class="line">count &#x3D;count *2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2^x=n  x=log2 n   所以这个循环的时间复杂度为O(log n).</p>
<h4 id="平方阶"><a href="#平方阶" class="headerlink" title="平方阶"></a>平方阶</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i,j;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">/*时间复杂度为O(1)的程序步骤序列      */</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度为O(m*n)</p>
<p>又如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i,j;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(j=i;j&lt;n;j++)</span><br><span class="line">&#123;</span><br><span class="line"> <span class="comment">/* 时间复杂度为O(1)的程序*/</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行总次数 n+n-1+(n-2)+…+1=n(n+1)/2   时间复杂度为O(n^2) </p>
<h4 id="常见的时间复杂度"><a href="#常见的时间复杂度" class="headerlink" title="常见的时间复杂度"></a>常见的时间复杂度</h4><p>常用时间复杂度耗费时间比对：</p>
<p>O(1)&lt;O(log n)&lt;O(n)&lt;O(nlogn)&lt;O(n^2)&lt;O(n^3)&lt;O(2^n)&lt;O(n!)&lt;O(n^n)</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>DataStructure</tag>
      </tags>
  </entry>
  <entry>
    <title>线性表</title>
    <url>/2020/05/05/%E7%BA%BF%E6%80%A7%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h1><h2 id="线性表的定义："><a href="#线性表的定义：" class="headerlink" title="线性表的定义："></a>线性表的定义：</h2><ul>
<li>线性表：零个或多个数据元素的有限序列</li>
<li>线性表元素的个数n 定义为线性表的长度，当n=0时，称为空表<a id="more"></a>

</li>
</ul>
<h2 id="线性表的顺序存储结构"><a href="#线性表的顺序存储结构" class="headerlink" title="线性表的顺序存储结构"></a>线性表的顺序存储结构</h2><ul>
<li><p>顺序存储定义： 线性表的顺序存储结构，指的是用一段地址连续的存储单元依次存储线性表的数据元素</p>
<h3 id="顺序存储方式"><a href="#顺序存储方式" class="headerlink" title="顺序存储方式"></a>顺序存储方式</h3><ul>
<li><p>顺序存储的结构代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 20 </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemType data[MAXSIZE];</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">&#125;SqList;</span><br></pre></td></tr></table></figure>

<p>MAXSIZE：数组长度</p>
<p>length： 线性表当前的长度</p>
<p>另外以数组data进行存储</p>
</li>
<li><p>线性表中的地址</p>
<p>存储器中的每个存储单元都有自己的编号，这个编号称为地址。</p>
<h3 id="顺序存储结构的插入与删除"><a href="#顺序存储结构的插入与删除" class="headerlink" title="顺序存储结构的插入与删除"></a>顺序存储结构的插入与删除</h3><h4 id="获得元素操作"><a href="#获得元素操作" class="headerlink" title="获得元素操作"></a>获得元素操作</h4><p>我们实现GetElem操作，即把线性表L中的第i个元素值返回。只要i的数值在数组范围内，就是把数组的第i-1下标返回即可。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR 0 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status; <span class="comment">/*函数的类型 */</span></span><br><span class="line"><span class="function">Status <span class="title">GetElem</span><span class="params">(SqList L,<span class="keyword">int</span> i,ElemType *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L.length==<span class="number">0</span> ||i&lt;<span class="number">1</span> ||i&gt;L.length)</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    *e=L.data[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h4><p>算法思路：</p>
<ul>
<li><p>插入位置不合理</p>
</li>
<li><p>线性表长度大于数组长度</p>
</li>
<li><p>从最后一个元素遍历到第i个元素</p>
</li>
<li><p>将要插入的元素填到位置i处</p>
</li>
<li><p>表长+1</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ListInsert</span><span class="params">(SqList *L,<span class="keyword">int</span> i,ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> k;</span><br><span class="line"><span class="keyword">if</span>(L-&gt;length==MAXSIZE)</span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line"><span class="keyword">if</span>(i&lt;<span class="number">1</span>||i&gt;L-&gt;length+<span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line"><span class="keyword">if</span>(i&lt;=L-&gt;length)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(k=L-&gt;length<span class="number">-1</span>;k&gt;=i<span class="number">-1</span>;k--)</span><br><span class="line">&#123;</span><br><span class="line">L-&gt;data[k+<span class="number">1</span>]=L-&gt;data[k];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">L-&gt;data[i<span class="number">-1</span>]=e;</span><br><span class="line">L-&gt;length++;</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>DataStructure</tag>
      </tags>
  </entry>
  <entry>
    <title>链表</title>
    <url>/2020/05/07/%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>线性表的链式存储结构详解</p>
</blockquote>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>单链表存储状态图示：</p>
<p>Node由存放数据元素的数据域和存放后继结点地址的指针域组成。</p>
<p>头结点的数据域可以不存储任何信息。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">ElemType data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;Node;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">LinkList</span>;</span></span><br></pre></td></tr></table></figure>

<p>假设p是指向线性表第i个元素的指针，则该结点ai的数据域 可以用p-&gt;data 来表示</p>
<p>结点ai的指针域用p-&gt;next来表示。p-&gt;next指向第i-1个元素，即指向ai+1的指针。即p-&gt;data=ai</p>
<p>那么p-&gt;next-&gt;data=ai+1</p>
<p><img src="/2020/05/07/%E9%93%BE%E8%A1%A8/%E9%93%BE%E8%A1%A801.png" alt></p>
<h2 id="单链表的读取"><a href="#单链表的读取" class="headerlink" title="单链表的读取"></a>单链表的读取</h2><p>算法思路：<br>从第一个头结点开始，指针域p-&gt; next一直向下指向第i个元素的指针域。</p>
<ol>
<li>声明指针p指向链表的第一个结点 ，初始化从1开始</li>
<li>当j&lt;i时就遍历链表，p不断向后移动，j++</li>
<li>当链表末尾p为空时，则说明第i个结点不存在</li>
<li>若查找成功，那么返回结点p的数据。</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">GetElem</span><span class="params">(LinkList L,<span class="keyword">int</span> i,ElemType *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> j;</span><br><span class="line">  LinkList p;</span><br><span class="line">  p=L-&gt;next;</span><br><span class="line">  j=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(p&amp;&amp;j&lt;i)</span><br><span class="line">  &#123;</span><br><span class="line">  p=p-&gt;next;</span><br><span class="line">  j++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(!p || j&gt;<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">  <span class="keyword">return</span> ERROR；</span><br><span class="line">  *e=p-&gt;data;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="单链表的插入与删除"><a href="#单链表的插入与删除" class="headerlink" title="单链表的插入与删除"></a>单链表的插入与删除</h2><h3 id="单链表插入"><a href="#单链表插入" class="headerlink" title="单链表插入"></a>单链表插入</h3><p>思路：在俩节点之间再插入一个结点</p>
<p>图示：</p>
<p><img src="/2020/05/07/%E9%93%BE%E8%A1%A8/%E9%93%BE%E8%A1%A802.png" alt></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">s-&gt;next=p-&gt;next;</span><br><span class="line">p-next=s;   <span class="comment">/*单链表插入标准语句 */</span></span><br></pre></td></tr></table></figure>

<p>实现插入操作的具体思路：</p>
<ol>
<li></li>
<li></li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ListInsert</span><span class="params">(LinkList *L,<span class="keyword">int</span> i,ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(p&amp;&amp;j&lt;i)</span><br><span class="line">    &#123;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">        ++j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!p||j&gt;i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    s=(LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    s-&gt;data=e;</span><br><span class="line">    s-&gt;next=p-&gt;next;</span><br><span class="line">    p-&gt;next=s;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>malloc  函数，生成一个新的结点，其类型与Node一样的，其实质就是在内存中找一小块空地，准备用来存放数据e的s结点。</p>
<h2 id="单链表的删除："><a href="#单链表的删除：" class="headerlink" title="单链表的删除："></a>单链表的删除：</h2><p>图示：</p>
<p><img src="/2020/05/07/%E9%93%BE%E8%A1%A8/%E9%93%BE%E8%A1%A803.png" alt></p>
<p>实际上就是p-&gt;next=p-&gt;next-&gt;next;</p>
<p>如果用q来表示p-&gt;next即</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">q=p-&gt;next;</span><br><span class="line">p-&gt;next=q-&gt;next;</span><br></pre></td></tr></table></figure>

<p>思路：</p>
<p>具体实现代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ListDelete</span><span class="params">(LinkList *L,<span class="keyword">int</span> i,ElemType *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> j;</span><br><span class="line">LinkList p,q;</span><br><span class="line">p=*L;</span><br><span class="line">j=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(p-&gt;next &amp;&amp; j&lt;i)</span><br><span class="line">&#123;</span><br><span class="line">p=p-&gt;next;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!(p-&gt;next)||j&gt;i)</span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line">q=p-&gt;next;</span><br><span class="line">p-&gt;next=q-&gt;next;</span><br><span class="line">*e=q-&gt;data;</span><br><span class="line"><span class="built_in">free</span>(q);<span class="comment">/* 回收一个Node结点 */</span></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>DataStructure</tag>
      </tags>
  </entry>
</search>
