<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>@ResponseBody</title>
      <link href="/2020/07/28/ResponseBody/"/>
      <url>/2020/07/28/ResponseBody/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>本章介绍</p></blockquote><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>@ResponseBody是作用在方法上的，@ResponseBody 表示该方法的返回结果直接写入 HTTP response body 中，一般在异步获取数据时使用【也就是AJAX】，在使用 @RequestMapping后，返回值通常解析为跳转路径，但是加上 @ResponseBody 后返回结果不会被解析为跳转路径，而是直接写入 HTTP response body 中。 比如异步获取 json 数据，加上 @ResponseBody 后，会直接返回 json 数据。@RequestBody 将 HTTP 请求正文插入方法中，使用适合的 HttpMessageConverter 将请求体写入某个对象。</p><p> 在使用springmvc框架的时候，在处理json的时候需要用到spring框架特有的注解@ResponseBody或者@RestController注解，这两个注解都会处理返回的数据格式，使用了该类型注解后返回的不再是视图，不会进行转跳，而是返回json或xml数据格式，输出在页面上。</p><p>  那么，这两个注解在使用上有什么区别呢？</p><p>  @ResponseBody，一般是使用在单独的方法上的，需要哪个方法返回json数据格式，就在哪个方法上使用，具有针对性。</p><p>  @RestController，一般是使用在类上的，它表示的意思其实就是结合了@Controller和@ResponseBody两个注解，</p><p>如果哪个类下的所有方法需要返回json数据格式的，就在哪个类上使用该注解，具有统一性；需要注意的是，使用了@RestController注解之后，其本质相当于在该类的所有方法上都统一使用了@ResponseBody注解，所以该类下的所有方法都会返回json数据格式，输出在页面上，而不会再返回视图。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>continue</title>
      <link href="/2020/07/27/continue/"/>
      <url>/2020/07/27/continue/</url>
      
        <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/qq_32452623/article/details/51488658">https://blog.csdn.net/qq_32452623/article/details/51488658</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>待学习的点</title>
      <link href="/2020/07/24/%E5%BE%85%E5%AD%A6%E4%B9%A0%E7%9A%84%E7%82%B9/"/>
      <url>/2020/07/24/%E5%BE%85%E5%AD%A6%E4%B9%A0%E7%9A%84%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>本章介绍</p></blockquote><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>自动化测试手册</title>
      <link href="/2020/07/24/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%89%8B%E5%86%8C/"/>
      <url>/2020/07/24/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%89%8B%E5%86%8C/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>本章介绍自动化测试手册</p></blockquote><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络概述</title>
      <link href="/2020/07/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/"/>
      <url>/2020/07/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>本章介绍计算机网络概述</p></blockquote><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>1 局域网 </p><blockquote></blockquote><p><img src="https://photos.alitaalice.cn/image/20200712204915.png" alt=""></p><p>2 Internet</p><p>  <img src="https://photos.alitaalice.cn/image/20200712205323.png" alt=""></p><p>1 公司在电信网通之类的机房托管自己的服务器，电信机房给它分配ip地址。</p><p>2我们公司通过自己的服务器，用光纤连接到运营商。</p><p>3 我们通过ADSL上网呢</p><p>4 Internet ISP运营商组成，有自己的机房，为网民提供访问Internet</p><h2 id="局域网"><a href="#局域网" class="headerlink" title="局域网"></a>局域网</h2><p><img src="https://photos.alitaalice.cn/image/20200712205640.png" alt=""></p><h2 id="广域网"><a href="#广域网" class="headerlink" title="广域网"></a>广域网</h2><p><img src="https://photos.alitaalice.cn/image/20200712205722.png" alt=""></p><p>距离远，超过100M，花钱租带宽，其他人维护</p><p>ADSL 只是其中一种</p><p>也包括光纤</p><p>为什么访问 有的地址快，有点地址慢</p><p>4  浏览网站的过程</p><p>  DNS 解析域名为IP地址</p><p> 网络部分，主机部分  </p><p> IP地址  子网掩码</p><p>网关 ：配置网关 15.0.0.1</p><p>路由器 ：在不同网段转发数据            15.0.0.1 路由器接口的地址 </p><p>MAC：网卡 出厂就被固定  又叫物理地址  48位2进制  全球唯一</p><p><img src="C:%5CUsers%5C16508%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200712210430808.png" alt="image-20200712210430808"></p><p><img src="https://photos.alitaalice.cn/image/20200712210758.png" alt=""></p><h2 id="7层架构"><a href="#7层架构" class="headerlink" title="7层架构"></a>7层架构</h2><p>1  应用层</p><p>2 表示层  </p><p>3 会话层  网站和网站之间的会话  查木马 netstat -nb</p><p>4 传输层 </p><p><img src="https://photos.alitaalice.cn/image/20200716082223.png" alt=""></p><p><img src="https://photos.alitaalice.cn/image/20200716083347.png" alt=""></p><p>5 MAC冲突  </p><p><img src="https://photos.alitaalice.cn/image/20200716091319.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>互联网概述</title>
      <link href="/2020/07/11/%E4%BA%92%E8%81%94%E7%BD%91%E6%A6%82%E8%BF%B0/"/>
      <url>/2020/07/11/%E4%BA%92%E8%81%94%E7%BD%91%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>本章介绍</p></blockquote><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p><img src="https://photos.alitaalice.cn/image/20200711212626.png" alt=""></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>stream</title>
      <link href="/2020/07/09/stream/"/>
      <url>/2020/07/09/stream/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>本章介绍</p></blockquote><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>序列化</title>
      <link href="/2020/07/09/%E5%BA%8F%E5%88%97%E5%8C%96/"/>
      <url>/2020/07/09/%E5%BA%8F%E5%88%97%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>本章介绍</p></blockquote><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>I/O</title>
      <link href="/2020/07/09/I-O/"/>
      <url>/2020/07/09/I-O/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>本章介绍</p></blockquote><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>工厂模式详解</title>
      <link href="/2020/07/09/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/"/>
      <url>/2020/07/09/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>本章介绍</p></blockquote><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ajax</title>
      <link href="/2020/07/06/ajax/"/>
      <url>/2020/07/06/ajax/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>本章介绍ajax</p></blockquote><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p><a href="https://www.cnblogs.com/Lighting-Sui/p/11494298.html">https://www.cnblogs.com/Lighting-Sui/p/11494298.html</a></p><p>JSON.stringify() 方法用于将 JavaScript 值转换为 JSON 字符串。</p><p>bootstraptable</p><p><a href="https://www.jianshu.com/p/b9d0f0935263">https://www.jianshu.com/p/b9d0f0935263</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>各种注解</title>
      <link href="/2020/07/03/%E5%90%84%E7%A7%8D%E6%B3%A8%E8%A7%A3/"/>
      <url>/2020/07/03/%E5%90%84%E7%A7%8D%E6%B3%A8%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>本章介绍各种注解</p></blockquote><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@RequestBody</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@ResponseBody</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@PostMapping</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>@RequestParam注解使用</title>
      <link href="/2020/06/29/RequestParam%E6%B3%A8%E8%A7%A3%E4%BD%BF%E7%94%A8/"/>
      <url>/2020/06/29/RequestParam%E6%B3%A8%E8%A7%A3%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>本章介绍@RequestParam注解使用</p></blockquote><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p><a href="https://blog.csdn.net/sswqzx/article/details/84195043">https://blog.csdn.net/sswqzx/article/details/84195043</a></p>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GetMapping和PostMapping的区别</title>
      <link href="/2020/06/29/GetMapping%E5%92%8CPostMapping%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2020/06/29/GetMapping%E5%92%8CPostMapping%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>本章介绍GetMapping和PostMapping的区别</p></blockquote><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>最近刚学完三大框架，回过头来做东西发现很多东西都忘了，GET\POST是有区别的<br>spring4.3中引进了｛@GetMapping、@PostMapping、@PutMapping、@DeleteMapping、@PatchMapping｝，来帮助简化常用的HTTP方法的映射，并更好地表达被注解方法的语义。<br>以@GetMapping为例，Spring官方文档说：<br>@GetMapping是一个组合注解，是@RequestMapping(method = RequestMethod.GET)的缩写。该注解将HTTP Get 映射到 特定的处理方法上。</p><p>以下是官方解释，供大家参考：</p><p>哪一些情况下，浏览器会发送get请求</p><ol><li><p>直接在浏览器地址栏输入某个地址</p></li><li><p>点击链接</p></li><li><p>表单默认的提交方式</p></li></ol><p>哪一些情况下，浏览器会发送post请求？</p><ol><li>设置表单method = “post”</li></ol><p>get请求的特点</p><ol><li><p>请求参数会添加到请求资源路劲的后面，只能添加少量参数（因为请求行只有一行，大约只能存放2K左右的数据）（2K左右的数据，看起来也不少。。。）</p></li><li><p>请求参数会显示在浏览器地址栏，路由器会记录请求地址</p></li></ol><p>post请求的特点</p><ol><li><p>请求参数添加到实体内容里面，可以添加大量的参数（也解释了为什么浏览器地址栏不能发送post请求，在地址栏里我们只能填写URL，并不能进入到Http包的实体当中）</p></li><li><p>相对安全，但是，post请求不会对请求参数进行加密处理（可以使用https协议来保证数据安全）。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XPath的使用</title>
      <link href="/2020/06/21/XPath%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2020/06/21/XPath%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>本章介绍XPath</p></blockquote><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h2 id="XPath的使用"><a href="#XPath的使用" class="headerlink" title="XPath的使用"></a>XPath的使用</h2><p>XPath，全称 XML Path Language，即 XML 路径语言，它是一门在XML文档中查找信息的语言。XPath 最初设计是用来搜寻XML文档的，但是它同样适用于 HTML 文档的搜索。</p><p>所以在做爬虫时，我们完全可以使用 XPath 来做相应的信息抽取，本节我们来介绍一下 XPath 的基本用法。</p><h2 id="1-XPath概览"><a href="#1-XPath概览" class="headerlink" title="1. XPath概览"></a>1. XPath概览</h2><p>XPath 的选择功能十分强大，它提供了非常简洁明了的路径选择表达式，另外它还提供了超过 100 个内建函数用于字符串、数值、时间的匹配以及节点、序列的处理等等，几乎所有我们想要定位的节点都可以用XPath来选择。</p><p>XPath 于 1999 年 11 月 16 日 成为 W3C 标准，它被设计为供 XSLT、XPointer 以及其他 XML 解析软件使用，更多的文档可以访问其官方网站：<a href="https://link.zhihu.com/?target=https%3A//www.w3.org/TR/xpath/">https://www.w3.org/TR/xpath/</a>。</p><h2 id="2-XPath常用规则"><a href="#2-XPath常用规则" class="headerlink" title="2. XPath常用规则"></a>2. XPath常用规则</h2><p>我们现用表格列举一下几个常用规则：</p><p>表达式描述<br>nodename选取此节点的所有子节点<br>/从当前节点选取直接子节点<br>//从当前节点选取子孙节点<br>.选取当前节点<br>..选取当前节点的父节点<br>@选取属性</p><p>在这里列出了XPath的常用匹配规则，例如 / 代表选取直接子节点，// 代表选择所有子孙节点，. 代表选取当前节点，.. 代表选取当前节点的父节点，@ 则是加了属性的限定，选取匹配属性的特定节点。</p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;title[@lang&#x3D;’eng’]</span><br></pre></td></tr></table></figure><p>这就是一个 XPath 规则，它就代表选择所有名称为 title，同时属性 lang 的值为 eng 的节点。</p><p>在后文我们会介绍 XPath 的详细用法，通过 Python 的 LXML 库利用 XPath 进行 HTML 的解</p>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dom节点</title>
      <link href="/2020/06/18/dom%E8%8A%82%E7%82%B9/"/>
      <url>/2020/06/18/dom%E8%8A%82%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>本章介绍</p></blockquote><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>1 </p><p><img src="https://photos.alitaalice.cn/image/20200618090133.png" alt=""></p><p>2 <img src="https://photos.alitaalice.cn/image/20200618090722.png" alt=""></p><p>3 article 和 aside 是 html5 的新标签。前段时间我刚学 html5 ，也是看的视频，刚开始不太明白，后来也想通了。html5 是什么呢？是 html 的升级版，在标签和功能上增强了，说到底还是 html 。html 又是什么呢？html 只是标签，a 就是锚点，p 就是段落，img 就是图片，我们按照这些规定来组织页面，他们本身只是标签，除此之外，没有任何意义，标签的背景颜色是什么，那是 css 的事，标签点击后出现什么效果，那时 js 的事。html 标签有几种分类，其中有一种就是网页布局性质的标签，如最常用的 div。抛开以前的传统网页布局（table布局）不谈，就说现在的网页布局——div+css。你比如说，你要做一个最简单的一行两列的网页，外层是一个 div 容器，里面两个 div，左边是导航菜单，右边是内容，为了实现网页布局，你肯定得用 css 定位，为了方便定位，你肯定得为 div 设置 id 或者 class，我们暂且用 id。外层容器 div ：id=”wrap”，内层左边 div：id=”aside”，内层右边 div：id=”article”。为什么左边导航 id 要给它设置为 aside（旁边），而不用 div1、div2 呢？因为 aside 赋予了 div 意义，给当前开发者和后期维护者带来方便，一看到 <div id="aside"> 我就知道它的作用，看到 <div id="div1"> 谁知道这是什么东西，就像 div 标签本身一样，毫无意义。而 article 和 aside 就像 div 一样，只是布局标签，除了标签名字不一样，其他功能意义基本是一样的，article、aside 里面的字体、背景、边框等没有任何特殊的样式，也不是鼠标点击了 aside 标签之后会出现什么特殊的效果，因为它们只是简简单单的标签。既然功能和 div 一模一样，html5 为何多此一举，又生产出几个多余的 “div” 出来呢？有句话叫做：存在的就是合理的。因为很多网站布局是重复的，全世界网站有很多都是左边是导航，右边是正文内容，然后给div设置id来用css布局，因为有这个需求，html5 就人性化的添加了几个标签，从而简化了开发人员的开发，毕竟，<aside> 与 <div id="aside">，那个更好？html 角度：前者比后者少写几行代码，一定程度简化了网页文件大小。css 角度：前者直接使用 aside 就能获取到标签，后者需要通过 id 。js 角度：同上。之前也听说过这么一个消息，说一些移动设备（如 ipad），在解析 html5 标签时，遇到 aside 标签可能会有个性化的展示，可能效果更美观。总结：<article> 你就看做是 <div id="article">，<aside> 你就看做是 <div id="aside">，仅仅是人为的给div 换了一个说话，换汤不换药，还是 div 。</p><p>4 ul  无序列表</p><p><a> 标签中的target=_blank</p><p>_self相同框架<br>_top整页<br>_blank新建一个窗口<br>_parent父窗口<br>其它的就是自定义了，可以指向已有的窗口名称</p><p><img src="https://photos.alitaalice.cn/image/20200619085109.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> html </category>
          
      </categories>
      
      
        <tags>
            
            <tag> html </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>volatile关键字</title>
      <link href="/2020/06/16/volatile%E5%85%B3%E9%94%AE%E5%AD%97/"/>
      <url>/2020/06/16/volatile%E5%85%B3%E9%94%AE%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>本章介绍</p></blockquote><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>1 </p>]]></content>
      
      
      <categories>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发编程第一章知识点</title>
      <link href="/2020/06/16/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AC%AC%E4%B8%80%E7%AB%A0%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
      <url>/2020/06/16/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AC%AC%E4%B8%80%E7%AB%A0%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>本章介绍并发编程第一章知识点</p></blockquote><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>1 进程和线程的区别</p><p>看了一遍排在前面的答案，类似”<strong>进程是资源分配的最小单位，线程是CPU调度的最小单位“</strong>这样的回答感觉太抽象，都不太容易让人理解。</p><p>做个简单的比喻：进程=火车，线程=车厢</p><ul><li>线程在进程下行进（单纯的车厢无法运行）</li><li>一个进程可以包含多个线程（一辆火车可以有多个车厢）</li><li>不同进程间数据很难共享（一辆火车上的乘客很难换到另外一辆火车，比如站点换乘）</li><li>同一进程下不同线程间数据很易共享（A车厢换到B车厢很容易）</li><li>进程要比线程消耗更多的计算机资源（采用多列火车相比多个车厢更耗资源）</li><li>进程间不会相互影响，一个线程挂掉将导致整个进程挂掉（一列火车不会影响到另外一列火车，但是如果一列火车上中间的一节车厢着火了，将影响到所有车厢）</li><li>进程可以拓展到多机，进程最多适合多核（不同火车可以开在多个轨道上，同一火车的车厢不能在行进的不同的轨道上）</li><li>进程使用的内存地址可以上锁，即一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。（比如火车上的洗手间）－”互斥锁”</li><li>进程使用的内存地址可以限定使用量（比如火车上的餐厅，最多只允许多少人进入，如果满了需要在门口等，等有人出来了才能进去）－“信号量”</li></ul><p>\2. 竞态</p><p>p15</p><p>\3. 竞态的两种模式</p><p>\4. 原子性</p><p>p15</p><p>\5. java实现原子性</p><p>\6. 可见性</p><p>可见性是指当一个线程修改了共享变量后，其他线程能够立即得知这个修改。通过之前对<a href="https://www.jianshu.com/p/d53bf830fa09">synchronzed</a>内存语义进行了分析，当线程获取锁时会从主内存中获取共享变量的最新值，释放锁的时候会将共享变量同步到主内存中。从而，<strong>synchronized具有可见性</strong>。同样的在<a href="https://www.jianshu.com/p/157279e6efdb">volatile分析中</a>，会通过在指令中添加<strong>lock指令</strong>，以实现内存可见性。因此, <strong>volatile具有可见性</strong></p><p>\7. 重排序</p><p>\8.  锁的概述</p><p>\9.  锁的分类</p><p>\10. 锁的作用</p><p>\11. 使用所保证线程安全是有条件的</p><p>\12. 锁的几个概念</p><p>\13. 内部锁</p><p>\14. 显示锁与内部锁的比较</p><p>\15. 锁的选用</p><p>\16. 改进锁（读写锁）ReadWriteLock</p><p>\17. 锁的使用场景</p><p>\18. 线程同步的底层助手：内存屏障</p><p>\19. 锁与重排序</p><p>\20. 轻量级同步机制volatile</p><p>\21. volatile的作用</p><p>\22. CAS与原子变量</p><p>\23. 字段更新器</p><p>\24. 对象初始化线程安全：重放final和static</p><p>\25. 线程数的设置</p><p>\26. 等待与通知：notify/notify</p><p>\27. wait,notify的开销及问题</p><p>\28. 多线程编程的硬件基础与java内存模型</p><p>\29. volatile关键字的实现</p><p><img src="https://photos.alitaalice.cn/image/20200616210931.png" alt=""></p><p>\30. Java实现生产者消费者的三种方法</p><p>\31. 启动线程</p><p>\32. volatile关键字的作用</p><p><img src="https://photos.alitaalice.cn/image/20200616210716.png" alt=""></p><p>\33. final域的内存语义</p><p>\34. 双重检查加锁与延迟初始化</p><p>\35. 线程优先级</p><p>\36. 什么是线程安全</p><p>\37. 线程池线程数量</p><p>\38. 线程池超负载了怎么办（jdk内置的拒绝策略）</p><p>\39. sleep和wait的区别</p><p>\40. Java中的NIO，BIO，AIO分别是什么</p>]]></content>
      
      
      <categories>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6.16逻辑</title>
      <link href="/2020/06/16/6-16%E9%80%BB%E8%BE%91/"/>
      <url>/2020/06/16/6-16%E9%80%BB%E8%BE%91/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>本章介绍6.16逻辑</p></blockquote><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h2 id="关联字段逻辑"><a href="#关联字段逻辑" class="headerlink" title="关联字段逻辑"></a>关联字段逻辑</h2><h3 id="1-Controller"><a href="#1-Controller" class="headerlink" title="1 Controller"></a>1 Controller</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"warn/ChnlWarnEventContact"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChnlWarnEventContactController</span> <span class="keyword">extends</span> <span class="title">BaseController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> WarnEventMapper warnEventMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ChannelExtendMapper channelExtendMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ChnlWarnEventContactMapper chnlWarnEventContactMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">""</span>)</span><br><span class="line">    <span class="meta">@RequiresPermissions</span>(<span class="string">"warn:ChnlWarnEventContact:list"</span>)</span><br><span class="line">    <span class="meta">@Log</span>(<span class="string">"跳转至预警事件渠道关联管理主界面"</span>)</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * @Author zhangxl</span></span><br><span class="line"><span class="comment">     * @Description //TODO</span></span><br><span class="line"><span class="comment">     * @Date 13:43 2020/6/16</span></span><br><span class="line"><span class="comment">     * @Param [correlationID, model]</span></span><br><span class="line"><span class="comment">     * @return java.lang.String</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="function">String <span class="title">main</span><span class="params">(String correlationID, Model model)</span> </span>&#123;</span><br><span class="line">        WarnEventQueryReq warnEventQueryReq = <span class="keyword">new</span> WarnEventQueryReq();</span><br><span class="line">        List&lt;WarnEvent&gt; warnEventReqList = warnEventMapper.findByComplexCondition(correlationID, warnEventQueryReq, <span class="number">1</span>, <span class="number">1000</span>).getModel();</span><br><span class="line">        model.addAttribute(<span class="string">"warnEventReqList"</span>, warnEventReqList);</span><br><span class="line">        ChannelExtendComplexReq complexReq = <span class="keyword">new</span> ChannelExtendComplexReq();</span><br><span class="line">        List&lt;ChannelExtend&gt; chnlList = channelExtendMapper.findByComplexCondition(correlationID, complexReq, <span class="number">1</span>, <span class="number">10000</span>).getModel();</span><br><span class="line">        model.addAttribute(<span class="string">"chnList"</span>, chnlList);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"warn/ChnlWarnEventContact/main"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * @Author zhangxl</span></span><br><span class="line"><span class="comment">     * @Description //TODO</span></span><br><span class="line"><span class="comment">     * @Date 14:08 2020/6/16</span></span><br><span class="line"><span class="comment">     * @Param [correlationID, model]</span></span><br><span class="line"><span class="comment">     * @return java.lang.String</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"add"</span>)</span><br><span class="line">    <span class="meta">@RequiresPermissions</span>(<span class="string">"warn:ChnlWarnEventContact:add"</span>)</span><br><span class="line">    <span class="meta">@Log</span>(<span class="string">"跳转至预警事件渠道关联添加页面"</span>)</span><br><span class="line">    <span class="function">String <span class="title">add</span><span class="params">(String correlationID, Model model)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"warn/ChnlWarnEventContact/edit"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * @Author zhangxl</span></span><br><span class="line"><span class="comment">     * @Description //TODO</span></span><br><span class="line"><span class="comment">     * @Date 14:07 2020/6/16</span></span><br><span class="line"><span class="comment">     * @Param [correlationID, req]</span></span><br><span class="line"><span class="comment">     * @return com.atom.common.dto.Page&lt;com.lianxin.dialog.domain.ChnlWarnEvent&gt;</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"list"</span>)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="meta">@Log</span>(<span class="string">"查询"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Page&lt;ChnlWarnEvent&gt; <span class="title">list</span><span class="params">(String correlationID, ChnlWarnEventContactMngQueryReq req)</span> </span>&#123;</span><br><span class="line">        ChnlWarnEventQueryReq complexReq = <span class="keyword">new</span> ChnlWarnEventQueryReq();</span><br><span class="line">        Reflect.on(req).copy(complexReq);</span><br><span class="line">        ModelListResult listResult = chnlWarnEventContactMapper.findByComplexCondition(correlationID, complexReq, req.getPage(), req.getPageSize());</span><br><span class="line">        <span class="keyword">return</span> listResult.toPage();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * @Author zhangxl</span></span><br><span class="line"><span class="comment">     * @Description //TODO</span></span><br><span class="line"><span class="comment">     * @Date 14:08 2020/6/16</span></span><br><span class="line"><span class="comment">     * @Param [correlationID, info]</span></span><br><span class="line"><span class="comment">     * @return void</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"/save"</span>)</span><br><span class="line">    <span class="meta">@RequiresPermissions</span>(<span class="string">"warn:ChnlWarnEventContact:add"</span>)</span><br><span class="line">    <span class="meta">@Log</span>(<span class="string">"进入预警事件渠道关联保存接口"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(String correlationID, @RequestBody ChnlWarnEvent info)</span> </span>&#123;</span><br><span class="line">        ValidatorWapper.from(info, <span class="string">"pojo"</span>).isNotNull().pojo().validate();</span><br><span class="line">        chnlWarnEventContactMapper.save(correlationID, info);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/delete"</span>)</span><br><span class="line">    <span class="meta">@RequiresPermissions</span>(<span class="string">"warn:ChnlWarnEventContact:delete"</span>)</span><br><span class="line">    <span class="meta">@Log</span>(<span class="string">"进入预警事件渠道管理删除接口"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(String correlationID, @RequestParam(<span class="string">"chnlId"</span>)</span> String chnlId, @<span class="title">RequestParam</span><span class="params">(<span class="string">"eventId"</span>)</span> String eventId)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ValidatorWapper.from(chnlId, <span class="string">"chnlId"</span>).isNotNull();</span><br><span class="line">        ValidatorWapper.from(eventId, <span class="string">"eventId"</span>).isNotNull();</span><br><span class="line">        ChnlWarnEventMutiKey key = <span class="keyword">new</span> ChnlWarnEventMutiKey();</span><br><span class="line">        key.setChnlId(chnlId);</span><br><span class="line">        key.setEventId(eventId);</span><br><span class="line">        chnlWarnEventContactMapper.delete(correlationID, key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-Mapper"><a href="#2-Mapper" class="headerlink" title="2 Mapper"></a>2 Mapper</h3><p>1 findByComplexCondition 条件复杂查询 //筛选查询</p><p>(correlationID,dto,page,pageSize)   dto，所查询的对象dto 包装成dto对象 </p><p>2 save (correlationID,domain)    domain 实体类</p><p>domain类型  get()</p><p>3 get 单查询 展示main page   get(correlationID,domain)    如果是关联查询 mutikey</p><p>4 delete 删除  delete(correlationID,domain)  如果是关联查询 domain为mutikey</p><h3 id="3-前端"><a href="#3-前端" class="headerlink" title="3 前端"></a>3 前端</h3><h3 id="4-js"><a href="#4-js" class="headerlink" title="4 js"></a>4 js</h3>]]></content>
      
      
      <categories>
          
          <category> job </category>
          
      </categories>
      
      
        <tags>
            
            <tag> job </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>@RequestBody的用法</title>
      <link href="/2020/06/15/RequestBody%E7%9A%84%E7%94%A8%E6%B3%95/"/>
      <url>/2020/06/15/RequestBody%E7%9A%84%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>本章介绍@RequestBody的用法</p></blockquote><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p><a href="https://jingyan.baidu.com/article/624e7459069f4034e8ba5a87.html">https://jingyan.baidu.com/article/624e7459069f4034e8ba5a87.html</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">jsonData();</span><br><span class="line"><span class="function">function <span class="title">jsonData</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">        url:<span class="string">"&lt;%=path%&gt;/user/jsonTest.do"</span></span><br><span class="line">        contentType:<span class="string">'application/json;charset=utf8'</span>,</span><br><span class="line">        data:<span class="string">'&#123;"username":"张三","address":"福州"&#125;，</span></span><br><span class="line"><span class="string">        type:'</span>post<span class="string">',</span></span><br><span class="line"><span class="string">        success:function(data)</span></span><br><span class="line"><span class="string">        &#123;</span></span><br><span class="line"><span class="string">            alert(data);</span></span><br><span class="line"><span class="string">        &#125;,error:function(error)</span></span><br><span class="line"><span class="string">        &#123;</span></span><br><span class="line"><span class="string">           alert(error);&#125;</span></span><br><span class="line"><span class="string">    &#125;)</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">后台接收如下：</span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/jsonTest.do"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">jsonTest</span><span class="params">(@RequstBody User user)</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">sout(user.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">那么输出的user就为 User[id&#x3D;0,username&#x3D;张三,sex&#x3D; ,birthday&#x3D;null,address&#x3D;福州]</span><br></pre></td></tr></table></figure><p>可以看到User这个对象中的username和address都已经自动赋值好了，这个就是json格式的数据转java对象了，是不是很方便呢，可以省去我们在后台将json转成java对象。不过在使用的时候，我们要注意两边的名称要相同，前台的username要对应java对象中的username这样才能成功。否则得到如下：</p><p><img src="https://photos.alitaalice.cn/image/20200616100452.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> springmvc </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springmvc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC流程</title>
      <link href="/2020/06/15/SpringMVC%E6%B5%81%E7%A8%8B/"/>
      <url>/2020/06/15/SpringMVC%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>本章介绍SpringMVC流程</p></blockquote><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>SpringMVC流程：请求执行到后端控制器（位于Web层）之后，后端控制器会继续调用Service层中的业务代码，而Service层继续向后调用Manager层或者DAO层，进而获得目标数据。Service层将获得到的目标数据返回给后端控制器。后端控制器把目标数据包装成Model之后返回给ViewResolver，ViewResolver把Model渲染成最终用户看到的页面。</p><p><img src="https://photos.alitaalice.cn/image/20200615092105.png" alt=""></p><p><img src="C:%5CUsers%5C16508%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200615092208397.png" alt="image-20200615092208397"></p><p><img src="https://photos.alitaalice.cn/image/20200615092336.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> SpringMVC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringMVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springmvc的原理</title>
      <link href="/2020/06/13/springmvc%E7%9A%84%E5%8E%9F%E7%90%86/"/>
      <url>/2020/06/13/springmvc%E7%9A%84%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>本章介绍springmvc的原理</p></blockquote><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>1、客户端发出一个http请求给web服务器，web服务器对http请求进行解析，如果匹配DispatcherServlet的请求映射路径（在web.xml中指定），web容器将请求转交给DispatcherServlet.</p><p>2、DipatcherServlet接收到这个请求之后将根据请求的信息（包括URL、Http方法、请求报文头和请求参数Cookie等）以及HandlerMapping的配置找到处理请求的处理器（Handler）。</p><p>3-4、DispatcherServlet根据HandlerMapping找到对应的Handler,将处理权交给Handler（Handler将具体的处理进行封装），再由具体的HandlerAdapter对Handler进行具体的调用。</p><p>5、Handler对数据处理完成以后将返回一个ModelAndView()对象给DispatcherServlet。</p><p>6、Handler返回的ModelAndView()只是一个逻辑视图并不是一个正式的视图，DispatcherSevlet通过ViewResolver将逻辑视图转化为真正的视图View。</p><p>7、Dispatcher通过model解析出ModelAndView()中的参数进行解析最终展现出完整的view并返回给客户端。</p>]]></content>
      
      
      <categories>
          
          <category> springmvc </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springmvc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jQuery入门</title>
      <link href="/2020/06/13/jQuery%E5%85%A5%E9%97%A8/"/>
      <url>/2020/06/13/jQuery%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>本章介绍jQuery入门</p></blockquote><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="1-什么是-jQuery-？"><a href="#1-什么是-jQuery-？" class="headerlink" title="1 什么是 jQuery ？"></a>1 什么是 jQuery ？</h3><p>jQuery是一个JavaScript函数库。</p><p>jQuery是一个轻量级的”写的少，做的多”的JavaScript库。</p><p>jQuery库包含以下功能：</p><ul><li>HTML 元素选取</li><li>HTML 元素操作</li><li>CSS 操作</li><li>HTML 事件函数</li><li>JavaScript 特效和动画</li><li>HTML DOM 遍历和修改</li><li>AJAX</li><li>Utilities</li></ul><p><strong>提示：</strong> 除此之外，Jquery还提供了大量的插件。</p><p>2 jQuery语法</p><p>基础语法：$(selector)查询和查找HTML元素</p><p>jQuery的action()执行对元素的操作</p><p>实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$(this).hide() &#x2F;&#x2F;隐藏当前元素</span><br><span class="line">$(&quot;p&quot;).hide() &#x2F;&#x2F;隐藏所有&lt;p&gt;元素</span><br><span class="line">$(&quot;p.test&quot;).hide()  &#x2F;&#x2F;隐藏所有class&#x3D;&quot;test&quot;的p元素</span><br><span class="line">$(&quot;#test&quot;).hide() &#x2F;&#x2F;隐藏id&#x3D;&quot;test&quot;的元素</span><br></pre></td></tr></table></figure><h3 id="2文档就绪事件"><a href="#2文档就绪事件" class="headerlink" title="2文档就绪事件"></a>2文档就绪事件</h3><p>这是为了防止文档在完全加载（就绪）之前运行 jQuery 代码，即在 DOM 加载完成后才可以对 DOM 进行操作。</p><p>如果在文档没有完全加载之前就运行函数，操作可能失败。下面是两个具体的例子：</p><ul><li>试图隐藏一个不存在的元素</li><li>获得未完全加载的图像的大小</li></ul><p>jQuery函数位于一个document ready函数中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//开始写jQuery代码</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>简洁写法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>))</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//开始写jQuery代码...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="3-元素选择器"><a href="#3-元素选择器" class="headerlink" title="3 元素选择器"></a>3 元素选择器</h3><p> jQuery元素选择器基于元素名选取元素</p><p>在页面中选取所有的<p>元素</p><p>$(“p”)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$(document).ready(function()</span><br><span class="line">&#123;</span><br><span class="line">$(&quot;button&quot;).click(function())</span><br><span class="line">&#123;</span><br><span class="line">$(&quot;p&quot;).hide();</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-id-选择器"><a href="#4-id-选择器" class="headerlink" title="4 id 选择器"></a>4 id 选择器</h3><p>选择器通过HTML元素的id属性选取指定的元素</p><p>语法为</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"#test"</span>)</span><br></pre></td></tr></table></figure><p>实例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">$(<span class="string">"button"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">$(<span class="string">"#test"</span>).hide();</span><br><span class="line">&#125;);</span><br><span class="line">&#125;);</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h2&gt;这是一个标题&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">&lt;p&gt;这是一个段落&lt;/</span>p&gt;</span><br><span class="line">&lt;p id=<span class="string">"test"</span>&gt;这是另外一个段落&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">&lt;button&gt;点我&lt;/</span>button&gt;</span><br><span class="line">&lt;<span class="regexp">/body&gt;</span></span><br></pre></td></tr></table></figure><h3 id="5-class选择器"><a href="#5-class选择器" class="headerlink" title="5 .class选择器"></a>5 .class选择器</h3><p>语法为</p><p>$(“.test”)</p><p>实例 用户点击按钮后所有带有class=“test”属性元素都隐藏：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">$(<span class="string">"button"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">$(<span class="string">".test"</span>).hide();</span><br><span class="line">&#125;);</span><br><span class="line">&#125;);</span><br><span class="line">&lt;h2 <span class="class"><span class="keyword">class</span></span>=<span class="string">"test"</span>&gt;这是一个标题&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">&lt;p class="test"&gt;这是一个段落。&lt;/</span>p&gt;</span><br></pre></td></tr></table></figure><p><img src="https://photos.alitaalice.cn/image/20200613124742.png" alt=""></p><p>click()方法是当按钮点击事件被触发时调用的一个函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"p"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">$(<span class="keyword">this</span>).hide();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>focus()</p><p>当元素获得焦点时，发生 focus 事件。</p><p>当通过鼠标点击选中元素或通过 tab 键定位到元素时，该元素就会获得焦点。</p><p>focus() 方法触发 focus 事件，或规定当发生 focus 事件时运行的函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"input"</span>).focus(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">$(<span class="keyword">this</span>).css(<span class="string">"background-color"</span>,<span class="string">"#ccccc"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>blur()</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"input"</span>).blur(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">$(<span class="keyword">this</span>).css(<span class="string">"background-color"</span>,<span class="string">"#ffffff"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">"https://cdn.staticfile.org/jquery/1.10.2/jquery.min.js"</span>&gt;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">$(document).ready(function()&#123;</span></span><br><span class="line"><span class="regexp">  $("input").focus(function()&#123;</span></span><br><span class="line"><span class="regexp">    $(this).css("background-color","#cccccc");</span></span><br><span class="line"><span class="regexp">  &#125;);</span></span><br><span class="line"><span class="regexp">  $("input").blur(function()&#123;</span></span><br><span class="line"><span class="regexp">    $(this).css("background-color","#ffffff");</span></span><br><span class="line"><span class="regexp">  &#125;);</span></span><br><span class="line"><span class="regexp">&#125;);</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br><span class="line">&lt;<span class="regexp">/head&gt;</span></span><br><span class="line"><span class="regexp">&lt;body&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">Name: &lt;input type="text" name="fullname"&gt;&lt;br&gt;</span></span><br><span class="line"><span class="regexp">Email: &lt;input type="text" name="email"&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br></pre></td></tr></table></figure><p>p</p><p><img src="https://photos.alitaalice.cn/image/20200709093404.png" alt=""></p><p>67.</p>]]></content>
      
      
      <categories>
          
          <category> jQuery </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jQuery </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>get和post的区别</title>
      <link href="/2020/06/13/get%E5%92%8Cpost%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2020/06/13/get%E5%92%8Cpost%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>本章介绍get和post的区别</p></blockquote><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>说到底，我觉得是要正确理解“GET的页面”和“POST的页面”的区别。</p><p>要说清楚这两个区别，首先要说清楚一个概念——你输入内容的页面和没输入内容的页面是两种东西。</p><p>当你进入一个有表单的页面时，假如其URL是”<a href="https://link.zhihu.com/?target=http%3A//www.haha.com">http://www.haha.com</a>“，你把这个URL分享给朋友，朋友进入这个页面看到的所有内容将和你看到的一摸一样；</p><p>此时你在表单里输入你的名字，没有提交，URL还是“<a href="http://www.haha.com”，此时有两种情况：">www.haha.com”，此时有两种情况：</a></p><p>此时你并没有提交：</p><p>1.这个表单的method值是POST。你把这个URL分享给朋友，朋友看到的是和你不一样的页面（页面表单里没有你的名字，除此之外一摸一样）。</p><p>2.这个表单的method值是GET。你把这个URL分享给朋友，朋友看到的页面和你的还是不一样（GET能本地缓存（应该没有“联网缓存”）——在某些应用里，关闭网页后再次进入，你会看到一个有你名字的表单。QQ空间网页版就是这样，你在说说处输入内容但不发布，重新打开时你还能看到那个没发布的内容。当然，你清除浏览器的Cookie和网站记录后再次进入这个页面就看不到未发布的内容了）。</p><p>现在，你把表单提交了（注意，有时候你可能都不知道自己提交了这个表单，比如百度搜索里，回车就是提交~），有两种情况：</p><p>1.表单的method是POST，URL变成了“<a href="https://link.zhihu.com/?target=http%3A//www.haha.com/nimei.php">http://www.haha.com/nimei.php</a>”。此时页面被刷新，你的数据被提交服务器脚本返回给你一个新页面。此时就算你“后退”到“<a href="http://www.haha.com”也看不到你原来输入了内容的那个表单了；你把这个网页分享给朋友，朋友是看不到你的页面的（你这个页面必须是提交相同的数据后才能看到），这也是为什么你登陆微博后，直接复制地址栏的URL发给别人，别人看不到这个网页的原因。">www.haha.com”也看不到你原来输入了内容的那个表单了；你把这个网页分享给朋友，朋友是看不到你的页面的（你这个页面必须是提交相同的数据后才能看到），这也是为什么你登陆微博后，直接复制地址栏的URL发给别人，别人看不到这个网页的原因。</a></p><p>2.表单的method是GET，URL变成了“<a href="https://link.zhihu.com/?target=http%3A//www.haha.com/nimei.php%3Fname%3D">http://www.haha.com/nimei.php?name=</a>“haha”&amp;…..”。此时页面被刷新，同样得到一个新页面。如果你“后退”，你能看到原来输入了内容的表单；你可以保存为书签，关闭后再次打开能看到保存书签时的网页（<strong>因为URL里有你发给服务器脚本的所有数据，就相当于再次发送给服务器脚本相同的数据，返回的页面自然也就一样——服务器脚本处理这些数据得到的结果还是一样的话</strong>）；你可以把这个页面分享给朋友，朋友打开后能看到一摸一样的页面（理由和书签里说的一样）</p>]]></content>
      
      
      <categories>
          
          <category> HTTP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js作用域</title>
      <link href="/2020/06/13/js%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
      <url>/2020/06/13/js%E4%BD%9C%E7%94%A8%E5%9F%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>本章介绍js作用域</p></blockquote><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="1局部作用域"><a href="#1局部作用域" class="headerlink" title="1局部作用域"></a>1局部作用域</h3><p><img src="https://photos.alitaalice.cn/image/20200613090919.png" alt=""></p><h3 id="2-全局变量"><a href="#2-全局变量" class="headerlink" title="2 全局变量"></a>2 全局变量</h3><p><img src="https://photos.alitaalice.cn/image/20200613090959.png" alt=""></p><p><img src="https://photos.alitaalice.cn/image/20200613091057.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript语法</title>
      <link href="/2020/06/13/JavaScript%E8%AF%AD%E6%B3%95/"/>
      <url>/2020/06/13/JavaScript%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>本章介绍JavaScript语法</p></blockquote><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p><img src="https://photos.alitaalice.cn/image/20200613082401.png" alt=""></p><p><img src="https://photos.alitaalice.cn/image/20200613082541.png" alt=""></p><p> JavaScript 语句和 JavaScript 变量都对大小写敏感。</p><p><img src="https://photos.alitaalice.cn/image/20200613083857.png" alt=""></p><p><img src="https://photos.alitaalice.cn/image/20200613085322.png" alt=""></p><h3 id="声明对象"><a href="#声明对象" class="headerlink" title="声明对象"></a>声明对象</h3><p><img src="https://photos.alitaalice.cn/image/20200613085835.png" alt=""></p><h3 id="js调用带参数的函数"><a href="#js调用带参数的函数" class="headerlink" title="js调用带参数的函数"></a>js调用带参数的函数</h3><p><img src="https://photos.alitaalice.cn/image/20200613090436.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js入门</title>
      <link href="/2020/06/13/js%E5%85%A5%E9%97%A8/"/>
      <url>/2020/06/13/js%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>本章介绍javascript</p></blockquote><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="1-为什么学习js"><a href="#1-为什么学习js" class="headerlink" title="1.为什么学习js"></a>1.为什么学习js</h3><ol><li><strong>HTML</strong> 定义了网页的内容</li><li><strong>CSS</strong> 描述了网页的布局</li><li><strong>JavaScript</strong> 网页的行为</li></ol><h3 id="2-JavaScript：对事件的反应"><a href="#2-JavaScript：对事件的反应" class="headerlink" title="2.JavaScript：对事件的反应"></a>2.JavaScript：对事件的反应</h3><p><button type="button" onclick="alert('欢迎')"> 点我</button></p><p>这是一个按钮，提醒按钮</p><h3 id="3-JAVAScript：改变HTML内容"><a href="#3-JAVAScript：改变HTML内容" class="headerlink" title="3.JAVAScript：改变HTML内容"></a>3.JAVAScript：改变HTML内容</h3><p>使用JAVAScript来处理HTML内容</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;我的第一段JAVAScript&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">&lt;p id="demo"&gt;</span></span><br><span class="line"><span class="regexp">JAVAScript能改变HTML元素的内容</span></span><br><span class="line"><span class="regexp">&lt;/</span>p&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">x.document.getElementById(<span class="string">"demo"</span>);<span class="comment">//找到元素</span></span><br><span class="line">x.innerHTML=<span class="string">"hello javascript!"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;button type="button" onclick="myFunction()"&gt;点击这里&lt;/</span>button&gt;</span><br><span class="line">&lt;<span class="regexp">/body&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-验证输入"><a href="#3-验证输入" class="headerlink" title="3.验证输入"></a>3.验证输入</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;我的第一段javaScrit&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">&lt;p&gt;请输入数字，如果不是数字那么，浏览器会弹出提示框&lt;/</span>p&gt;</span><br><span class="line">&lt;input id=<span class="string">"demo"</span> type=<span class="string">"text"</span>&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">var</span> x=<span class="built_in">document</span>.getElementById(<span class="string">"demo"</span>).value;</span><br><span class="line"><span class="keyword">if</span>(x==<span class="string">""</span>||<span class="built_in">isNaN</span>(x))</span><br><span class="line">&#123;</span><br><span class="line">alert(<span class="string">"不是数字"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;button type="button" onclick="myFunction()"&gt;点击这里&lt;/</span>button&gt;</span><br><span class="line">&lt;<span class="regexp">/body&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>html&gt;</span><br></pre></td></tr></table></figure><h3 id="4-在本例中，JavaScript-会在页面加载时向-HTML-的-写文本："><a href="#4-在本例中，JavaScript-会在页面加载时向-HTML-的-写文本：" class="headerlink" title="4 在本例中，JavaScript 会在页面加载时向 HTML 的  写文本："></a>4 在本例中，JavaScript 会在页面加载时向 HTML 的 <body> 写文本：<img src="https://photos.alitaalice.cn/image/20200613075951.png" alt=""></h3><h3 id="5-中的-JavaScript-函数"><a href="#5-中的-JavaScript-函数" class="headerlink" title="5 中的 JavaScript 函数"></a>5<head> 中的 JavaScript 函数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">"demo"</span>).innerHTML=<span class="string">"我的第一个 JavaScript 函数"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;我的 Web 页面&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">&lt;p id="demo"&gt;一个段落&lt;/</span>p&gt;</span><br><span class="line">&lt;button type=<span class="string">"button"</span> onclick=<span class="string">"myFunction()"</span>&gt;尝试一下&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br><span class="line">&lt;<span class="regexp">/html&gt;</span></span><br></pre></td></tr></table></figure><p>6.<body> 中的 JavaScript 函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;我的 Web 页面&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">&lt;p id="demo"&gt;一个段落&lt;/</span>p&gt;</span><br><span class="line">&lt;button type=<span class="string">"button"</span> onclick=<span class="string">"myFunction()"</span>&gt;尝试一下&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">function myFunction()</span></span><br><span class="line"><span class="regexp">&#123;</span></span><br><span class="line"><span class="regexp">    document.getElementById("demo").innerHTML="我的第一个 JavaScript 函数";</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br><span class="line">&lt;<span class="regexp">/body&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>html&gt;</span><br></pre></td></tr></table></figure><p>7.外部的 JavaScript</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;script src=<span class="string">"myScript.js"</span>&gt;&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br><span class="line">&lt;<span class="regexp">/html&gt;</span></span><br></pre></td></tr></table></figure><p>myScript.js 文件代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params"></span>) </span>&#123;    <span class="built_in">document</span>.getElementById(<span class="string">"demo"</span>).innerHTML=<span class="string">"我的第一个 JavaScript 函数"</span>; &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">JavaScript 显示数据</span><br><span class="line">JavaScript 可以通过不同的方式来输出数据：</span><br><span class="line"></span><br><span class="line">使用 window.alert() 弹出警告框。</span><br><span class="line">使用 document.write() 方法将内容写到 HTML 文档中。</span><br><span class="line">使用 innerHTML 写入到 HTML 元素。</span><br><span class="line">使用 console.log() 写入到浏览器的控制台。</span><br></pre></td></tr></table></figure><p>8.JavaScript 显示数据</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">JavaScript 可以通过不同的方式来输出数据：</span><br><span class="line"></span><br><span class="line">使用 <span class="built_in">window</span>.alert() 弹出警告框。</span><br><span class="line">使用 <span class="built_in">document</span>.write() 方法将内容写到 HTML 文档中。</span><br><span class="line">使用 innerHTML 写入到 HTML 元素。</span><br><span class="line">使用 <span class="built_in">console</span>.log() 写入到浏览器的控制台。</span><br></pre></td></tr></table></figure><p><img src="https://photos.alitaalice.cn/image/20200613082104.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springboot中controller的使用</title>
      <link href="/2020/06/12/springboot%E4%B8%ADcontroller%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2020/06/12/springboot%E4%B8%ADcontroller%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>本章介绍springboot中controller的使用</p></blockquote><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>1 </p><p><img src="https://photos.alitaalice.cn/image/20200613091901.png" alt=""></p><p><img src="https://photos.alitaalice.cn/image/20200613092010.png" alt=""></p><p><img src="C:%5CUsers%5C16508%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200613092031562.png" alt="image-20200613092031562"></p><p><img src="https://photos.alitaalice.cn/image/20200613092049.png" alt=""></p><p><img src="https://photos.alitaalice.cn/image/20200613092100.png" alt="">-</p><h1 id="RequestBody"><a href="#RequestBody" class="headerlink" title="@RequestBody"></a>@RequestBody</h1><p>@RequestBody主要用来json转换为java对象。 前台向后台传数据</p><p>@ResponseBody的作用其实是将java对象转为json格式的数据。后台传前台。</p><h1 id="model-attribute-的作用"><a href="#model-attribute-的作用" class="headerlink" title="model.attribute()的作用"></a>model.attribute()的作用</h1><p>1.往前台传数据，可以传对象，可以传List，通过el表达式 ${}可以获取到，</p><p>类似于request.setAttribute(“sts”,sts)效果一样。</p><p>2.@ModelAttribute(“model”)  注解</p>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基本索引类型</title>
      <link href="/2020/06/09/%E5%9F%BA%E6%9C%AC%E7%B4%A2%E5%BC%95%E7%B1%BB%E5%9E%8B/"/>
      <url>/2020/06/09/%E5%9F%BA%E6%9C%AC%E7%B4%A2%E5%BC%95%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>本章介绍</p></blockquote><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>线程和进程的区别</title>
      <link href="/2020/06/09/%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2020/06/09/%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>本章介绍线程和进程的区别。</p></blockquote><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>转<a href="https://blog.csdn.net/ThinkWon/article/details/102021274">https://blog.csdn.net/ThinkWon/article/details/102021274</a></p>]]></content>
      
      
      <categories>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql执行外部sql</title>
      <link href="/2020/06/07/mysql%E6%89%A7%E8%A1%8C%E5%A4%96%E9%83%A8sql/"/>
      <url>/2020/06/07/mysql%E6%89%A7%E8%A1%8C%E5%A4%96%E9%83%A8sql/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>本章介绍mysql执行外部sql</p></blockquote><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>进入mysql的控制台后，使用source命令执行<br>Mysql&gt;source 【sql脚本文件的路径全名】 或 Mysql&gt;. 【sql脚本文件的路径全名】，示例：<br>source d:\test\ss.sql 或者 . d:\test\ss.sql</p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反射</title>
      <link href="/2020/06/05/%E5%8F%8D%E5%B0%84/"/>
      <url>/2020/06/05/%E5%8F%8D%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>本章介绍反射</p></blockquote><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2>]]></content>
      
      
      <categories>
          
          <category> JAVASE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVASE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java_I/O</title>
      <link href="/2020/06/05/java-I-O/"/>
      <url>/2020/06/05/java-I-O/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>本章介绍</p></blockquote><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2>]]></content>
      
      
      <categories>
          
          <category> JAVASE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVASE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring常用注解</title>
      <link href="/2020/06/04/spring%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/"/>
      <url>/2020/06/04/spring%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>本章介绍spring常用注解。</p></blockquote><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>Spring部分<br>1、声明bean的注解</p><p>@Component 组件，没有明确的角色<br>@Service 在业务逻辑层使用（service层）<br>@Repository 在数据访问层使用（dao层）<br>@Controller 在展现层使用，控制器的声明（C）</p><p>2、注入bean的注解<br>@Autowired：由Spring提供<br>@Inject：由JSR-330提供<br>@Resource：由JSR-250提供<br>都可以注解在set方法和属性上，推荐注解在属性上（一目了然，少写代码）。</p><p>3、java配置类相关注解<br>@Configuration 声明当前类为配置类，相当于xml形式的Spring配置（类上）<br>@Bean 注解在方法上，声明当前方法的返回值为一个bean，替代xml中的方式（方法上）<br>@Configuration 声明当前类为配置类，其中内部组合了@Component注解，表明这个类是一个bean（类上）<br>@ComponentScan 用于对Component进行扫描，相当于xml中的（类上）<br>@WishlyConfiguration 为@Configuration与@ComponentScan的组合注解，可以替代这两个注解</p><p>4、切面（AOP）相关注解<br>Spring支持AspectJ的注解式切面编程。<br>@Aspect 声明一个切面（类上）<br>使用@After、@Before、@Around定义建言（advice），可直接将拦截规则（切点）作为参数。<br>@After 在方法执行之后执行（方法上）<br>@Before 在方法执行之前执行（方法上）<br>@Around 在方法执行之前与之后执行（方法上）<br>@PointCut 声明切点<br>在java配置类中使用@EnableAspectJAutoProxy注解开启Spring对AspectJ代理的支持（类上）</p><p>5、@Bean的属性支持<br>@Scope 设置Spring容器如何新建Bean实例（方法上，得有@Bean）<br>其设置类型包括：<br>Singleton （单例,一个Spring容器中只有一个bean实例，默认模式）,<br>Protetype （每次调用新建一个bean）,<br>Request （web项目中，给每个http request新建一个bean）,<br>Session （web项目中，给每个http session新建一个bean）,<br>GlobalSession（给每一个 global http session新建一个Bean实例）<br>@StepScope 在Spring Batch中还有涉及<br>@PostConstruct 由JSR-250提供，在构造函数执行完之后执行，等价于xml配置文件中bean的initMethod<br>@PreDestory 由JSR-250提供，在Bean销毁之前执行，等价于xml配置文件中bean的destroyMethod</p><p>6、@Value注解<br>@Value 为属性注入值（属性上）<br>支持如下方式的注入：<br>》注入普通字符</p><p>》注入操作系统属性</p><p>》注入表达式结果</p><p>》注入其它bean属性</p><p>》注入文件资源</p><p>》注入网站资源</p><p>》注入配置文件</p><p>注入配置使用方法：<br>① 编写配置文件（test.properties）<br>book.name=《三体》<br>② @PropertySource 加载配置文件(类上)</p><p>③ 还需配置一个PropertySourcesPlaceholderConfigurer的bean。</p><p>7、环境切换<br>@Profile 通过设定Environment的ActiveProfiles来设定当前context需要使用的配置环境。（类或方法上）<br>@Conditional Spring4中可以使用此注解定义条件话的bean，通过实现Condition接口，并重写matches方法，从而决定该bean是否被实例化。（方法上）</p><p>8、异步相关<br>@EnableAsync 配置类中，通过此注解开启对异步任务的支持，叙事性AsyncConfigurer接口（类上）<br>@Async 在实际执行的bean方法使用该注解来申明其是一个异步任务（方法上或类上所有的方法都将异步，需要@EnableAsync开启异步任务）</p><p>9、定时任务相关<br>@EnableScheduling 在配置类上使用，开启计划任务的支持（类上）<br>@Scheduled 来申明这是一个任务，包括cron,fixDelay,fixRate等类型（方法上，需先开启计划任务的支持）</p><p>10、@Enable*注解说明<br>这些注解主要用来开启对xxx的支持。<br>@EnableAspectJAutoProxy 开启对AspectJ自动代理的支持<br>@EnableAsync 开启异步方法的支持<br>@EnableScheduling 开启计划任务的支持<br>@EnableWebMvc 开启Web MVC的配置支持<br>@EnableConfigurationProperties 开启对@ConfigurationProperties注解配置Bean的支持<br>@EnableJpaRepositories 开启对SpringData JPA Repository的支持<br>@EnableTransactionManagement 开启注解式事务的支持<br>@EnableTransactionManagement 开启注解式事务的支持<br>@EnableCaching 开启注解式的缓存支持</p><p>11、测试相关注解<br>@RunWith 运行器，Spring中通常用于对JUnit的支持</p><p>@ContextConfiguration 用来加载配置ApplicationContext，其中classes属性用来加载配置类</p><p>SpringMVC部分<br>@EnableWebMvc 在配置类中开启Web MVC的配置支持，如一些ViewResolver或者MessageConverter等，若无此句，重写WebMvcConfigurerAdapter方法（用于对SpringMVC的配置）。<br>@Controller 声明该类为SpringMVC中的Controller<br>@RequestMapping 用于映射Web请求，包括访问路径和参数（类或方法上）<br>@ResponseBody 支持将返回值放在response内，而不是一个页面，通常用户返回json数据（返回值旁或方法上）<br>@RequestBody 允许request的参数在request体中，而不是在直接连接在地址后面。（放在参数前）<br>@PathVariable 用于接收路径参数，比如@RequestMapping(“/hello/{name}”)申明的路径，将注解放在参数中前，即可获取该值，通常作为Restful的接口实现方法。<br>@RestController 该注解为一个组合注解，相当于@Controller和@ResponseBody的组合，注解在类上，意味着，该Controller的所有方法都默认加上了@ResponseBody。<br>@ControllerAdvice 通过该注解，我们可以将对于控制器的全局配置放置在同一个位置，注解了@Controller的类的方法可使用@ExceptionHandler、@InitBinder、@ModelAttribute注解到方法上，<br>这对所有注解了 @RequestMapping的控制器内的方法有效。<br>@ExceptionHandler 用于全局处理控制器里的异常<br>@InitBinder 用来设置WebDataBinder，WebDataBinder用来自动绑定前台请求参数到Model中。<br>@ModelAttribute 本来的作用是绑定键值对到Model里，在@ControllerAdvice中是让全局的@RequestMapping都能获得在此处设置的键值对。</p>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习有感</title>
      <link href="/2020/06/03/%E5%AD%A6%E4%B9%A0%E6%9C%89%E6%84%9F/"/>
      <url>/2020/06/03/%E5%AD%A6%E4%B9%A0%E6%9C%89%E6%84%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>本章介绍学习有感</p></blockquote><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>不要着急，任何学习都不是一蹴而就的，但是你必须进步，必须每天都有自己的计划，不浪费过多时间，按部就班，每天进步一些，一步一步来。</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂谈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git常用命令</title>
      <link href="/2020/06/03/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2020/06/03/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>本章介绍</p></blockquote><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>初始化仓库</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><p>查看仓库的状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure><p>向暂存区添加文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add</span><br></pre></td></tr></table></figure><p>保存仓库的历史记录</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m <span class="string">"first commit"</span></span><br></pre></td></tr></table></figure><p>查看提交日志</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log</span><br></pre></td></tr></table></figure><p>查看更改前后的差别</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff</span><br></pre></td></tr></table></figure><p>显示分支一览表</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure><p>创建、切换分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b alita</span><br><span class="line">&#x2F;* 创建名为alita的分支 *&#x2F;</span><br></pre></td></tr></table></figure><p>合并分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br><span class="line">&#x2F;* 为了在历史记录中明确记录下本次分支合并。我们需要创建合并并提交 *&#x2F;</span><br><span class="line">git merge --no-ff alita</span><br></pre></td></tr></table></figure><p>以图表形式查看分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --graph</span><br></pre></td></tr></table></figure><p>添加远程仓库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@github.com:xxx</span><br></pre></td></tr></table></figure><p>推送至远程仓库</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure><p>从远程仓库获取</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git@xxx</span><br></pre></td></tr></table></figure><p>获取最新的远程仓库分支</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull origin alita</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>delete、drop、truncate区别</title>
      <link href="/2020/06/03/delete%E3%80%81drop%E3%80%81truncate%E5%8C%BA%E5%88%AB/"/>
      <url>/2020/06/03/delete%E3%80%81drop%E3%80%81truncate%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>本章介绍delete、drop、truncate区别</p></blockquote><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>SQL关于删除的三个语句：<strong>DROP</strong>、<strong>TRUNCATE</strong>、 <strong>DELETE</strong> 的区别。</p><p><strong>DROP:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP test;</span><br></pre></td></tr></table></figure><p>删除表test，并释放空间，将test删除的一干二净。</p><p><strong>TRUNCATE:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TRUNCATE test;</span><br></pre></td></tr></table></figure><p>删除表test里的内容，并释放空间，但不删除表的定义，表的结构还在。</p><p><strong>DELETE:</strong></p><p>1、删除指定数据</p><p>删除表test中年龄等于30的且国家为US的数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE FROM test WHERE age&#x3D;30 AND country&#x3D;&#39;US&#39;;</span><br></pre></td></tr></table></figure><p>2、删除整个表</p><p>仅删除表test内的所有内容，保留表的定义，不释放空间。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DELETE FROM test 或者 DELETE FROM test;</span><br><span class="line">DELETE * FROM test 或者 DELETE * FROM test;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>集合排序</title>
      <link href="/2020/06/02/%E9%9B%86%E5%90%88%E6%8E%92%E5%BA%8F/"/>
      <url>/2020/06/02/%E9%9B%86%E5%90%88%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>本章介绍集合排序。</p></blockquote><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2>]]></content>
      
      
      <categories>
          
          <category> JAVA集合 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>希尔排序</title>
      <link href="/2020/06/02/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/"/>
      <url>/2020/06/02/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>本章介绍</p></blockquote><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>选择排序</title>
      <link href="/2020/06/02/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"/>
      <url>/2020/06/02/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>本章介绍</p></blockquote><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>冒泡排序</title>
      <link href="/2020/06/02/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
      <url>/2020/06/02/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>本章介绍</p></blockquote><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>插入排序</title>
      <link href="/2020/06/02/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
      <url>/2020/06/02/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>本章介绍插入排序</p></blockquote><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>转自<a href="https://www.runoob.com/w3cnote/insertion-sort.html">https://www.runoob.com/w3cnote/insertion-sort.html</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">function <span class="title">insertionSort</span><span class="params">(arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> len = arr.length;</span><br><span class="line">    <span class="keyword">var</span> preIndex, current;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">        preIndex = i - <span class="number">1</span>;</span><br><span class="line">        current = arr[i];</span><br><span class="line">        <span class="keyword">while</span>(preIndex &gt;= <span class="number">0</span> &amp;&amp; arr[preIndex] &gt; current) &#123;</span><br><span class="line">            arr[preIndex+<span class="number">1</span>] = arr[preIndex];</span><br><span class="line">            preIndex--;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[preIndex+<span class="number">1</span>] = current;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DataStructure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql事务相关</title>
      <link href="/2020/06/02/mysql%E4%BA%8B%E5%8A%A1%E7%9B%B8%E5%85%B3/"/>
      <url>/2020/06/02/mysql%E4%BA%8B%E5%8A%A1%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>本章介绍事务相关。</p></blockquote><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="1-脏读，不可重复读，幻读"><a href="#1-脏读，不可重复读，幻读" class="headerlink" title="1 脏读，不可重复读，幻读"></a>1 脏读，不可重复读，幻读</h3><p><strong>1.</strong> <strong>脏读</strong> ：脏读就是指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。</p><p><strong>2.</strong> <strong>不可重复读</strong> ：是指在一个事务内，多次读同一数据。在这个事务还没有结束时，另外一个事务也访问该同一数据。那么，在第一个事务中的两 次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的的数据可能是不一样的。这样就发生了在一个事务内两次读到的数据是不一样的，因此称为是不 可重复读。例如，一个编辑人员两次读取同一文档，但在两次读取之间，作者重写了该文档。当编辑人员第二次读取文档时，文档已更改。原始读取不可重复。如果 只有在作者全部完成编写后编辑人员才可以读取文档，则可以避免该问题。</p><p><strong>3.</strong> <strong>幻读</strong> : 是指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。 同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象 发生了幻觉一样。例如，一个编辑人员更改作者提交的文档，但当生产部门将其更改内容合并到该文档的主复本时，发现作者已将未编辑的新材料添加到该文档中。 如果在编辑人员和生产部门完成对原始文档的处理之前，任何人都不能将新材料添加到文档中，则可以避免该问题。</p><h3 id="2-事务隔离级别"><a href="#2-事务隔离级别" class="headerlink" title="2 事务隔离级别"></a>2 事务隔离级别</h3>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql范式</title>
      <link href="/2020/06/02/mysql%E8%8C%83%E5%BC%8F/"/>
      <url>/2020/06/02/mysql%E8%8C%83%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>本章介绍mysql范式。</p></blockquote><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p><img src="https://photos.alitaalice.cn/image/20200602155102.png" alt=""></p><p><img src="https://photos.alitaalice.cn/image/20200602155137.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql索引相关</title>
      <link href="/2020/06/02/mysql%E7%B4%A2%E5%BC%95%E7%9B%B8%E5%85%B3/"/>
      <url>/2020/06/02/mysql%E7%B4%A2%E5%BC%95%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>本章介绍mysql索引相关。</p></blockquote><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="1-在什么情况下建立索引"><a href="#1-在什么情况下建立索引" class="headerlink" title="1 在什么情况下建立索引"></a>1 在什么情况下建立索引</h3><p>1 在经常需要搜索的列上，可以加快搜索的速度；<br>2 在作为主键的列上，强制该列的唯一性和组织表中数据的排列结构；<br>3 在经常用于连接两张表的列上，这些列主要是一些外键，可以加快连接的速度；<br>4 在经常需要根据范围进行搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的；<br>5 在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间；<br>6  在经常使用在WHERE子句中的列上面创建索引，加快条件的判断速度。</p><h3 id="2-数据库索引的优缺点，以及什么时候数据库索引失效"><a href="#2-数据库索引的优缺点，以及什么时候数据库索引失效" class="headerlink" title="2 数据库索引的优缺点，以及什么时候数据库索引失效"></a>2 数据库索引的优缺点，以及什么时候数据库索引失效</h3><p>索引的优点：</p><p>1 索引大大减少了服务器需要扫描的数据量</p><p>2 索引可以帮助服务器避免排序和临时表</p><p>3 索引可以将随机I/O变为顺序I/O</p><p>索引的缺点</p><p>1.创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加</p><p>2.索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大</p><p>3.当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，降低了数据的维护速度</p><h3 id="3-索引的类型（普通、唯一、主键、组合、全文）"><a href="#3-索引的类型（普通、唯一、主键、组合、全文）" class="headerlink" title="3 索引的类型（普通、唯一、主键、组合、全文）"></a>3 索引的类型（普通、唯一、主键、组合、全文）</h3><h3 id="4-索引优化（最左前缀原则）"><a href="#4-索引优化（最左前缀原则）" class="headerlink" title="4 索引优化（最左前缀原则）"></a>4 索引优化（最左前缀原则）</h3><h3 id="5-数据库中的索引结构"><a href="#5-数据库中的索引结构" class="headerlink" title="5 数据库中的索引结构"></a>5 数据库中的索引结构</h3><ol><li><p>InnoDB 支持事务，MyISAM 不支持事务。这是 MySQL 将默认存储引擎从 MyISAM 变成 InnoDB 的重要原因之一；</p></li><li><p>InnoDB 支持外键，而 MyISAM 不支持。对一个包含外键的 InnoDB 表转为 MYISAM 会失败；  </p></li><li><p>InnoDB 是聚集索引，MyISAM 是非聚集索引。聚簇索引的文件存放在主键索引的叶子节点上，因此 InnoDB 必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。而 MyISAM 是非聚集索引，数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。 </p></li><li><p>InnoDB 不保存表的具体行数，执行 select count(*) from table 时需要全表扫描。而MyISAM 用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快；    </p></li></ol><p>\5. InnoDB 最小的锁粒度是行锁，MyISAM 最小的锁粒度是表锁。一个更新语句会锁住整张表，导致其他查询和更新都会被阻塞，因此并发访问受限。这也是 MySQL 将默认存储引擎从 MyISAM 变成 InnoDB 的重要原因之一；</p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库相关</title>
      <link href="/2020/06/02/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3/"/>
      <url>/2020/06/02/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>本章介绍数据库相关。</p></blockquote><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="1-MyISAM和-InnoDB的区别"><a href="#1-MyISAM和-InnoDB的区别" class="headerlink" title="1 MyISAM和 InnoDB的区别"></a>1 MyISAM和 InnoDB的区别</h3><p><strong>区别：</strong></p><p>\1. InnoDB 支持事务，MyISAM 不支持事务。这是 MySQL 将默认存储引擎从 MyISAM 变成 InnoDB 的重要原因之一；</p><p>\2. InnoDB 支持外键，而 MyISAM 不支持。对一个包含外键的 InnoDB 表转为 MYISAM 会失败；  </p><p>\3. InnoDB 是聚集索引，MyISAM 是非聚集索引。聚簇索引的文件存放在主键索引的叶子节点上，因此 InnoDB 必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。而 MyISAM 是非聚集索引，数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。 </p><p>\4. InnoDB 不保存表的具体行数，执行 select count(*) from table 时需要全表扫描。而MyISAM 用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快；    </p><p>\5. InnoDB 最小的锁粒度是行锁，MyISAM 最小的锁粒度是表锁。一个更新语句会锁住整张表，导致其他查询和更新都会被阻塞，因此并发访问受限。这也是 MySQL 将默认存储引擎从 MyISAM 变成 InnoDB 的重要原因之一；</p><p><strong>如何选择：</strong></p><p>\1. 是否要支持事务，如果要请选择 InnoDB，如果不需要可以考虑 MyISAM；</p><p>\2. 如果表中绝大多数都只是读查询，可以考虑 MyISAM，如果既有读写也挺频繁，请使用InnoDB。</p><p>\3. 系统奔溃后，MyISAM恢复起来更困难，能否接受，不能接受就选 InnoDB；</p><p> \4. MySQL5.5版本开始Innodb已经成为Mysql的默认引擎(之前是MyISAM)，说明其优势是有目共睹的。如果你不知道用什么存储引擎，那就用InnoDB，至少不会差。</p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA程序的编译和运行过程</title>
      <link href="/2020/06/02/JAVA%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BC%96%E8%AF%91%E5%92%8C%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B/"/>
      <url>/2020/06/02/JAVA%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BC%96%E8%AF%91%E5%92%8C%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>本章介绍</p></blockquote><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>JAVA程序的编译和运行过程：<br>JAVA程序代码经过编译之后转换为一种称为JAVA字节码的中间语言，JAVA虚拟机(JVM）将对字节码进行解释和运行。编译只进行一次，而解释在每次运行程序时都会运行，编译的字节码采用一种针对JVM优化过度机器码的形式进行保存。虚拟机将字节码解释为机器码，然后在计算机上运行。<br>JAVA语言程序代码的编译和运行过程如图：<br><img src="https://photos.alitaalice.cn/image/20200602091745.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> JAVASE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVASE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>final关键字</title>
      <link href="/2020/05/30/final%E5%85%B3%E9%94%AE%E5%AD%97/"/>
      <url>/2020/05/30/final%E5%85%B3%E9%94%AE%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>本章介绍final关键字</p></blockquote><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>根据程序上下文环境，Java关键字final有“这是无法改变的”或者“终态的”含义，它可以修饰非抽象类、非抽象类成员方法和变量。你可能出于两种理解而需要阻止改变：设计或效率。<br>final类不能被继承，没有子类，final类中的方法默认是final的。<br>final方法不能被子类的方法覆盖，但可以被继承。<br>final成员变量表示常量，只能被赋值一次，赋值后值不再改变。<br>final不能用于修饰构造方法。</p>]]></content>
      
      
      <categories>
          
          <category> JAVASE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVASE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>索引基本操作</title>
      <link href="/2020/05/29/%E7%B4%A2%E5%BC%95%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
      <url>/2020/05/29/%E7%B4%A2%E5%BC%95%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>本章介绍</p></blockquote><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JDK7和JDK8的区别</title>
      <link href="/2020/05/29/JDK7%E5%92%8CJDK8%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2020/05/29/JDK7%E5%92%8CJDK8%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>本章介绍JDK7和JDK8的区别</p></blockquote><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h2 id="JDK-7"><a href="#JDK-7" class="headerlink" title="JDK 7"></a><strong>JDK 7</strong></h2><ol><li>对集合类的语言支持；</li><li>try-with-resources 语句</li><li>使用文件 Path</li><li>改进的通用实例创建类型推断；(？？)</li><li>数字字面量下划线支持；（√）</li><li>switch中使用string；（√）</li><li>二进制字面量；（√）</li><li>简化可变参数方法调用。</li><li>map集合支持并发请求 ，且可以写成 Map map = {name:”xxx”,age:18};</li><li>Boolean类型反转，空指针安全,参与位运算；</li><li>新增一些取环境信息的工具方法；</li></ol><h2 id="JDK-8"><a href="#JDK-8" class="headerlink" title="JDK 8"></a>JDK 8</h2><p>1、<strong>接口可以添加默认方法，default;</strong><br>2、<strong>lambda表达式，对于接口可以直接用()-&gt;{}方式来表达，小括号表示方法入参，花括号内表示方法返回值，如Collections的sort()方法</strong>：<br>3、<strong>函数式接口</strong><br>4、新的日期和时间API<br>5、并发增强<br>6、支持多重注解<br>7、<strong>特性四、反射的加强 。JDK8加强了反射，它允许你直接通过反射获取参数的名字</strong><br>8、 <strong>Stream API</strong> </p><p>Java 8 API添加了一个新的抽象称为流Stream，可以让你以一种声明的方式处理数据。</p><p>Stream 使用一种类似用 SQL 语句从数据库查询数据的直观方式来提供一种对 Java 集合运算和表达的高阶抽象。</p><p>Stream API可以极大提高Java程序员的生产力，让程序员写出高效率、干净、简洁的代码。 9、  JavaScript引擎Nashorn<br>10、Java虚拟机（JVM）的新特性<br>PermGen空间被移除了，取而代之的是Metaspace（JEP 122）。JVM选项-XX:PermSize与-XX:MaxPermSize分别被-XX:MetaSpaceSize与-XX:MaxMetaspaceSize所代替。</p>]]></content>
      
      
      <categories>
          
          <category> JAVASE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVASE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>equals和==的区别</title>
      <link href="/2020/05/29/equals%E5%92%8C-%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2020/05/29/equals%E5%92%8C-%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>本章介绍equals和==的区别</p></blockquote><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p><a href="https://juejin.im/post/5c7ddcd06fb9a04a06059bea">https://juejin.im/post/5c7ddcd06fb9a04a06059bea</a></p>]]></content>
      
      
      <categories>
          
          <category> JAVASE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVASE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Arrays类相关</title>
      <link href="/2020/05/29/Arrays%E7%B1%BB%E7%9B%B8%E5%85%B3/"/>
      <url>/2020/05/29/Arrays%E7%B1%BB%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>本章介绍Arrays类相关.</p></blockquote><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>转<a href="https://blog.csdn.net/LIU_YANZHAO/article/details/70847050?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase">https://blog.csdn.net/LIU_YANZHAO/article/details/70847050?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase</a></p><h1 id="java-List和数组相互转换方法"><a href="#java-List和数组相互转换方法" class="headerlink" title="java List和数组相互转换方法"></a>java List和数组相互转换方法</h1><h3 id="1-List转数组"><a href="#1-List转数组" class="headerlink" title="1 List转数组"></a>1 List转数组</h3><h4 id="toArray-方法"><a href="#toArray-方法" class="headerlink" title="toArray()方法"></a>toArray()方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">      list.add(<span class="string">"1"</span>);</span><br><span class="line">      String[] strings = <span class="keyword">new</span> String[list.size()];</span><br><span class="line">      list.toArray(strings);</span><br><span class="line">      System.out.println(strings);</span><br><span class="line">      System.out.println(strings.getClass());</span><br><span class="line">      System.out.println(Arrays.toString(strings));</span><br></pre></td></tr></table></figure><h3 id="2-数组转List"><a href="#2-数组转List" class="headerlink" title="2 数组转List"></a>2 数组转List</h3><h4 id="使用asList（）"><a href="#使用asList（）" class="headerlink" title="使用asList（）"></a>使用asList（）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;String&gt;(Arrays.asList(arrays));</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JAVASE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVASE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>String为什么设置成不可变类</title>
      <link href="/2020/05/29/String%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AE%BE%E7%BD%AE%E6%88%90%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%B1%BB/"/>
      <url>/2020/05/29/String%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AE%BE%E7%BD%AE%E6%88%90%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>本章介绍String为什么设置成不可变类</p></blockquote><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>转自<a href="https://blog.csdn.net/renfufei/article/details/16808775">https://blog.csdn.net/renfufei/article/details/16808775</a></p><h2 id="不可变对象的好处"><a href="#不可变对象的好处" class="headerlink" title="不可变对象的好处"></a>不可变对象的好处</h2><p>不可变类（Immutable Class）：所谓的不可变类是指这个类的实例一旦创建完成后，就不能改变其成员变量值。如JDK内部自带的很多不可变类：Interger、Long和String等。</p><p>可变类（Mutable Class）：相对于不可变类，可变类创建实例后可以改变其成员变量值，开发中创建的大部分类都属于可变类。</p><p>不可变类的特性对JAVA来说带来怎样的好处？</p><p>1）线程安全：不可变对象是线程安全的，在线程之间可以相互共享，不需要利用特殊机制来保证同步问题，因为对象的值无法改变。可以降低并发错误的可能性，因为不需要用一些锁机制等保证内存一致性问题也减少了同步开销。</p><p>2）易于构造、使用和测试。</p>]]></content>
      
      
      <categories>
          
          <category> JAVASE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVASE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>String,StringBuffer,StringBuilder的区别</title>
      <link href="/2020/05/29/String-StringBuffer-StringBuilder%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2020/05/29/String-StringBuffer-StringBuilder%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>本章介绍String,StringBuffer,StringBuilder的区别</p></blockquote><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>转<a href="https://blog.csdn.net/rmn190/article/details/1492013">https://blog.csdn.net/rmn190/article/details/1492013</a></p>]]></content>
      
      
      <categories>
          
          <category> JAVASE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVASE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>for_each循环</title>
      <link href="/2020/05/29/for-each%E5%BE%AA%E7%8E%AF/"/>
      <url>/2020/05/29/for-each%E5%BE%AA%E7%8E%AF/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>本章介绍for_each循环</p></blockquote><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>for(variable :collection)  statement</p><p>它定义一个变量用于暂存集合中的每一个元素。</p><p>但是collection必须是一个数组或者一个实现了Iterable接口的类对象（例如ArrayList)</p><p>eg:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> element :a)</span><br><span class="line">    System.out.println(element);</span><br></pre></td></tr></table></figure><p>这个循环应该读作 循环a中的每一个元素。</p><p>在for_each 循环语句中的循环变量将会遍历循环数组中的每个元素，而不是下标值。</p>]]></content>
      
      
      <categories>
          
          <category> JAVASE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVASE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMap相关</title>
      <link href="/2020/05/29/HashMap%E7%9B%B8%E5%85%B3/"/>
      <url>/2020/05/29/HashMap%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>本章介绍HashMap相关</p></blockquote><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h2 id="1-基于拉链和线性探测法的散列表"><a href="#1-基于拉链和线性探测法的散列表" class="headerlink" title="1 基于拉链和线性探测法的散列表"></a>1 基于拉链和线性探测法的散列表</h2><p><a href="https://www.alitaalice.cn/2020/05/13/%E5%9F%BA%E4%BA%8E%E6%8B%89%E9%93%BE%E5%92%8C%E7%BA%BF%E6%80%A7%E6%8E%A2%E6%B5%8B%E6%B3%95%E7%9A%84%E6%95%A3%E5%88%97%E8%A1%A8/">https://www.alitaalice.cn/2020/05/13/%E5%9F%BA%E4%BA%8E%E6%8B%89%E9%93%BE%E5%92%8C%E7%BA%BF%E6%80%A7%E6%8E%A2%E6%B5%8B%E6%B3%95%E7%9A%84%E6%95%A3%E5%88%97%E8%A1%A8/</a></p><h2 id="2-hashcode"><a href="#2-hashcode" class="headerlink" title="2 hashcode()"></a>2 hashcode()</h2><p><a href="https://www.alitaalice.cn/2020/05/13/%E6%95%A3%E5%88%97%E8%A1%A8%E8%AF%A6%E8%A7%A3/">https://www.alitaalice.cn/2020/05/13/%E6%95%A3%E5%88%97%E8%A1%A8%E8%AF%A6%E8%A7%A3/</a></p><h2 id="3-HashMap加载因子和初始容量"><a href="#3-HashMap加载因子和初始容量" class="headerlink" title="3 HashMap加载因子和初始容量"></a>3 HashMap加载因子和初始容量</h2><p>转载自<a href="https://www.cnblogs.com/aspirant/p/11470928.html4">https://www.cnblogs.com/aspirant/p/11470928.html4</a></p><h3 id="4-当两个对象的hashcode相同时会发生什么，如何获取对象"><a href="#4-当两个对象的hashcode相同时会发生什么，如何获取对象" class="headerlink" title="4 当两个对象的hashcode相同时会发生什么，如何获取对象"></a>4 当两个对象的hashcode相同时会发生什么，如何获取对象</h3><p>因为hashcode相同，所以它们的bucket位置相同，‘碰撞’会发生。因为HashMap使用链表存储对象，这个Entry(包含有键值对的Map.Entry对象)会存储在链表中。这个时候要理解根据hashcode来划分的数组，如果数组的坐标相同，则进入链表这个数据结构中了，一般的添加都在最前面，也就是和数组下标直接相连的地方，链表长度到达8的时候，jdk1.8上升为红黑树.</p><h3 id="5-HashMap中的tableSizeFor方法"><a href="#5-HashMap中的tableSizeFor方法" class="headerlink" title="5  HashMap中的tableSizeFor方法"></a>5  HashMap中的tableSizeFor方法</h3><p>在使用指定数组的初始容量时上面说过，<strong>数组容量必须是2的次方。所以就需要通过算法将我们给定的数值转换成2的次方。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个方法可以将任意一个整数转换成2的次方。</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-重新调整HashMap大小存在什么问题吗"><a href="#6-重新调整HashMap大小存在什么问题吗" class="headerlink" title="6 重新调整HashMap大小存在什么问题吗"></a>6 重新调整HashMap大小存在什么问题吗</h3><p>当重新调整HashMap大小的时候，确实存在条件竞争，因为如果两个线程都发现HashMap需要重新调整大小了，它们会同时试着调整大小。在调整大小的过程中，存储在链表中的元素的次序会反过来，因为移动到新的bucket位置的时候，HashMap并不会将元素放在链表的尾部，而是放在头部，这是为了避免尾部遍历(tail traversing)。如果条件竞争发生了，那么就死循环了。(多线程的环境下不使用HashMap）</p><p>HashMap的容量是有限的。当经过多次元素插入，使得HashMap达到一定饱和度时，Key映射位置发生冲突的几率会逐渐提高。这时候，HashMap需要扩展它的长度，也就是进行Resize。</p><ol><li>扩容：创建一个新的Entry空数组，长度是原数组的2倍。</li><li>ReHash：遍历原Entry数组，把所有的Entry重新Hash到新数组。</li></ol><h3 id="7-如果HashMap的大小超过了负载因子-load-factor-定义的容量，怎么办？"><a href="#7-如果HashMap的大小超过了负载因子-load-factor-定义的容量，怎么办？" class="headerlink" title="7 如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办？"></a>7 如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办？</h3><p>默认的负载因子大小为0.75，也就是说，当一个map填满了75%的bucket时候，和其它集合类(如ArrayList等)一样，将会创建原来HashMap大小的两倍的bucket数组，来重新调整map的大小，并将原来的对象放入新的bucket数组中。这个过程叫作rehashing，因为它调用hash方法找到新的bucket位置。这个值只可能在两个地方，一个是原下标的位置，另一种是在下标为&lt;原下标+原容量&gt;的位置</p><h3 id="8-我们可以使用自定义的对象作为HashMap的键吗"><a href="#8-我们可以使用自定义的对象作为HashMap的键吗" class="headerlink" title="8 我们可以使用自定义的对象作为HashMap的键吗"></a>8 我们可以使用自定义的对象作为HashMap的键吗</h3><p>作为HashMap的key的自定义类需要重写hashCode()和equals()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.xxx.demo;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 使用HashMap集合,存储自定义的对象。 如果自定义的对象作为键(键不能重复),需要重写自定义类型的hashCode()和equals()方法。</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">function();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">HashMap&lt;Person, String&gt; map = <span class="keyword">new</span> HashMap&lt;Person, String&gt;();</span><br><span class="line">map.put(<span class="keyword">new</span> Person(<span class="string">"a"</span>,<span class="number">20</span>), <span class="string">"里约热内卢"</span>);</span><br><span class="line">map.put(<span class="keyword">new</span> Person(<span class="string">"b"</span>,<span class="number">18</span>), <span class="string">"索马里"</span>);</span><br><span class="line">map.put(<span class="keyword">new</span> Person(<span class="string">"b"</span>,<span class="number">18</span>), <span class="string">"索马里"</span>);</span><br><span class="line">map.put(<span class="keyword">new</span> Person(<span class="string">"c"</span>,<span class="number">19</span>), <span class="string">"百慕大"</span>);</span><br><span class="line"><span class="keyword">for</span>(Person key : map.keySet())&#123;  <span class="comment">// 通过keySet()遍历</span></span><br><span class="line">String value = map.get(key);</span><br><span class="line">System.out.println(key+<span class="string">"..."</span>+value);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"==================="</span>);</span><br><span class="line"><span class="keyword">for</span>(Map.Entry&lt;Person, String&gt; entry : map.entrySet())&#123;  <span class="comment">// 通过entrySet()遍历</span></span><br><span class="line">System.out.println(entry.getKey()+<span class="string">"..."</span>+entry.getValue());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-jdk7和jdk8的HashMap实现的区别"><a href="#9-jdk7和jdk8的HashMap实现的区别" class="headerlink" title="9 jdk7和jdk8的HashMap实现的区别"></a>9 jdk7和jdk8的HashMap实现的区别</h3><p>JDK7中的HashMap</p><p>基于链表+数组实现,底层维护一个Entry数组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Entry&lt;K,V&gt;[] table;</span><br></pre></td></tr></table></figure><p>根据计算的hashCode将对应的KV键值对存储到该table中，一旦发生hashCode冲突，那么就会将该KV键值对放到对应的已有元素的后面， 此时，形成了一个链表式的存储结构,如下图<img src="https://photos.alitaalice.cn/image/20200601154028.png" alt=""></p><p>JDK8中的HashMap</p><p>基于位桶+链表/红黑树的方式实现,底层维护一个Node数组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Node&lt;K,V&gt;[] table;</span><br></pre></td></tr></table></figure><p>在JDK7中HashMap,当成百上千个节点在hash时发生碰撞，存储一个链表中，那么如果要查找其中一个节点，那就不可避免的花费O(N)的查找时间，这将是多么大的性能损失,这个问题终于在JDK8中得到了解决。</p><p>JDK8中,HashMap采用的是位桶+链表/红黑树的方式,当链表的存储的数据个数大于等于8的时候，不再采用链表存储，而采用了红黑树存储结构。这是JDK7与JDK8中HashMap实现的最大区别。 如下图所示：<img src="https://photos.alitaalice.cn/image/20200601154120.png" alt=""></p><h3 id="10-HashMap与LinkedHashMap和TreeMap-Hashtable的区别"><a href="#10-HashMap与LinkedHashMap和TreeMap-Hashtable的区别" class="headerlink" title="10  HashMap与LinkedHashMap和TreeMap Hashtable的区别"></a>10  HashMap与LinkedHashMap和TreeMap Hashtable的区别</h3><p><strong>HashMap</strong>: 最常用的Map,它根据键的HashCode 值存储数据,根据键可以直接获取它的值，具有很快的访问速度。HashMap最多只允许一条记录的键为Null(多条会覆盖);允许多条记录的值为 Null。非同步的。 </p><p><strong>TreeMap</strong>: 能够把它保存的记录根据键(key)排序,默认是按升序排序，也可以指定排序的比较器，当用Iterator 遍历TreeMap时，得到的记录是排过序的。TreeMap不允许key的值为null。非同步的。 </p><p><strong>Hashtable:</strong> 与 HashMap类似,不同的是:key和value的值均不允许为null;它支持线程的同步，即任一时刻只有一个线程能写Hashtable,因此也导致了Hashtable在写入时会比较慢。 </p><p><strong>LinkedHashMap</strong>: 保存了记录的插入顺序，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的.在遍历的时候会比HashMap慢。key和value均允许为空，非同步的。 </p><h3 id="11-为什么-HashMap-中-String、Integer-这样的包装类适合作为-key-键，即为什么使用它们可以减少哈希碰撞？"><a href="#11-为什么-HashMap-中-String、Integer-这样的包装类适合作为-key-键，即为什么使用它们可以减少哈希碰撞？" class="headerlink" title="11 为什么 HashMap 中 String、Integer 这样的包装类适合作为 key 键，即为什么使用它们可以减少哈希碰撞？"></a>11 为什么 HashMap 中 String、Integer 这样的包装类适合作为 key 键，即为什么使用它们可以减少哈希碰撞？</h3><p>答：因为 String、Integer 等包装类是 <strong>final 类型的，具有不可变性，而且已经重写了 equals() 和 hashCode() 方法。</strong>不可变性保证了计算 hashCode() 后键值的唯一性和缓存特性，不会出现放入和获取时哈希码不同的情况且读取哈希值的高效性，此外官方实现的 equals() 和 hashCode() 都是严格遵守相关规范的，不会出现错误</p><p>12.HashMap是线程安全的吗，为什么</p><p>13.哪些是线程安全的容器</p><p>同步容器类：</p><p>使用了synchronized<br>1.Vector<br>2.HashTable</p><p>并发容器：<br>3.ConcurrentHashMap:　底层哈希实现的同步Map(Set)。效率高，线程安全。使用系统底层技术实现线程安全。量级较synchronized低。key和value不能为null<br>4.CopyOnWriteArrayList：写时复制<br>5.CopyOnWriteArraySet：写时复制</p>]]></content>
      
      
      <categories>
          
          <category> JAVA集合 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>try_catch_finally_return的情况</title>
      <link href="/2020/05/28/try-catch-finally-return%E7%9A%84%E6%83%85%E5%86%B5/"/>
      <url>/2020/05/28/try-catch-finally-return%E7%9A%84%E6%83%85%E5%86%B5/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>本章介绍try_catch_finally_return的情况</p></blockquote><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h2 id="try-catch"><a href="#try-catch" class="headerlink" title="try-catch"></a>try-catch</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">  code</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(ExceptionType e)</span><br><span class="line">&#123;</span><br><span class="line">handler <span class="keyword">for</span> <span class="keyword">this</span> type</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果try 语句块中的任何代码抛出了catch 子句中指定的一个异常类</p><p>那么</p><p>1程序将跳过try  语句块</p><p>2程序将执行catch语句块</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(String filename)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> code</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法的首部添加一个throws说明符，提醒调用者这个方法可能会抛出异常</p><h2 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h2><p>代码抛出一个异常时，就会停止处理这个方法中的剩余代码，并且退出这个方法，如果这个方法已经获得了只有它自己知道的一些本地资源，而且这些资源必须清理，finally子句可以解决这个问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">code</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(IOException e)</span><br><span class="line">&#123;</span><br><span class="line">show error message</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span></span><br><span class="line">&#123;</span><br><span class="line">in.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="try-with-resource"><a href="#try-with-resource" class="headerlink" title="try-with-resource"></a>try-with-resource</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">work with the resource</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span></span><br><span class="line">&#123;</span><br><span class="line">close the resource</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*可以用try-with-resource代替 */</span></span><br><span class="line"><span class="keyword">try</span>(Resource res=...)</span><br><span class="line">&#123;</span><br><span class="line">    work with res</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span>块退出时，会自动调用res.close()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JAVASE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVASE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java修饰符：public，protected，private，不加修饰符。有什么区别呢？</title>
      <link href="/2020/05/28/Java%E4%BF%AE%E9%A5%B0%E7%AC%A6%EF%BC%9Apublic%EF%BC%8Cprotected%EF%BC%8Cprivate%EF%BC%8C%E4%B8%8D%E5%8A%A0%E4%BF%AE%E9%A5%B0%E7%AC%A6%E3%80%82%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%E5%91%A2%EF%BC%9F/"/>
      <url>/2020/05/28/Java%E4%BF%AE%E9%A5%B0%E7%AC%A6%EF%BC%9Apublic%EF%BC%8Cprotected%EF%BC%8Cprivate%EF%BC%8C%E4%B8%8D%E5%8A%A0%E4%BF%AE%E9%A5%B0%E7%AC%A6%E3%80%82%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%E5%91%A2%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>本章介绍JAVA修饰符</p></blockquote><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p><img src="https://photos.alitaalice.cn/image/20200715095509.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> JAVASE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVASE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>方法宗量</title>
      <link href="/2020/05/28/%E6%96%B9%E6%B3%95%E5%AE%97%E9%87%8F/"/>
      <url>/2020/05/28/%E6%96%B9%E6%B3%95%E5%AE%97%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>本章介绍方法宗量。</p></blockquote><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>宗量：方法的接收者和方法的参数统称为方法的宗量。</p><p>宗量（argument）,可以理解为<a href="https://en.wikipedia.org/wiki/Argument_of_a_function">自变量</a>，在计算机科学中可能当成<a href="https://en.wikipedia.org/wiki/Parameter_(computer_programming)">形式参数</a>更好理解一些。</p><p>方法的接收者，在运行时可以理解为方法的实际执行者。</p><p>看一下下面的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doRead</span><span class="params">(Book b)</span></span>&#123;</span><br><span class="line">    b.read();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类方法 <code>Book.doRead(Book)</code> 他的接收者就是 <code>Book</code> 这个类对象，他的参数 <code>b</code> 是一个形式参数。意思是在方法没被调用前，b 没有具体的值，就只是一个形式而已，相当于于一个占位符。再来看方法体:<code>b.read()</code>，我们可以说<code>b.read()</code>一定是指向<code>Book#read</code>这个方法吗？也可以不严谨的说 <code>read</code> 的执行者 <code>b</code> 一定是 <code>Book</code> 对象吗？不行的，因为面向对象的多态性，<strong>父类的方法是可以被子类重写的</strong>。只有运行时，我们调用这个方法时才可以确定方法的接收者，比如 <code>Book.doRead(new Magazine())</code>，在运行时实际指向的是 <code>Magazine#read</code>。所以说方法的接收者是形式变量(宗量)。</p>]]></content>
      
      
      <categories>
          
          <category> JAVASE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVASE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>方法签名</title>
      <link href="/2020/05/28/%E6%96%B9%E6%B3%95%E7%AD%BE%E5%90%8D/"/>
      <url>/2020/05/28/%E6%96%B9%E6%B3%95%E7%AD%BE%E5%90%8D/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>本章介绍方法签名</p></blockquote><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>方法签名由方法名称和一个参数列表（方法的参数的顺序和类型）组成。<br>注意，方法签名不包括方法的返回类型。不包括返回值和访问修饰符。</p>]]></content>
      
      
      <categories>
          
          <category> JAVASE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVASE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>复合模式</title>
      <link href="/2020/05/28/%E5%A4%8D%E5%90%88%E6%A8%A1%E5%BC%8F/"/>
      <url>/2020/05/28/%E5%A4%8D%E5%90%88%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>本章介绍</p></blockquote><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>代理模式</title>
      <link href="/2020/05/28/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
      <url>/2020/05/28/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>本章介绍</p></blockquote><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>状态模式</title>
      <link href="/2020/05/28/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/"/>
      <url>/2020/05/28/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>本章介绍</p></blockquote><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>模板方法模式</title>
      <link href="/2020/05/28/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"/>
      <url>/2020/05/28/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>本章介绍模板方法模式</p></blockquote><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>定义： 在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中，模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>适配器模式和外观模式</title>
      <link href="/2020/05/28/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/"/>
      <url>/2020/05/28/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>本章介绍适配器模式和外观模式</p></blockquote><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>OO适配器将一个接口转换为另一个接口，就像转换电源插口的接口那样。</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>适配器模式将一个类的接口，转换成客户期望的另一个接口。适配器让原本接口不兼容的类可以合作无间。</p><h3 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h3><p><strong>提供了一个统一的接口，用来访问子系统的一群接口。外观定义了一个高层接口，让子系统更容易使用。</strong></p><p>设计原则：</p><p><strong>最少知识原则：只和你的密友谈话</strong></p><p>我们要减少对象之间的交互，只留下几个密友。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>命令模式</title>
      <link href="/2020/05/28/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/"/>
      <url>/2020/05/28/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>本章介绍命令模式</p></blockquote><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>这个模式允许我们将动作封装成命令对象，这样一来，我们就可以随心所欲地储存，传递和调用他们。</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>命令模式：</p><p>将请求封装成对象，这可以让你使用不同的请求，队列或者日志请求来参数化其他对象，命令模式也可以支持撤销操作。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java8函数式接口与lambda表达式</title>
      <link href="/2020/05/28/Java8%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3%E4%B8%8ELambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2020/05/28/Java8%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3%E4%B8%8ELambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>本章介绍lambda</p></blockquote><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>转自<a href="https://blog.csdn.net/justloveyou_/article/details/89066782">https://blog.csdn.net/justloveyou_/article/details/89066782</a></p><h2 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h2><p>lambda表达式采用一种简洁的语法来定义代码块。lambda表达式是一个可传递的代码块，可以在以后执行一次或者多次。</p><p>eg:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LengthComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">String</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String first,String second)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> first.length()-senond.length;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">Arrays.sort(strings,<span class="keyword">new</span> LenthComparator());</span><br><span class="line">在JAVA中传递一个代码段并不容易，你不能直接传递代码段，JAVA是一种面向对象的语言，所以必须构造一个对象，这个对象的类需要有一个方法来包含所必须的代码段。</span><br></pre></td></tr></table></figure><h2 id="lambda表达式的语法"><a href="#lambda表达式的语法" class="headerlink" title="lambda表达式的语法"></a>lambda表达式的语法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(String first,String second)</span><br><span class="line">-&gt;first.length()-second.length()</span><br><span class="line">这是一个lambda表达式，lambda表达式是一个代码块，以及必须传入代码的变量规范，</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(String first,String second)-&gt;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(first.length() &lt;second.length() <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(first.length() &gt;second.length() <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line">以上包含显式的<span class="keyword">return</span> 语句</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">即使lambda表达式没有参数，仍然要提供空括号</span><br><span class="line">()-&gt;&#123;<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">100</span>;i&gt;=<span class="number">0</span>;i--) System.out.println(i);&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">如果可以推导出一个lambda表达式的参数类型，则可以忽略其类型。</span><br><span class="line">Comparator&lt;String&gt; compatator=(first,second) -&gt;first.length()-second.length();</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">如果方法只有一个参数，并且这个参数的类型可以推导得出，那么甚至可以省略括号</span><br><span class="line">ActionListener listener =event -&gt;System.out.println(<span class="string">"this time is"</span> +Instant.ofEpochMilli(event.getWhen()));</span><br><span class="line"><span class="function">instead <span class="title">of</span> <span class="params">(event)</span>-&gt;...<span class="title">or</span><span class="params">(ActionEvent event)</span>-&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JAVASE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVASE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单件模式</title>
      <link href="/2020/05/27/%E5%8D%95%E4%BB%B6%E6%A8%A1%E5%BC%8F/"/>
      <url>/2020/05/27/%E5%8D%95%E4%BB%B6%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>本章介绍</p></blockquote><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>单件模式 –&gt;  确保一个类只有一个实例，并提供全局访问点。</p><p>当你需要确保程序中的某个类只有一个实例时，就采用单件模式吧</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSM基础</title>
      <link href="/2020/05/27/SSM%E5%9F%BA%E7%A1%80/"/>
      <url>/2020/05/27/SSM%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>本章介绍</p></blockquote><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>验证二叉搜索树</title>
      <link href="/2020/05/25/%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
      <url>/2020/05/25/%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>本章介绍</p></blockquote><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h4 id="98-验证二叉搜索树"><a href="#98-验证二叉搜索树" class="headerlink" title="98. 验证二叉搜索树"></a><a href="https://leetcode-cn.com/problems/validate-binary-search-tree/">98. 验证二叉搜索树</a></h4><p>难度中等589</p><p>给定一个二叉树，判断其是否是一个有效的二叉搜索树。</p><p>假设一个二叉搜索树具有如下特征：</p><ul><li>节点的左子树只包含<strong>小于</strong>当前节点的数。</li><li>节点的右子树只包含<strong>大于</strong>当前节点的数。</li><li>所有左子树和右子树自身必须也是二叉搜索树。</li></ul><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">    2</span><br><span class="line">   &#x2F; \</span><br><span class="line">  1   3</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">    5</span><br><span class="line">   &#x2F; \</span><br><span class="line">  1   4</span><br><span class="line">     &#x2F; \</span><br><span class="line">    3   6</span><br><span class="line">输出: false</span><br><span class="line">解释: 输入为: [5,1,4,null,null,3,6]。</span><br><span class="line">     根节点的值为 5 ，但是其右子节点值为 4 。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>两数之和</title>
      <link href="/2020/05/25/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
      <url>/2020/05/25/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>本章介绍</p></blockquote><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h4 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a><a href="https://leetcode-cn.com/problems/two-sum/">1. 两数之和</a></h4><p>难度简单8282</p><p>给定一个整数数组 <code>nums</code> 和一个目标值 <code>target</code>，请你在该数组中找出和为目标值的那 <strong>两个</strong> 整数，并返回他们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。</p><p><strong>示例:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">给定 nums = [<span class="number">2</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>], target = <span class="number">9</span></span><br><span class="line"></span><br><span class="line">因为 nums[<span class="number">0</span>] + nums[<span class="number">1</span>] = <span class="number">2</span> + <span class="number">7</span> = <span class="number">9</span></span><br><span class="line">所以返回 [<span class="number">0</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>Solution:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span>  <span class="title">Solution</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> [] twoSum(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> target)</span><br><span class="line">    &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(target-nums[i]))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;map.get(target-nums[i]),i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类加载的过程</title>
      <link href="/2020/05/25/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%9A%84%E8%BF%87%E7%A8%8B/"/>
      <url>/2020/05/25/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%9A%84%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>本章介绍类加载的过程</p></blockquote><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p><img src="https://photos.alitaalice.cn/image/20200525210206.png" alt=""></p><h3 id="1-加载"><a href="#1-加载" class="headerlink" title="1 加载"></a>1 加载</h3><p>JAVA虚拟机需要完成：</p><p>1 通过一个类的全限定名来获取定义此类的二进制字节流</p><p>2 通过这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</p><p>3 在内存中生成一个代表这个类的java.lang.Class对象 作为方法区这个类的各种数据的访问入口。</p><h3 id="2-验证"><a href="#2-验证" class="headerlink" title="2 验证"></a>2 验证</h3><p>验证是连接阶段的第一步，这么做是确保Class文件的字节流中包含的信息符合《JAVA虚拟机规范》的全部约束要求，保证这些信息被当作代码运行后不会危害虚拟机自身的安全</p><p>分为：</p><p>1 文件格式验证</p><p>2 元数据验证</p><p>3 字节码验证</p><p>4 符号引用验证</p><h3 id="3-准备"><a href="#3-准备" class="headerlink" title="3 准备"></a>3 准备</h3><p>准备阶段是正式为类中定义的变量（静态变量、被static修饰的变量）分配内存并设置类变量初始值的阶段，从概念上讲，这些变量所使用的内存都应当在方法区中进行分配</p><h3 id="4-解析"><a href="#4-解析" class="headerlink" title="4 解析"></a>4 解析</h3><p>解析阶段是JAVA虚拟机将常量池内的符号引用替换为直接引用的过程。</p><p>符号引用：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量</p><p>直接引用：直接引用是可以直接指向目标的指针</p><h3 id="5-初始化"><a href="#5-初始化" class="headerlink" title="5 初始化"></a>5 初始化</h3><p>直到初始化阶段，JAVA虚拟机才真正开始执行类中编写的JAVA程序代码，将主导权移交给应用程序。</p><p>初始化阶段就是执行类构造器<clinit>()方法的过程。<clinit>()并不是程序员在JAVA代码中直接编写的方法，它是JAVAC编译器的自动生成物，</p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OutOfMemeryError异常</title>
      <link href="/2020/05/25/OutOfMemeryError%E5%BC%82%E5%B8%B8/"/>
      <url>/2020/05/25/OutOfMemeryError%E5%BC%82%E5%B8%B8/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>本章介绍OutOfMemeryError异常</p></blockquote><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="1-Java堆溢出"><a href="#1-Java堆溢出" class="headerlink" title="1 Java堆溢出"></a>1 Java堆溢出</h3><p><img src="https://photos.alitaalice.cn/image/20200525171739.png" alt=""></p><h3 id="2-虚拟机栈和本地方法栈溢出"><a href="#2-虚拟机栈和本地方法栈溢出" class="headerlink" title="2 虚拟机栈和本地方法栈溢出"></a>2 虚拟机栈和本地方法栈溢出</h3><p><img src="https://photos.alitaalice.cn/image/20200525171954.png" alt=""></p><h3 id="3-方法区和运行时常量池溢出"><a href="#3-方法区和运行时常量池溢出" class="headerlink" title="3 方法区和运行时常量池溢出"></a>3 方法区和运行时常量池溢出</h3><h3 id="4-本地直接内存溢出"><a href="#4-本地直接内存溢出" class="headerlink" title="4 本地直接内存溢出"></a>4 本地直接内存溢出</h3>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>synchronized关键字</title>
      <link href="/2020/05/25/synchronized%E5%85%B3%E9%94%AE%E5%AD%97/"/>
      <url>/2020/05/25/synchronized%E5%85%B3%E9%94%AE%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>本章介绍synchronized关键字</p></blockquote><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>转自<a href="https://juejin.im/post/5adf14dcf265da0b7b358d58#heading-10">https://juejin.im/post/5adf14dcf265da0b7b358d58#heading-10</a></p>]]></content>
      
      
      <categories>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工厂模式</title>
      <link href="/2020/05/22/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
      <url>/2020/05/22/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>本章介绍工厂模式</p></blockquote><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>工厂方法模式：通过让子类决定该创建的对象是什么，来达到将对象创建的过程封装的目的。</p><p>创造者（Creator）类   抽象创建者类。定义抽象的工厂方法，让子类实现此方法制造产品。</p><p>产品类  具体的产品，实际能制造的东西</p><p><img src="https://photos.alitaalice.cn/image/20200525105633.png" alt=""> </p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>词法分析</title>
      <link href="/2020/05/21/%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/"/>
      <url>/2020/05/21/%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>本章介绍</p></blockquote><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><div id="article_content" class="article_content clearfix" style="height: 2193px; overflow: hidden;">            <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-211130ba7a.css">                            <div id="content_views" class="markdown_views">                    <!-- flowchart 箭头图标 勿删 -->                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>                    </svg>                                            <p><strong>摘要：</strong></p><p>　　所谓排序，就是根据排序码的递增或者递减顺序把数据元素依次排列起来，使一组任意排列的元素变为一组按其排序码线性有序的元素。本文将介绍八种最为经典常用的内部排序算法的基本思想与实现，包括插入排序(直接插入排序，希尔排序)、选择排序(直接选择排序，堆排序)、交换排序(冒泡排序，快速排序)、归并排序、分配排序(基数排序)，并给出各种算法的时间复杂度、空间复杂度和稳定性。</p><hr><p><strong>版权声明：</strong></p><p>　　本文原创作者：<a href="http://my.csdn.net/justloveyou_" rel="nofollow" target="_blank">书呆子Rico</a> <br>　　作者博客地址：<a href="http://blog.csdn.net/justloveyou_/" target="_blank">http://blog.csdn.net/justloveyou_/</a></p><hr><p><strong>友情提示：</strong></p><p>　　若读者需要本博文相关完整代码，请移步我的Github自行获取，项目名为 DataStructure(具体算法实现在cn.tju.edu.rico.sort包)，项目链接地址为：<a href="https://github.com/githubofrico/DataStructure" target="_blank">https://github.com/githubofrico/DataStructure</a>。</p><hr><h2 id="一-排序算法概述"><a name="t0"></a><a name="t0"></a>一. 排序算法概述</h2><p>　　所谓排序，就是根据排序码的递增或者递减顺序把数据元素依次排列起来，使一组任意排列的元素变为一组按其排序码线性有序的元素。本文将介绍八种最为经典常用的内部排序算法，包括插入排序(直接插入排序，希尔排序)、选择排序(直接选择排序，堆排序)、交换排序(冒泡排序，快速排序)、归并排序、分配排序(基数排序)。实际上，无论是基本排序方法(直接插入排序，直接选择排序，冒泡排序)，还是高效排序方法(快速排序，堆排序，归并排序)等，它们各有所长，都拥有特定的使用场景。因此，在实际应用中，我们必须根据实际任务的特点和各种排序算法的特性来做出最合适的选择。一般地，我们衡量一个算法的指标包括：</p><ul><li><p>时间复杂度 (在排序过程中需要比较和交换的次数)</p></li><li><p>空间复杂度 (在排序过程中需要的辅助存储空间)</p></li><li><p>稳定性 (该算法的实现是否可以保证排序后相等元素的初始顺序，只要该算法存在一种实现可以保证这种特征，那么该算法就是稳定的)</p></li><li><p>内部排序/外部排序 (在排序过程中数据元素是否完全在内存)</p></li></ul><hr><p>　　笔者将在本文着重探讨上述八种排序算法的思想和实现，并就各算法根据以上指标进行分析和归类，以便进一步熟悉它们各自的应用场景。</p><hr><h2 id="二-插入排序"><a name="t1"></a><a name="t1"></a>二. 插入排序</h2><p>　　<font color="red"><b>插入排序的基本思想</b></font>：每步将一个待排序元素，按其排序码大小插入到前面已经排好序的一组元素中，直到元素全部插入为止。在这里，我们介绍三种具体的插入排序算法：直接插入排序，希尔排序与折半插入排序。</p><hr><p><strong>1、直接插入排序</strong></p><p>　　<font color="red"><b>直接插入排序的思想：</b></font>当插入第i(i&gt;=1)个元素时，前面的V[0],…,V[i-1]等i-1个 元素已经有序。这时，将第i个元素与前i-1个元素V[i-1]，…，V[0]依次比较，找到插入位置即将V[i]插入，同时原来位置上的元素向后顺移。在这里，插入位置的查找是顺序查找。直接插入排序是一种稳定的排序算法，其实现如下：</p><pre class="prettyprint" name="code"><code class="language-java hljs  has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="hljs-javadoc">/**         * Title: 插入排序中的直接插入排序，依赖于初始序列     * Description: 在有序序列中不断插入新的记录以达到扩大有序区到整个数组的目的 *              时间复杂度：最好情形O(n)，平均情形O(n^2)，最差情形O(n^2) *              空间复杂度：O(1) *              稳    定   性：稳定 *              内部排序(在排序过程中数据元素完全在内存) *<span class="hljs-javadoctag"> @author</span> rico        *<span class="hljs-javadoctag"> @created</span> 2017年5月20日 上午10:40:00     */</span>      <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StraightInsertionSort</span> {</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] <span class="hljs-title">insertSort</span>(<span class="hljs-keyword">int</span>[] target){        <span class="hljs-keyword">if</span>(target != <span class="hljs-keyword">null</span> &amp;&amp; target.length != <span class="hljs-number">1</span>){   <span class="hljs-comment">// 待排序数组不为空且长度大于1</span>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; target.length; i++) { <span class="hljs-comment">// 不断扩大有序序列，直到扩展到整个数组</span>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i; j &gt; <span class="hljs-number">0</span>; j--) {    <span class="hljs-comment">// 向有序序列中插入新的元素</span>                    <span class="hljs-keyword">if</span>(target[j]  &lt; target[j-<span class="hljs-number">1</span>]){  <span class="hljs-comment">// 交换</span>                        <span class="hljs-keyword">int</span> temp = target[j];                        target[j] = target[j-<span class="hljs-number">1</span>];                        target[j-<span class="hljs-number">1</span>] = temp;                    }                }            }        }        <span class="hljs-keyword">return</span> target;    }}<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li><li style="color: rgb(153, 153, 153);">8</li><li style="color: rgb(153, 153, 153);">9</li><li style="color: rgb(153, 153, 153);">10</li><li style="color: rgb(153, 153, 153);">11</li><li style="color: rgb(153, 153, 153);">12</li><li style="color: rgb(153, 153, 153);">13</li><li style="color: rgb(153, 153, 153);">14</li><li style="color: rgb(153, 153, 153);">15</li><li style="color: rgb(153, 153, 153);">16</li><li style="color: rgb(153, 153, 153);">17</li><li style="color: rgb(153, 153, 153);">18</li><li style="color: rgb(153, 153, 153);">19</li><li style="color: rgb(153, 153, 153);">20</li><li style="color: rgb(153, 153, 153);">21</li><li style="color: rgb(153, 153, 153);">22</li><li style="color: rgb(153, 153, 153);">23</li><li style="color: rgb(153, 153, 153);">24</li><li style="color: rgb(153, 153, 153);">25</li><li style="color: rgb(153, 153, 153);">26</li><li style="color: rgb(153, 153, 153);">27</li><li style="color: rgb(153, 153, 153);">28</li></ul></pre><hr><p><strong>2、希尔排序</strong></p><p>　　<font color="red"><b>希尔排序的思想：</b></font>设待排序序列共n个元素，首先取一个整数gap&lt;n作为间隔，将全部元素分为间隔为gap的gap个子序列并对每一个子序列进行直接插入排序。然后，缩小间隔gap，重复上述操作，直至gap缩小为1，此时所有元素位于同一个序列且有序。由于刚开始时，gap较大，每个子序列元素较少，排序速度较快；待到排序后期，gap变小，每个子序列元素较多，但大部分元素基本有序，所以排序速度仍较快。一般地，gap取 （gap/3 + 1）。希尔排序是一种不稳定的排序方法，其实现如下：</p><pre class="prettyprint" name="code"><code class="language-java hljs  has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="hljs-javadoc">/**         * Title: 插入排序中的希尔排序，依赖于初始序列     * Description: 分别对间隔为gap的gap个子序列进行直接插入排序，不断缩小gap,直至为 1  *  *              刚开始时，gap较大，每个子序列元素较少，排序速度较快； *              待到排序后期，gap变小，每个子序列元素较多，但大部分元素基本有序，所以排序速度仍较快。                 *  *              时间复杂度：O(n) ~ O(n^2) *              空间复杂度：O(1) *              稳    定   性：不稳定 *              内部排序(在排序过程中数据元素完全在内存) *<span class="hljs-javadoctag"> @author</span> rico        *<span class="hljs-javadoctag"> @created</span> 2017年5月20日 上午10:40:00     */</span>      <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ShellSort</span> {</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">shellSort</span>(<span class="hljs-keyword">int</span>[] target) {        <span class="hljs-keyword">if</span> (target != <span class="hljs-keyword">null</span> &amp;&amp; target.length != <span class="hljs-number">1</span>) {            <span class="hljs-keyword">int</span> gap = target.length;                <span class="hljs-keyword">while</span> (gap &gt; <span class="hljs-number">1</span>) {      <span class="hljs-comment">// gap为int型，自动取整</span>                gap = gap / <span class="hljs-number">3</span> + <span class="hljs-number">1</span>;                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = gap; i &lt; target.length; i++) {                    <span class="hljs-keyword">int</span> j = i - gap;                    <span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span>) {                        <span class="hljs-keyword">if</span> (target[j + gap] &lt; target[j]) {                            swap(target, j, j+gap);                            j -= gap;                        }<span class="hljs-keyword">else</span>{                            <span class="hljs-keyword">break</span>;                        }                    }                }            }        }    }    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span>(<span class="hljs-keyword">int</span>[] target, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j) {        <span class="hljs-keyword">int</span> temp = target[i];        target[i] = target[j];        target[j] = temp;    }}<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li><li style="color: rgb(153, 153, 153);">8</li><li style="color: rgb(153, 153, 153);">9</li><li style="color: rgb(153, 153, 153);">10</li><li style="color: rgb(153, 153, 153);">11</li><li style="color: rgb(153, 153, 153);">12</li><li style="color: rgb(153, 153, 153);">13</li><li style="color: rgb(153, 153, 153);">14</li><li style="color: rgb(153, 153, 153);">15</li><li style="color: rgb(153, 153, 153);">16</li><li style="color: rgb(153, 153, 153);">17</li><li style="color: rgb(153, 153, 153);">18</li><li style="color: rgb(153, 153, 153);">19</li><li style="color: rgb(153, 153, 153);">20</li><li style="color: rgb(153, 153, 153);">21</li><li style="color: rgb(153, 153, 153);">22</li><li style="color: rgb(153, 153, 153);">23</li><li style="color: rgb(153, 153, 153);">24</li><li style="color: rgb(153, 153, 153);">25</li><li style="color: rgb(153, 153, 153);">26</li><li style="color: rgb(153, 153, 153);">27</li><li style="color: rgb(153, 153, 153);">28</li><li style="color: rgb(153, 153, 153);">29</li><li style="color: rgb(153, 153, 153);">30</li><li style="color: rgb(153, 153, 153);">31</li><li style="color: rgb(153, 153, 153);">32</li><li style="color: rgb(153, 153, 153);">33</li><li style="color: rgb(153, 153, 153);">34</li><li style="color: rgb(153, 153, 153);">35</li><li style="color: rgb(153, 153, 153);">36</li><li style="color: rgb(153, 153, 153);">37</li><li style="color: rgb(153, 153, 153);">38</li><li style="color: rgb(153, 153, 153);">39</li><li style="color: rgb(153, 153, 153);">40</li><li style="color: rgb(153, 153, 153);">41</li><li style="color: rgb(153, 153, 153);">42</li></ul></pre><hr><p><strong>3、折半插入排序</strong></p><p>　　<font color="red"><b>折半插入排序的思想：</b></font>当插入第i(i&gt;=1)个元素时，前面的V[0],…,V[i-1]等i-1个 元素已经有序。这时，折半搜索第i个元素在前i-1个元素V[i-1]，…，V[0]中的插入位置，然后直接将V[i]插入，同时原来位置上的元素向后顺移。与直接插入排序不同的是，折半插入排序比直接插入排序明显减少了关键字之间的比较次数，但是移动次数是没有改变。所以，折半插入排序和插入排序的时间复杂度相同都是O（N^2），但其减少了比较次数，所以该算法仍然比直接插入排序好。折半插入排序是一种稳定的排序算法，其实现如下：</p><pre class="prettyprint" name="code"><code class="language-java hljs  has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="hljs-javadoc">/**         * Title: 插入排序中的折半插入排序，依赖于初始序列   * Description: 折半搜索出插入位置，并直接插入;与直接插入搜索的区别是，后者的搜索要快于顺序搜索 *              时间复杂度：折半插入排序比直接插入排序明显减少了关键字之间的比较次数，但是移动次数是没有改变。所以， *              折半插入排序和插入排序的时间复杂度相同都是O（N^2），在减少了比较次数方面它确实相当优秀，所以该算法仍然比直接插入排序好。 *              空间复杂度：O(1) *              稳    定   性：稳定 *              内部排序(在排序过程中数据元素完全在内存) *<span class="hljs-javadoctag"> @author</span> rico        *<span class="hljs-javadoctag"> @created</span> 2017年5月25日 下午12:03:23     */</span>      <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BinaryInsertSort</span> {</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] <span class="hljs-title">binaryInsertSort</span>(<span class="hljs-keyword">int</span>[] target) {        <span class="hljs-keyword">if</span> (target != <span class="hljs-keyword">null</span> &amp;&amp; target.length &gt; <span class="hljs-number">1</span>) {            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; target.length; i++) {                <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;                <span class="hljs-keyword">int</span> right = i - <span class="hljs-number">1</span>;                <span class="hljs-keyword">int</span> mid;                <span class="hljs-keyword">int</span> temp = target[i];                <span class="hljs-keyword">if</span>(temp &lt; target[right]){   <span class="hljs-comment">// 当前值小于有序序列的最大值时，开始查找插入位置</span>                    <span class="hljs-keyword">while</span>(left &lt;= right){                        mid = (left + right)/<span class="hljs-number">2</span>;                        <span class="hljs-keyword">if</span>(target[mid] &lt; temp){                            left = mid + <span class="hljs-number">1</span>;    <span class="hljs-comment">// 缩小插入区间</span>                        }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(target[mid] &gt; temp){                            right = mid - <span class="hljs-number">1</span>;    <span class="hljs-comment">// 缩小插入区间</span>                        }<span class="hljs-keyword">else</span>{        <span class="hljs-comment">// 待插入值与有序序列中的target[mid]相等，保证稳定性的处理</span>                            left = left + <span class="hljs-number">1</span>;                           }                    }                    <span class="hljs-comment">// left及其后面的数据顺序向后移动，并在left位置插入</span>                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i; j &gt; left; j--) {                        target[j] = target[j-<span class="hljs-number">1</span>];                    }                    target[left] = temp;                }            }        }        <span class="hljs-keyword">return</span> target;    }}<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li><li style="color: rgb(153, 153, 153);">8</li><li style="color: rgb(153, 153, 153);">9</li><li style="color: rgb(153, 153, 153);">10</li><li style="color: rgb(153, 153, 153);">11</li><li style="color: rgb(153, 153, 153);">12</li><li style="color: rgb(153, 153, 153);">13</li><li style="color: rgb(153, 153, 153);">14</li><li style="color: rgb(153, 153, 153);">15</li><li style="color: rgb(153, 153, 153);">16</li><li style="color: rgb(153, 153, 153);">17</li><li style="color: rgb(153, 153, 153);">18</li><li style="color: rgb(153, 153, 153);">19</li><li style="color: rgb(153, 153, 153);">20</li><li style="color: rgb(153, 153, 153);">21</li><li style="color: rgb(153, 153, 153);">22</li><li style="color: rgb(153, 153, 153);">23</li><li style="color: rgb(153, 153, 153);">24</li><li style="color: rgb(153, 153, 153);">25</li><li style="color: rgb(153, 153, 153);">26</li><li style="color: rgb(153, 153, 153);">27</li><li style="color: rgb(153, 153, 153);">28</li><li style="color: rgb(153, 153, 153);">29</li><li style="color: rgb(153, 153, 153);">30</li><li style="color: rgb(153, 153, 153);">31</li><li style="color: rgb(153, 153, 153);">32</li><li style="color: rgb(153, 153, 153);">33</li><li style="color: rgb(153, 153, 153);">34</li><li style="color: rgb(153, 153, 153);">35</li><li style="color: rgb(153, 153, 153);">36</li><li style="color: rgb(153, 153, 153);">37</li><li style="color: rgb(153, 153, 153);">38</li><li style="color: rgb(153, 153, 153);">39</li><li style="color: rgb(153, 153, 153);">40</li><li style="color: rgb(153, 153, 153);">41</li><li style="color: rgb(153, 153, 153);">42</li></ul></pre><hr><h2 id="三-选择排序"><a name="t2"></a><a name="t2"></a>三. 选择排序</h2><p>　　<font color="red"><b>选择排序的基本思想：</b></font>每一趟 (例如第i趟，i = 0,1,…)在后面第n-i个待排序元素中选出最小元素作为有序序列的第i个元素，直到第n-1趟结束后，所有元素有序。在这里，我们介绍两种具体的选择排序算法：直接选择排序与堆排序。</p><hr><p><strong>1、直接选择排序</strong></p><p>　　<font color="red"><b>直接选择排序的思想：</b></font>第一次从R[0]~R[n-1]中选取最小值，与R[0]交换，第二次从R<a href="http://static.zybuluo.com/Rico123/ymihfm526o5xv5bo1btvm1fy/%E5%85%AB%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.jpg" rel="nofollow" target="_blank">1</a>~R[n-1]中选取最小值，与R<a href="http://static.zybuluo.com/Rico123/ymihfm526o5xv5bo1btvm1fy/%E5%85%AB%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.jpg" rel="nofollow" target="_blank">1</a>交换，….，第i次从R[i-1]~R[n-1]中选取最小值，与R[i-1]交换，…..，第n-1次从R[n-2]~R[n-1]中选取最小值，与R[n-2]交换，总共通过n-1次，得到一个按排序码从小到大排列的有序序列。直接选择排序是一种不稳定的排序算法，其实现如下：</p><pre class="prettyprint" name="code"><code class="language-java hljs  has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="hljs-javadoc">/**         * Title: 选择排序中的直接选择排序，依赖于初始序列      * Description: 每一趟 (例如第i趟，i = 0,1,...)在后面第n-i个待排序元素中选出最小元素作为有序序列的第i个元素 *              时间复杂度：最好情形O(n^2)，平均情形O(n^2)，最差情形O(n^2) *              空间复杂度：O(1) *              稳    定   性：不稳定 *              内部排序(在排序过程中数据元素完全在内存) *<span class="hljs-javadoctag"> @author</span> rico        *<span class="hljs-javadoctag"> @created</span> 2017年5月20日 上午10:40:00     */</span>      <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StraightSelectSort</span> {</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] <span class="hljs-title">selectSort</span>(<span class="hljs-keyword">int</span>[] target){        <span class="hljs-keyword">if</span>(target != <span class="hljs-keyword">null</span> &amp;&amp; target.length != <span class="hljs-number">1</span>){            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; target.length; i++) {                <span class="hljs-keyword">int</span> min_index = i;                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; target.length; j++) {                    <span class="hljs-keyword">if</span>(target[min_index] &gt; target[j]){                        min_index = j;                    }                }                <span class="hljs-keyword">if</span>(target[min_index] != target[i]){  <span class="hljs-comment">// 导致不稳定的因素：交换</span>                    <span class="hljs-keyword">int</span> min = target[min_index];                    target[min_index] = target[i];                    target[i] = min;                }            }        }        <span class="hljs-keyword">return</span> target;    }}<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li><li style="color: rgb(153, 153, 153);">8</li><li style="color: rgb(153, 153, 153);">9</li><li style="color: rgb(153, 153, 153);">10</li><li style="color: rgb(153, 153, 153);">11</li><li style="color: rgb(153, 153, 153);">12</li><li style="color: rgb(153, 153, 153);">13</li><li style="color: rgb(153, 153, 153);">14</li><li style="color: rgb(153, 153, 153);">15</li><li style="color: rgb(153, 153, 153);">16</li><li style="color: rgb(153, 153, 153);">17</li><li style="color: rgb(153, 153, 153);">18</li><li style="color: rgb(153, 153, 153);">19</li><li style="color: rgb(153, 153, 153);">20</li><li style="color: rgb(153, 153, 153);">21</li><li style="color: rgb(153, 153, 153);">22</li><li style="color: rgb(153, 153, 153);">23</li><li style="color: rgb(153, 153, 153);">24</li><li style="color: rgb(153, 153, 153);">25</li><li style="color: rgb(153, 153, 153);">26</li><li style="color: rgb(153, 153, 153);">27</li><li style="color: rgb(153, 153, 153);">28</li><li style="color: rgb(153, 153, 153);">29</li><li style="color: rgb(153, 153, 153);">30</li></ul></pre><hr><p><strong>2、堆排序</strong></p><p>　　<font color="red"><b>堆排序的核心是堆调整算法。</b></font>首先根据初始输入数据，利用堆调整算法shiftDown()形成初始堆；然后，将堆顶元素与堆尾元素交换，缩小堆的范围并重新调整为堆，如此往复。堆排序是一种不稳定的排序算法，其实现如下：</p><pre class="prettyprint" name="code"><code class="language-java hljs  has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="hljs-javadoc">/**         * Title: 堆排序(选择排序)，升序排序(最大堆)，依赖于初始序列      * Description: 现将给定序列调整为最大堆，然后每次将堆顶元素与堆尾元素交换并缩小堆的范围，直到将堆缩小至1 * 时间复杂度：O(nlgn) * 空间复杂度：O(1)  * 稳 定 性：不稳定 * 内部排序(在排序过程中数据元素完全在内存) *<span class="hljs-javadoctag"> @author</span> rico        *<span class="hljs-javadoctag"> @created</span> 2017年5月25日 上午9:48:06     */</span>      <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HeapSort</span> {</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] <span class="hljs-title">heapSort</span>(<span class="hljs-keyword">int</span>[] target) {        <span class="hljs-keyword">if</span> (target != <span class="hljs-keyword">null</span> &amp;&amp; target.length &gt; <span class="hljs-number">1</span>) {            <span class="hljs-comment">// 调整为最大堆</span>            <span class="hljs-keyword">int</span> pos = (target.length - <span class="hljs-number">2</span>) / <span class="hljs-number">2</span>;            <span class="hljs-keyword">while</span> (pos &gt;= <span class="hljs-number">0</span>) {                shiftDown(target, pos, target.length - <span class="hljs-number">1</span>);                pos--;            }            <span class="hljs-comment">// 堆排序</span>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = target.length-<span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i--) {                <span class="hljs-keyword">int</span> temp = target[i];                target[i] = target[<span class="hljs-number">0</span>];                target[<span class="hljs-number">0</span>] = temp;                shiftDown(target, <span class="hljs-number">0</span>, i-<span class="hljs-number">1</span>);            }            <span class="hljs-keyword">return</span> target;        }        <span class="hljs-keyword">return</span> target;    }    <span class="hljs-javadoc">/**          *<span class="hljs-javadoctag"> @description</span> 自上而下调整为最大堆     *<span class="hljs-javadoctag"> @author</span> rico            *<span class="hljs-javadoctag"> @created</span> 2017年5月25日 上午9:45:40          *<span class="hljs-javadoctag"> @param</span> target     *<span class="hljs-javadoctag"> @param</span> start     *<span class="hljs-javadoctag"> @param</span> end          */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">shiftDown</span>(<span class="hljs-keyword">int</span>[] target, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end) {        <span class="hljs-keyword">int</span> i = start;        <span class="hljs-keyword">int</span> j = <span class="hljs-number">2</span> * start + <span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span> temp = target[i];        <span class="hljs-keyword">while</span> (j &lt;= end) {   <span class="hljs-comment">// 迭代条件</span>            <span class="hljs-keyword">if</span> (j &lt; end &amp;&amp; target[j + <span class="hljs-number">1</span>] &gt; target[j]) {  <span class="hljs-comment">//找出较大子女</span>                j = j + <span class="hljs-number">1</span>;            }            <span class="hljs-keyword">if</span> (target[j] &lt;= temp) {  <span class="hljs-comment">// 父亲大于子女</span>                <span class="hljs-keyword">break</span>;            } <span class="hljs-keyword">else</span> {                target[i] = target[j];                i = j;                j = <span class="hljs-number">2</span> * j + <span class="hljs-number">1</span>;            }        }        target[i] = temp;    }}<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li><li style="color: rgb(153, 153, 153);">8</li><li style="color: rgb(153, 153, 153);">9</li><li style="color: rgb(153, 153, 153);">10</li><li style="color: rgb(153, 153, 153);">11</li><li style="color: rgb(153, 153, 153);">12</li><li style="color: rgb(153, 153, 153);">13</li><li style="color: rgb(153, 153, 153);">14</li><li style="color: rgb(153, 153, 153);">15</li><li style="color: rgb(153, 153, 153);">16</li><li style="color: rgb(153, 153, 153);">17</li><li style="color: rgb(153, 153, 153);">18</li><li style="color: rgb(153, 153, 153);">19</li><li style="color: rgb(153, 153, 153);">20</li><li style="color: rgb(153, 153, 153);">21</li><li style="color: rgb(153, 153, 153);">22</li><li style="color: rgb(153, 153, 153);">23</li><li style="color: rgb(153, 153, 153);">24</li><li style="color: rgb(153, 153, 153);">25</li><li style="color: rgb(153, 153, 153);">26</li><li style="color: rgb(153, 153, 153);">27</li><li style="color: rgb(153, 153, 153);">28</li><li style="color: rgb(153, 153, 153);">29</li><li style="color: rgb(153, 153, 153);">30</li><li style="color: rgb(153, 153, 153);">31</li><li style="color: rgb(153, 153, 153);">32</li><li style="color: rgb(153, 153, 153);">33</li><li style="color: rgb(153, 153, 153);">34</li><li style="color: rgb(153, 153, 153);">35</li><li style="color: rgb(153, 153, 153);">36</li><li style="color: rgb(153, 153, 153);">37</li><li style="color: rgb(153, 153, 153);">38</li><li style="color: rgb(153, 153, 153);">39</li><li style="color: rgb(153, 153, 153);">40</li><li style="color: rgb(153, 153, 153);">41</li><li style="color: rgb(153, 153, 153);">42</li><li style="color: rgb(153, 153, 153);">43</li><li style="color: rgb(153, 153, 153);">44</li><li style="color: rgb(153, 153, 153);">45</li><li style="color: rgb(153, 153, 153);">46</li><li style="color: rgb(153, 153, 153);">47</li><li style="color: rgb(153, 153, 153);">48</li><li style="color: rgb(153, 153, 153);">49</li><li style="color: rgb(153, 153, 153);">50</li><li style="color: rgb(153, 153, 153);">51</li><li style="color: rgb(153, 153, 153);">52</li><li style="color: rgb(153, 153, 153);">53</li><li style="color: rgb(153, 153, 153);">54</li><li style="color: rgb(153, 153, 153);">55</li><li style="color: rgb(153, 153, 153);">56</li><li style="color: rgb(153, 153, 153);">57</li><li style="color: rgb(153, 153, 153);">58</li><li style="color: rgb(153, 153, 153);">59</li><li style="color: rgb(153, 153, 153);">60</li><li style="color: rgb(153, 153, 153);">61</li><li style="color: rgb(153, 153, 153);">62</li></ul></pre><hr><h2 id="四-交换排序"><a name="t3"></a><a name="t3"></a>四. 交换排序</h2><p>　　<font color="red"><b>交换排序的基本思想：</b></font>根据序列中两个元素的比较结果来对换这两个记录在序列中的位置，也就是说，将键值较大的记录向序列的尾部移动，键值较小的记录向序列的前部移动。</p><hr><p><strong>1、冒泡排序</strong></p><p>　　<font color="red"><b>冒泡排序的思想：</b></font>根据序列中两个元素的比较结果来对换这两个记录在序列中的位置，将键值较大的记录向序列的尾部移动，键值较小的记录向序列的前部移动。因此，每一趟都将较小的元素移到前面，较大的元素自然就逐渐沉到最后面了，也就是说，最大的元素最后才能确定，这就是冒泡。冒泡排序是一种稳定的排序算法，其实现如下：</p><pre class="prettyprint" name="code"><code class="language-java hljs  has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="hljs-javadoc">/** * Title: 交换排序中的冒泡排序 ，一般情形下指的是优化后的冒泡排序，最多进行n-1次比较，依赖于初始序列   * Description:因为越大的元素会经由交换慢慢"浮"到数列的顶端(最后位置)，最大的数最后才确定下来，所以称为冒泡排序 * 时间复杂度：最好情形O(n)，平均情形O(n^2)，最差情形O(n^2)  * 空间复杂度：O(1)  * 稳 定 性：稳定 * 内部排序(在排序过程中数据元素完全在内存) *  *<span class="hljs-javadoctag"> @author</span> rico *<span class="hljs-javadoctag"> @created</span> 2017年5月20日 上午10:40:00 */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BubbleSort</span> {</span>    <span class="hljs-javadoc">/**          *<span class="hljs-javadoctag"> @description</span> 朴素冒泡排序(共进行n-1次比较)     *<span class="hljs-javadoctag"> @author</span> rico              */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] <span class="hljs-title">bubbleSort</span>(<span class="hljs-keyword">int</span>[] target) {        <span class="hljs-keyword">int</span> n = target.length;        <span class="hljs-keyword">if</span> (target != <span class="hljs-keyword">null</span> &amp;&amp; n != <span class="hljs-number">1</span>) {            <span class="hljs-comment">// 最多需要进行n-1躺，每一趟将比较小的元素移到前面，比较大的元素自然就逐渐沉到最后面了，这就是冒泡</span>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n-<span class="hljs-number">1</span>; i++) {                      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = n-<span class="hljs-number">1</span>; j &gt; i; j--) {                    <span class="hljs-keyword">if</span>(target[j] &lt; target[j-<span class="hljs-number">1</span>]){                        <span class="hljs-keyword">int</span> temp = target[j];                        target[j] = target[j-<span class="hljs-number">1</span>];                        target[j-<span class="hljs-number">1</span>] = temp;                    }                }                System.out.println(Arrays.toString(target));            }        }        <span class="hljs-keyword">return</span> target;    }    <span class="hljs-javadoc">/**          *<span class="hljs-javadoctag"> @description</span> 优化冒泡排序     *<span class="hljs-javadoctag"> @author</span> rico              */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] <span class="hljs-title">optimizeBubbleSort</span>(<span class="hljs-keyword">int</span>[] target) {        <span class="hljs-keyword">int</span> n = target.length;        <span class="hljs-keyword">if</span> (target != <span class="hljs-keyword">null</span> &amp;&amp; n != <span class="hljs-number">1</span>) {            <span class="hljs-comment">// 最多需要进行n-1躺，每一趟将比较小的元素移到前面，比较大的元素自然就逐渐沉到最后面了，这就是冒泡</span>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n-<span class="hljs-number">1</span>; i++) {                      <span class="hljs-keyword">boolean</span> exchange = <span class="hljs-keyword">false</span>;                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = n-<span class="hljs-number">1</span>; j &gt; i; j--) {                    <span class="hljs-keyword">if</span>(target[j] &lt; target[j-<span class="hljs-number">1</span>]){                        <span class="hljs-keyword">int</span> temp = target[j];                        target[j] = target[j-<span class="hljs-number">1</span>];                        target[j-<span class="hljs-number">1</span>] = temp;                        exchange = <span class="hljs-keyword">true</span>;                    }                }                System.out.println(Arrays.toString(target));                <span class="hljs-keyword">if</span> (!exchange){    <span class="hljs-comment">// 若 i 到 n-1 这部分元素已经有序，则直接返回</span>                    <span class="hljs-keyword">return</span> target;                }            }        }        <span class="hljs-keyword">return</span> target;    }}<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li><li style="color: rgb(153, 153, 153);">8</li><li style="color: rgb(153, 153, 153);">9</li><li style="color: rgb(153, 153, 153);">10</li><li style="color: rgb(153, 153, 153);">11</li><li style="color: rgb(153, 153, 153);">12</li><li style="color: rgb(153, 153, 153);">13</li><li style="color: rgb(153, 153, 153);">14</li><li style="color: rgb(153, 153, 153);">15</li><li style="color: rgb(153, 153, 153);">16</li><li style="color: rgb(153, 153, 153);">17</li><li style="color: rgb(153, 153, 153);">18</li><li style="color: rgb(153, 153, 153);">19</li><li style="color: rgb(153, 153, 153);">20</li><li style="color: rgb(153, 153, 153);">21</li><li style="color: rgb(153, 153, 153);">22</li><li style="color: rgb(153, 153, 153);">23</li><li style="color: rgb(153, 153, 153);">24</li><li style="color: rgb(153, 153, 153);">25</li><li style="color: rgb(153, 153, 153);">26</li><li style="color: rgb(153, 153, 153);">27</li><li style="color: rgb(153, 153, 153);">28</li><li style="color: rgb(153, 153, 153);">29</li><li style="color: rgb(153, 153, 153);">30</li><li style="color: rgb(153, 153, 153);">31</li><li style="color: rgb(153, 153, 153);">32</li><li style="color: rgb(153, 153, 153);">33</li><li style="color: rgb(153, 153, 153);">34</li><li style="color: rgb(153, 153, 153);">35</li><li style="color: rgb(153, 153, 153);">36</li><li style="color: rgb(153, 153, 153);">37</li><li style="color: rgb(153, 153, 153);">38</li><li style="color: rgb(153, 153, 153);">39</li><li style="color: rgb(153, 153, 153);">40</li><li style="color: rgb(153, 153, 153);">41</li><li style="color: rgb(153, 153, 153);">42</li><li style="color: rgb(153, 153, 153);">43</li><li style="color: rgb(153, 153, 153);">44</li><li style="color: rgb(153, 153, 153);">45</li><li style="color: rgb(153, 153, 153);">46</li><li style="color: rgb(153, 153, 153);">47</li><li style="color: rgb(153, 153, 153);">48</li><li style="color: rgb(153, 153, 153);">49</li><li style="color: rgb(153, 153, 153);">50</li><li style="color: rgb(153, 153, 153);">51</li><li style="color: rgb(153, 153, 153);">52</li><li style="color: rgb(153, 153, 153);">53</li><li style="color: rgb(153, 153, 153);">54</li><li style="color: rgb(153, 153, 153);">55</li><li style="color: rgb(153, 153, 153);">56</li><li style="color: rgb(153, 153, 153);">57</li><li style="color: rgb(153, 153, 153);">58</li><li style="color: rgb(153, 153, 153);">59</li><li style="color: rgb(153, 153, 153);">60</li><li style="color: rgb(153, 153, 153);">61</li><li style="color: rgb(153, 153, 153);">62</li></ul></pre><hr><p><strong>2、快速排序</strong></p><p>　　<font color="red"><b>快速排序的思想：</b></font>通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小(划分过程)，然后再按此方法对这两部分数据分别进行快速排序(快速排序过程)，整个排序过程可以递归进行，以此达到整个数据变成有序序列。快速排序是一种不稳定的排序算法。</p><pre class="prettyprint" name="code"><code class="language-java hljs  has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="hljs-javadoc">/** * Title: 交换排序中的快速排序，目前应用最为广泛的排序算法，是一个递归算法，依赖于初始序列   * Description:快速排序包括两个过程：划分 和 快排 * "划分"是指将原序列按基准元素划分两个子序列 * "快排"是指分别对子序列进行快排 *  * 就平均计算时间而言，快速排序是所有内部排序方法中最好的一个 *  * 对大规模数据排序时，快排是快的；对小规模数据排序时，快排是慢的，甚至慢于简单选择排序等简单排序方法 *  * 快速排序依赖于原始序列，因此其时间复杂度从O(nlgn)到O(n^2)不等 * 时间复杂度：最好情形O(nlgn)，平均情形O(nlgn)，最差情形O(n^2) *  * 递归所消耗的栈空间 * 空间复杂度：O(lgn) *  * 可选任一元素作为基准元素 * 稳 定 性：不稳定 *  *  * 内部排序(在排序过程中数据元素完全在内存) *  *<span class="hljs-javadoctag"> @author</span> rico *<span class="hljs-javadoctag"> @created</span> 2017年5月20日 上午10:40:00 */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">QuickSort</span> {</span>    <span class="hljs-javadoc">/**          *<span class="hljs-javadoctag"> @description</span> 快排算法(递归算法)：在递去过程中就把问题解决了     *<span class="hljs-javadoctag"> @author</span> rico            *<span class="hljs-javadoctag"> @created</span> 2017年5月20日 下午5:12:06          *<span class="hljs-javadoctag"> @param</span> target     *<span class="hljs-javadoctag"> @param</span> left     *<span class="hljs-javadoctag"> @param</span> right     *<span class="hljs-javadoctag"> @return</span>          */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] <span class="hljs-title">quickSort</span>(<span class="hljs-keyword">int</span>[] target, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right) {        <span class="hljs-keyword">if</span>(right &gt; left){     <span class="hljs-comment">// 递归终止条件</span>            <span class="hljs-keyword">int</span> base_index = partition(target,left, right);  <span class="hljs-comment">// 原序列划分后基准元素的位置</span>            quickSort(target, left, base_index-<span class="hljs-number">1</span>);    <span class="hljs-comment">// 对第一个子序列快速排序，不包含基准元素！</span>            quickSort(target, base_index+<span class="hljs-number">1</span>, right);   <span class="hljs-comment">// 对第二个子序列快速排序，不包含基准元素！</span>            <span class="hljs-keyword">return</span> target;        }        <span class="hljs-keyword">return</span> target;    }    <span class="hljs-javadoc">/**          *<span class="hljs-javadoctag"> @description</span> 序列划分，以第一个元素为基准元素     *<span class="hljs-javadoctag"> @author</span> rico            *<span class="hljs-javadoctag"> @created</span> 2017年5月20日 下午5:10:54          *<span class="hljs-javadoctag"> @param</span> target  序列     *<span class="hljs-javadoctag"> @param</span> left 序列左端     *<span class="hljs-javadoctag"> @param</span> right  序列右端     *<span class="hljs-javadoctag"> @return</span>          */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">partition</span>(<span class="hljs-keyword">int</span>[] target, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right){        <span class="hljs-keyword">int</span> base = target[left];   <span class="hljs-comment">// 基准元素的值</span>        <span class="hljs-keyword">int</span> base_index = left;    <span class="hljs-comment">// 基准元素最终应该在的位置</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = left+<span class="hljs-number">1</span>; i &lt;= right; i++) {  <span class="hljs-comment">// 从基准元素的下一个元素开始</span>            <span class="hljs-keyword">if</span>(target[i] &lt; base){       <span class="hljs-comment">//  若其小于基准元素</span>                base_index++;           <span class="hljs-comment">// 若其小于基准元素,则基准元素最终位置后移；否则不用移动</span>                <span class="hljs-keyword">if</span>(base_index != i){    <span class="hljs-comment">// 相等情况意味着i之前的元素都小于base,只需要换一次即可，不需要次次都换</span>                    <span class="hljs-keyword">int</span> temp = target[base_index];                    target[base_index] = target[i];                    target[i] = temp;                }            }        }        <span class="hljs-comment">// 将基准元素就位</span>        target[left] = target[base_index];           target[base_index] = base;        System.out.println(Arrays.toString(target));        <span class="hljs-keyword">return</span> base_index;  <span class="hljs-comment">//返回划分后基准元素的位置</span>    }}<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li><li style="color: rgb(153, 153, 153);">8</li><li style="color: rgb(153, 153, 153);">9</li><li style="color: rgb(153, 153, 153);">10</li><li style="color: rgb(153, 153, 153);">11</li><li style="color: rgb(153, 153, 153);">12</li><li style="color: rgb(153, 153, 153);">13</li><li style="color: rgb(153, 153, 153);">14</li><li style="color: rgb(153, 153, 153);">15</li><li style="color: rgb(153, 153, 153);">16</li><li style="color: rgb(153, 153, 153);">17</li><li style="color: rgb(153, 153, 153);">18</li><li style="color: rgb(153, 153, 153);">19</li><li style="color: rgb(153, 153, 153);">20</li><li style="color: rgb(153, 153, 153);">21</li><li style="color: rgb(153, 153, 153);">22</li><li style="color: rgb(153, 153, 153);">23</li><li style="color: rgb(153, 153, 153);">24</li><li style="color: rgb(153, 153, 153);">25</li><li style="color: rgb(153, 153, 153);">26</li><li style="color: rgb(153, 153, 153);">27</li><li style="color: rgb(153, 153, 153);">28</li><li style="color: rgb(153, 153, 153);">29</li><li style="color: rgb(153, 153, 153);">30</li><li style="color: rgb(153, 153, 153);">31</li><li style="color: rgb(153, 153, 153);">32</li><li style="color: rgb(153, 153, 153);">33</li><li style="color: rgb(153, 153, 153);">34</li><li style="color: rgb(153, 153, 153);">35</li><li style="color: rgb(153, 153, 153);">36</li><li style="color: rgb(153, 153, 153);">37</li><li style="color: rgb(153, 153, 153);">38</li><li style="color: rgb(153, 153, 153);">39</li><li style="color: rgb(153, 153, 153);">40</li><li style="color: rgb(153, 153, 153);">41</li><li style="color: rgb(153, 153, 153);">42</li><li style="color: rgb(153, 153, 153);">43</li><li style="color: rgb(153, 153, 153);">44</li><li style="color: rgb(153, 153, 153);">45</li><li style="color: rgb(153, 153, 153);">46</li><li style="color: rgb(153, 153, 153);">47</li><li style="color: rgb(153, 153, 153);">48</li><li style="color: rgb(153, 153, 153);">49</li><li style="color: rgb(153, 153, 153);">50</li><li style="color: rgb(153, 153, 153);">51</li><li style="color: rgb(153, 153, 153);">52</li><li style="color: rgb(153, 153, 153);">53</li><li style="color: rgb(153, 153, 153);">54</li><li style="color: rgb(153, 153, 153);">55</li><li style="color: rgb(153, 153, 153);">56</li><li style="color: rgb(153, 153, 153);">57</li><li style="color: rgb(153, 153, 153);">58</li><li style="color: rgb(153, 153, 153);">59</li><li style="color: rgb(153, 153, 153);">60</li><li style="color: rgb(153, 153, 153);">61</li><li style="color: rgb(153, 153, 153);">62</li><li style="color: rgb(153, 153, 153);">63</li><li style="color: rgb(153, 153, 153);">64</li><li style="color: rgb(153, 153, 153);">65</li><li style="color: rgb(153, 153, 153);">66</li><li style="color: rgb(153, 153, 153);">67</li><li style="color: rgb(153, 153, 153);">68</li><li style="color: rgb(153, 153, 153);">69</li><li style="color: rgb(153, 153, 153);">70</li><li style="color: rgb(153, 153, 153);">71</li><li style="color: rgb(153, 153, 153);">72</li><li style="color: rgb(153, 153, 153);">73</li><li style="color: rgb(153, 153, 153);">74</li><li style="color: rgb(153, 153, 153);">75</li><li style="color: rgb(153, 153, 153);">76</li><li style="color: rgb(153, 153, 153);">77</li><li style="color: rgb(153, 153, 153);">78</li><li style="color: rgb(153, 153, 153);">79</li><li style="color: rgb(153, 153, 153);">80</li><li style="color: rgb(153, 153, 153);">81</li><li style="color: rgb(153, 153, 153);">82</li></ul></pre><hr><h2 id="五-归并排序"><a name="t4"></a><a name="t4"></a>五. 归并排序</h2><p>　　<font color="red"><b>归并排序包含两个过程：”归”和”并”。</b></font>其中，”归”是指将原序列分成半子序列，分别对子序列进行递归排序；”并”是指将排好序的各子序列合并成原序列。归并排序算法是一个典型的递归算法，因此也是概念上最为简单的排序算法。与快速排序算法相比，归并排序算法不依赖于初始序列，并且是一种稳定的排序算法，但需要与原序列一样大小的辅助存储空间。</p><pre class="prettyprint" name="code"><code class="language-java hljs  has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="hljs-javadoc">/** * Title: 归并排序 ，概念上最为简单的排序算法，是一个递归算法 Description:归并排序包括两个过程：归 和 并 * "归"是指将原序列分成半子序列，分别对子序列进行递归排序 "并"是指将排好序的各子序列合并成原序列 *  * 归并排序的主要问题是：需要一个与原待排序数组一样大的辅助数组空间 *  * 归并排序不依赖于原始序列，因此其最好情形、平均情形和最差情形时间复杂度都一样 时间复杂度：最好情形O(n)，平均情形O(n^2)，最差情形O(n^2) * 空间复杂度：O(n) 稳 定 性：稳定 内部排序(在排序过程中数据元素完全在内存) *  *<span class="hljs-javadoctag"> @author</span> rico *<span class="hljs-javadoctag"> @created</span> 2017年5月20日 上午10:40:00 */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MergeSort</span> {</span>    <span class="hljs-javadoc">/**     *<span class="hljs-javadoctag"> @description</span> 归并排序算法(递归算法)：递去分解，归来合并     *<span class="hljs-javadoctag"> @author</span> rico     *<span class="hljs-javadoctag"> @created</span> 2017年5月20日 下午4:04:52     *<span class="hljs-javadoctag"> @param</span> target     *            待排序序列     *<span class="hljs-javadoctag"> @param</span> left     *            待排序序列起始位置     *<span class="hljs-javadoctag"> @param</span> right     *            待排序序列终止位置     *<span class="hljs-javadoctag"> @return</span>     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mergeSort</span>(<span class="hljs-keyword">int</span>[] target) {        <span class="hljs-keyword">int</span>[] copy = Arrays.copyOf(target, target.length);    <span class="hljs-comment">// 空间复杂度O(n)</span>        mergeSort(target, copy, <span class="hljs-number">0</span>, target.length - <span class="hljs-number">1</span>);    }    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mergeSort</span>(<span class="hljs-keyword">int</span>[] target, <span class="hljs-keyword">int</span>[] copy, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right) {        <span class="hljs-keyword">if</span> (right &gt; left) { <span class="hljs-comment">// 递归终止条件</span>            <span class="hljs-keyword">int</span> mid = (left + right) / <span class="hljs-number">2</span>;            mergeSort(target, copy, left, mid); <span class="hljs-comment">// 归并排序第一个子序列</span>            mergeSort(target, copy, mid + <span class="hljs-number">1</span>, right); <span class="hljs-comment">// 归并排序第二个子序列</span>            merge(target, copy, left, mid, right); <span class="hljs-comment">// 合并子序列成原序列</span>        }    }    <span class="hljs-javadoc">/**     *<span class="hljs-javadoctag"> @description</span> 两路归并算法     *<span class="hljs-javadoctag"> @author</span> rico     *<span class="hljs-javadoctag"> @created</span> 2017年5月20日 下午3:59:16     *<span class="hljs-javadoctag"> @param</span> target     *            用于存储归并结果     *<span class="hljs-javadoctag"> @param</span> left     *            第一个有序表的第一个元素所在位置     *<span class="hljs-javadoctag"> @param</span> mid     *            第一个有序表的最后一个元素所在位置     *<span class="hljs-javadoctag"> @param</span> right     *            第二个有序表的最后一个元素所在位置     *<span class="hljs-javadoctag"> @return</span>     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">merge</span>(<span class="hljs-keyword">int</span>[] target, <span class="hljs-keyword">int</span>[] copy, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> mid,            <span class="hljs-keyword">int</span> right) {        <span class="hljs-comment">// s1,s2是检查指针，index 是存放指针</span>        <span class="hljs-keyword">int</span> s1 = left;        <span class="hljs-keyword">int</span> s2 = mid + <span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span> index = left;        <span class="hljs-comment">// 两个表都未检查完，两两比较</span>        <span class="hljs-keyword">while</span> (s1 &lt;= mid &amp;&amp; s2 &lt;= right) {            <span class="hljs-keyword">if</span> (copy[s1] &lt;= copy[s2]) { <span class="hljs-comment">// 稳定性</span>                target[index++] = copy[s1++];            } <span class="hljs-keyword">else</span> {                target[index++] = copy[s2++];            }        }        <span class="hljs-comment">// 若第一个表未检查完，复制</span>        <span class="hljs-keyword">while</span> (s1 &lt;= mid) {            target[index++] = copy[s1++];        }        <span class="hljs-comment">// 若第二个表未检查完，复制</span>        <span class="hljs-keyword">while</span> (s2 &lt;= right) {            target[index++] = copy[s2++];        }        <span class="hljs-comment">// 更新辅助数组 copy</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = left; i &lt;= right; i++) {            copy[i] = target[i];        }    }<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li><li style="color: rgb(153, 153, 153);">8</li><li style="color: rgb(153, 153, 153);">9</li><li style="color: rgb(153, 153, 153);">10</li><li style="color: rgb(153, 153, 153);">11</li><li style="color: rgb(153, 153, 153);">12</li><li style="color: rgb(153, 153, 153);">13</li><li style="color: rgb(153, 153, 153);">14</li><li style="color: rgb(153, 153, 153);">15</li><li style="color: rgb(153, 153, 153);">16</li><li style="color: rgb(153, 153, 153);">17</li><li style="color: rgb(153, 153, 153);">18</li><li style="color: rgb(153, 153, 153);">19</li><li style="color: rgb(153, 153, 153);">20</li><li style="color: rgb(153, 153, 153);">21</li><li style="color: rgb(153, 153, 153);">22</li><li style="color: rgb(153, 153, 153);">23</li><li style="color: rgb(153, 153, 153);">24</li><li style="color: rgb(153, 153, 153);">25</li><li style="color: rgb(153, 153, 153);">26</li><li style="color: rgb(153, 153, 153);">27</li><li style="color: rgb(153, 153, 153);">28</li><li style="color: rgb(153, 153, 153);">29</li><li style="color: rgb(153, 153, 153);">30</li><li style="color: rgb(153, 153, 153);">31</li><li style="color: rgb(153, 153, 153);">32</li><li style="color: rgb(153, 153, 153);">33</li><li style="color: rgb(153, 153, 153);">34</li><li style="color: rgb(153, 153, 153);">35</li><li style="color: rgb(153, 153, 153);">36</li><li style="color: rgb(153, 153, 153);">37</li><li style="color: rgb(153, 153, 153);">38</li><li style="color: rgb(153, 153, 153);">39</li><li style="color: rgb(153, 153, 153);">40</li><li style="color: rgb(153, 153, 153);">41</li><li style="color: rgb(153, 153, 153);">42</li><li style="color: rgb(153, 153, 153);">43</li><li style="color: rgb(153, 153, 153);">44</li><li style="color: rgb(153, 153, 153);">45</li><li style="color: rgb(153, 153, 153);">46</li><li style="color: rgb(153, 153, 153);">47</li><li style="color: rgb(153, 153, 153);">48</li><li style="color: rgb(153, 153, 153);">49</li><li style="color: rgb(153, 153, 153);">50</li><li style="color: rgb(153, 153, 153);">51</li><li style="color: rgb(153, 153, 153);">52</li><li style="color: rgb(153, 153, 153);">53</li><li style="color: rgb(153, 153, 153);">54</li><li style="color: rgb(153, 153, 153);">55</li><li style="color: rgb(153, 153, 153);">56</li><li style="color: rgb(153, 153, 153);">57</li><li style="color: rgb(153, 153, 153);">58</li><li style="color: rgb(153, 153, 153);">59</li><li style="color: rgb(153, 153, 153);">60</li><li style="color: rgb(153, 153, 153);">61</li><li style="color: rgb(153, 153, 153);">62</li><li style="color: rgb(153, 153, 153);">63</li><li style="color: rgb(153, 153, 153);">64</li><li style="color: rgb(153, 153, 153);">65</li><li style="color: rgb(153, 153, 153);">66</li><li style="color: rgb(153, 153, 153);">67</li><li style="color: rgb(153, 153, 153);">68</li><li style="color: rgb(153, 153, 153);">69</li><li style="color: rgb(153, 153, 153);">70</li><li style="color: rgb(153, 153, 153);">71</li><li style="color: rgb(153, 153, 153);">72</li><li style="color: rgb(153, 153, 153);">73</li><li style="color: rgb(153, 153, 153);">74</li><li style="color: rgb(153, 153, 153);">75</li><li style="color: rgb(153, 153, 153);">76</li><li style="color: rgb(153, 153, 153);">77</li><li style="color: rgb(153, 153, 153);">78</li><li style="color: rgb(153, 153, 153);">79</li><li style="color: rgb(153, 153, 153);">80</li><li style="color: rgb(153, 153, 153);">81</li><li style="color: rgb(153, 153, 153);">82</li><li style="color: rgb(153, 153, 153);">83</li><li style="color: rgb(153, 153, 153);">84</li><li style="color: rgb(153, 153, 153);">85</li><li style="color: rgb(153, 153, 153);">86</li><li style="color: rgb(153, 153, 153);">87</li></ul></pre><p>　　Ps : 归并排序和快速排序都是典型的递归算法，因此它们比较容易理解和实现。关于递归思想和内涵深度剖析，请见博文<a href="http://blog.csdn.net/justloveyou_/article/details/71787149">《算法设计方法：递归的内涵与经典应用》</a>。</p><hr><h2 id="六-分配排序基数排序"><a name="t5"></a><a name="t5"></a>六. 分配排序(基数排序)</h2><p>　　<font color="red"><b>分配排序的基本思想</b></font>：用空间换时间。在整个排序过程中，无须比较关键字，而是通过用额外的空间来”分配”和”收集”来实现排序，它们的时间复杂度可达到线性阶：O(n)。其中，基数排序包括两个过程：首先，将目标序列各元素分配到各个桶中(分配过程)；然后，将各个桶中的元素按先进先出的顺序再放回去(收集过程)，如此往复，一共需要进行d趟，d为元素的位数。</p><pre class="prettyprint" name="code"><code class="language-java hljs  has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="hljs-javadoc">/**         * Title: 分配排序中的基数排序，不依赖于初始序列   * Description: 不是在对元素进行比较的基础上进行排序，而是采用 "分配 + 收集" 的办法  *  *              首先，将目标序列各元素分配到各个桶中； *              其次，将各个桶中的元素按先进先出的顺序再放回去 *              如此往复...              *  *              时间复杂度：O(d*(r+n))或者 O(dn),d 的大小一般会受到 n的影响 *              空间复杂度：O(rd + n)或者 O(n) *              稳    定   性：稳定 *              内部排序(在排序过程中数据元素完全在内存) *<span class="hljs-javadoctag"> @author</span> rico        *<span class="hljs-javadoctag"> @created</span> 2017年5月20日 上午10:40:00     */</span>   <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RadixSort</span> {</span>    <span class="hljs-javadoc">/**          *<span class="hljs-javadoctag"> @description</span> 分配 + 收集     *<span class="hljs-javadoctag"> @author</span> rico            *<span class="hljs-javadoctag"> @created</span> 2017年5月21日 下午9:25:52          *<span class="hljs-javadoctag"> @param</span> target 待排序数组     *<span class="hljs-javadoctag"> @param</span> r 基数     *<span class="hljs-javadoctag"> @param</span> d 元素的位数     *<span class="hljs-javadoctag"> @param</span> n 待排序元素个数     *<span class="hljs-javadoctag"> @return</span>          */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] <span class="hljs-title">radixSort</span>(<span class="hljs-keyword">int</span>[] target, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> d, <span class="hljs-keyword">int</span> n){        <span class="hljs-keyword">if</span> (target != <span class="hljs-keyword">null</span> &amp;&amp; target.length != <span class="hljs-number">1</span> ) {            <span class="hljs-keyword">int</span>[][] bucket = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[r][n];  <span class="hljs-comment">// 一共有基数r个桶，每个桶最多放n个元素</span>            <span class="hljs-keyword">int</span> digit;  <span class="hljs-comment">// 获取元素对应位上的数字，即装入那个桶</span>            <span class="hljs-keyword">int</span> divisor = <span class="hljs-number">1</span>;   <span class="hljs-comment">// 定义每一轮的除数，1, 10, 100, ...</span>            <span class="hljs-keyword">int</span>[] count = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[r];   <span class="hljs-comment">// 统计每个桶中实际存放元素的个数</span>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; d; i++) {  <span class="hljs-comment">// d 位的元素，需要经过分配、收集d次即可完成排序</span>                <span class="hljs-comment">// 分配</span>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> ele : target) {                       digit = (ele/divisor) % <span class="hljs-number">10</span>;  <span class="hljs-comment">// 获取元素对应位上的数字(巧妙！！！)</span>                    bucket[digit][count[digit]++] = ele; <span class="hljs-comment">// 将元素放入对应桶，桶中元素数目加1</span>                }                <span class="hljs-comment">// 收集</span>                <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 目标数组的下标</span>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; r; j++) {                    <span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>;    <span class="hljs-comment">// 用于按照先进先出顺序获取桶中元素</span>                    <span class="hljs-keyword">while</span>(k &lt; count[j]){                        target[index++] = bucket[j][k++];  <span class="hljs-comment">// 按照先进先出依次取出桶中的元素</span>                    }                    count[j] = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 计数器归零</span>                }                divisor *= <span class="hljs-number">10</span>;  <span class="hljs-comment">//用于获取元素对应位数字</span>            }        }        <span class="hljs-keyword">return</span> target;    }}<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li><li style="color: rgb(153, 153, 153);">8</li><li style="color: rgb(153, 153, 153);">9</li><li style="color: rgb(153, 153, 153);">10</li><li style="color: rgb(153, 153, 153);">11</li><li style="color: rgb(153, 153, 153);">12</li><li style="color: rgb(153, 153, 153);">13</li><li style="color: rgb(153, 153, 153);">14</li><li style="color: rgb(153, 153, 153);">15</li><li style="color: rgb(153, 153, 153);">16</li><li style="color: rgb(153, 153, 153);">17</li><li style="color: rgb(153, 153, 153);">18</li><li style="color: rgb(153, 153, 153);">19</li><li style="color: rgb(153, 153, 153);">20</li><li style="color: rgb(153, 153, 153);">21</li><li style="color: rgb(153, 153, 153);">22</li><li style="color: rgb(153, 153, 153);">23</li><li style="color: rgb(153, 153, 153);">24</li><li style="color: rgb(153, 153, 153);">25</li><li style="color: rgb(153, 153, 153);">26</li><li style="color: rgb(153, 153, 153);">27</li><li style="color: rgb(153, 153, 153);">28</li><li style="color: rgb(153, 153, 153);">29</li><li style="color: rgb(153, 153, 153);">30</li><li style="color: rgb(153, 153, 153);">31</li><li style="color: rgb(153, 153, 153);">32</li><li style="color: rgb(153, 153, 153);">33</li><li style="color: rgb(153, 153, 153);">34</li><li style="color: rgb(153, 153, 153);">35</li><li style="color: rgb(153, 153, 153);">36</li><li style="color: rgb(153, 153, 153);">37</li><li style="color: rgb(153, 153, 153);">38</li><li style="color: rgb(153, 153, 153);">39</li><li style="color: rgb(153, 153, 153);">40</li><li style="color: rgb(153, 153, 153);">41</li><li style="color: rgb(153, 153, 153);">42</li><li style="color: rgb(153, 153, 153);">43</li><li style="color: rgb(153, 153, 153);">44</li><li style="color: rgb(153, 153, 153);">45</li><li style="color: rgb(153, 153, 153);">46</li><li style="color: rgb(153, 153, 153);">47</li><li style="color: rgb(153, 153, 153);">48</li><li style="color: rgb(153, 153, 153);">49</li><li style="color: rgb(153, 153, 153);">50</li><li style="color: rgb(153, 153, 153);">51</li><li style="color: rgb(153, 153, 153);">52</li><li style="color: rgb(153, 153, 153);">53</li><li style="color: rgb(153, 153, 153);">54</li><li style="color: rgb(153, 153, 153);">55</li><li style="color: rgb(153, 153, 153);">56</li><li style="color: rgb(153, 153, 153);">57</li><li style="color: rgb(153, 153, 153);">58</li></ul></pre><hr><h2 id="七-总结"><a name="t6"></a><a name="t6"></a>七. 总结</h2><p>　　 　　 　　 　　 　　 　<img src="http://static.zybuluo.com/Rico123/ymihfm526o5xv5bo1btvm1fy/%E5%85%AB%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.jpg" alt="八大排序算法总结.jpg-201kB" title=""></p><hr><p>1、直接插入排序 Vs. 折半插入排序 Vs. 希尔排序</p><p>　　这三种排序方法都属于插入排序的范畴。与直接插入排序的顺序搜索插入位置相比，折半插入排序通过折半搜索的方法搜索插入位置，因此，在搜索插入位置方面，折半插入排序要快于直接插入排序。实际上，折半插入排序比直接插入排序只是减少了关键字之间的比较次数，但是移动次数是没有改变。所以，折半插入排序和插入排序的时间复杂度相同都是O（n^2），但减少了比较次数，所以该算法要比直接插入排序好一点。希尔排序可以看作是对直接插入排序的一种优化，它将全部元素分为间隔为gap的gap个子序列并对每一个子序列进行直接插入排序，同时不断缩小间隔gap，直至所有元素位于同一个序列。使用这种方式可以保证排序效率，因为刚开始时，gap较大，每个子序列元素较少，排序速度较快；待到排序后期，gap变小，每个子序列元素较多，但大部分元素基本有序，所以排序速度仍较快。因此，希尔排序比直接插入排序 、折半插入排序都要高效，但它不是稳定的。</p><hr><p>2、直接选择排序 Vs. 堆排序</p><p>　　这两种排序方法都属于插入选择排序的范畴，它们的核心思想都是每一趟都选择一个极值元素放在靠前/靠后位置，直到序列有序。与直接选择排序不同的是，堆排序不是“蛮力选择”，而是不断进行堆调整以取得每趟中的极值。因此，堆排序比直接选择排序要高效，不过它们都是不稳定的。</p><hr><p>3、冒泡排序 Vs. 快速排序</p><p>　　这两种排序方法都属于选择排序的范畴，它们的核心思想都是元素的交换，冒泡排序中每一趟相邻元素互相比较，并将较小的交换到前面(较大的自然沉到后面)位置，快速排序则是以基准点为基础，将比它小的元素和比它大的元素分别交换到它的两边。因此，快速排序比冒泡排序要高效，但它不是稳定的。</p><hr><p>4、归并排序 Vs. 快速排序</p><p>　　这两种排序方法都属于递归算法的范畴，因此，它们都比较容易让人理解和实现。与快速排序相比，归并排序不但是稳定的，还是与原始序列无关的(不依赖于原始序列的顺序，时间复杂度总是O(nlgn))，但是需要与原始序列一样大小的空间；而快速排序则一般情况下都要比其他高效排序算法（包括归并排序）快，而且空间复杂度只为O(1)。另外，我们从算法实现中可以看出这两种递归算法有以下区别和联系：</p><ul><li>二者的递归终止条件相同；</li><li>二者的实现结构较为类似，归并排序是先归后并，快速排序是先分后排；</li><li>归并排序的核心实现在于有序子序列的合并，而快速排序的核心实现在于对原始序列的划分；</li></ul><hr><p>5、小结</p><p>　　直接插入排序、直接选择排序和冒泡排序是基本的排序方法，它们平均情况下的时间复杂度都是O(n^2)，实现也比较简单，它们对规模较小的元素序列很有效。</p><p>　　快速排序、堆排序和归并排序是高效的排序方法，它们平均情况下的时间复杂度都是O(nlgn)，其中快速排序是最通用的高效排序算法，但其是不稳定的；归并排序是上述几种排序算法中唯一与初始序列无关的，而且时间复杂度总是O(nlgn)，但其空间复杂度是O(n)，是一种稳定的排序算法；堆排序的时间复杂度总是O(nlgn)，空间复杂度是O(1)，也是不稳定的。它们对规模较大的元素序列很有效。</p><p>　　希尔排序的效率介于基本排序方法与高效排序方法之间，是一种不稳定的排序算法。它们各有所长，都拥有特定的使用场景。基数排序虽然具有线性增长的时间复杂度，但实际上开销并不比快速排序小很多，应用相对不太广泛。</p><p>　　因此，在实际应用中，我们必须根据实际任务的特点和各种排序算法的特性来做出最合适的选择。</p><hr><h2 id="八-更多"><a name="t7"></a><a name="t7"></a>八. 更多</h2><p>　　归并排序和快速排序都是典型的递归算法，因此它们比较容易理解和实现。关于递归思想和内涵深度剖析，请见博文<a href="http://blog.csdn.net/justloveyou_/article/details/71787149" target="_blank">《算法设计方法：递归的内涵与经典应用》</a>。</p><hr><blockquote>  <h2 id="引用"><a name="t8"></a><a name="t8"></a>引用</h2>  <p><a href="http://blog.csdn.net/hguisu/article/details/7776068/" target="_blank">《八大排序算法》</a></p></blockquote>                                    </div>                <link href="https://csdnimg.cn/release/phoenix/mdeditor/markdown_views-60ecaf1f42.css" rel="stylesheet">                                </div>]]></content>
      
      
      <categories>
          
          <category> 编译原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编译原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM内存模型概述</title>
      <link href="/2020/05/20/JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E6%A6%82%E8%BF%B0/"/>
      <url>/2020/05/20/JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>本章介绍JVM内存模型概述</p></blockquote><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>转<a href="https://blog.csdn.net/justloveyou_/article/details/71189093">https://blog.csdn.net/justloveyou_/article/details/71189093</a></p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图解JAVA垃圾回收机制</title>
      <link href="/2020/05/20/%E5%9B%BE%E8%A7%A3JAVA%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"/>
      <url>/2020/05/20/%E5%9B%BE%E8%A7%A3JAVA%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>本章介绍JAVA垃圾回收机制.</p></blockquote><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="对象是否可以被回收的两种经典算法"><a href="#对象是否可以被回收的两种经典算法" class="headerlink" title="对象是否可以被回收的两种经典算法"></a>对象是否可以被回收的两种经典算法</h3><p>1 引用计数算法</p><p>2 可达性分析算法</p><h3 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h3><p>转<a href="https://blog.csdn.net/justloveyou_/article/details/71216049">https://blog.csdn.net/justloveyou_/article/details/71216049</a></p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>语法分析消除回溯</title>
      <link href="/2020/05/20/%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E6%B6%88%E9%99%A4%E5%9B%9E%E6%BA%AF/"/>
      <url>/2020/05/20/%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E6%B6%88%E9%99%A4%E5%9B%9E%E6%BA%AF/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>本章介绍</p></blockquote><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p><img src="https://photos.alitaalice.cn/image/20200520110241.png" alt=""></p><p><img src="https://photos.alitaalice.cn/image/20200520110725.png" alt=""></p><p><img src="https://photos.alitaalice.cn/image/20200520110909.png" alt=""></p><p><img src="https://photos.alitaalice.cn/image/20200520111151.png" alt=""></p><p><img src="C:%5CUsers%5C16508%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200520111712012.png" alt="image-20200520111712012"></p><p><img src="https://photos.alitaalice.cn/image/20200520112422.png" alt=""></p><p><img src="https://photos.alitaalice.cn/image/20200520112834.png" alt=""> </p><p><img src="https://photos.alitaalice.cn/image/20200520113021.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">    public boolean Judge(List&lt;String&gt; list)&#123;</span><br><span class="line">         ArrayList&lt;node&gt; analy &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">        for (int i &#x3D; 0; i &lt; list.size(); i++) &#123;</span><br><span class="line">            node aa &#x3D; new node(list.get(i).charAt(0),list.get(i).substring(3));</span><br><span class="line">            analy.add(aa);</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i&#x3D;0;i&lt;analy.size();i++)&#123;</span><br><span class="line">            if(analy.get(i).left &#x3D;&#x3D; analy.get(i).right.charAt(0))&#123;   &#x2F;&#x2F;当产生式的左部等于右部第一个符号，则具有左递归</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    class node&#123;          &#x2F;&#x2F;用于方便查找产生式的左部与右部</span><br><span class="line">    public char left;</span><br><span class="line">    public String right;</span><br><span class="line">    public node(char left,String right)&#123;</span><br><span class="line">        this.left&#x3D;left;</span><br><span class="line">        this.right&#x3D;right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编译原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编译原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>语法分析</title>
      <link href="/2020/05/19/%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/"/>
      <url>/2020/05/19/%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>本章介绍</p></blockquote><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p><img src="https://photos.alitaalice.cn/image/20200519182456.png" alt=""> </p><p><img src="https://photos.alitaalice.cn/image/20200519182209.png" alt=""></p><p><img src="https://photos.alitaalice.cn/image/20200519182733.png" alt=""></p><p><img src="https://photos.alitaalice.cn/image/20200519183255.png" alt=""></p><h3 id="自上而下分析面临的问题"><a href="#自上而下分析面临的问题" class="headerlink" title="自上而下分析面临的问题"></a>自上而下分析面临的问题<img src="https://photos.alitaalice.cn/image/20200519183424.png" alt=""></h3><h3 id="单词没向下进行，而语法树一直生成，死循环"><a href="#单词没向下进行，而语法树一直生成，死循环" class="headerlink" title="单词没向下进行，而语法树一直生成，死循环"></a><strong>单词没向下进行，而语法树一直生成，死循环</strong></h3><p><img src="https://photos.alitaalice.cn/image/20200519183702.png" alt=""></p><p><img src="https://photos.alitaalice.cn/image/20200519184233.png" alt=""></p><p><img src="https://photos.alitaalice.cn/image/20200519184615.png" alt=""></p><p> <img src="https://photos.alitaalice.cn/image/20200519185010.png" alt=""></p><p><img src="https://photos.alitaalice.cn/image/20200519185526.png" alt=""></p><p><img src="https://photos.alitaalice.cn/image/20200519190630.png" alt=""></p><p><img src="https://photos.alitaalice.cn/image/20200519190602.png" alt=""></p><p>通用消除左递归的方法</p><p><img src="https://photos.alitaalice.cn/image/20200519190928.png" alt=""></p><p><img src="https://photos.alitaalice.cn/image/20200519191437.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 编译原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编译原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql用户变量和set语句</title>
      <link href="/2020/05/19/Mysql%E7%94%A8%E6%88%B7%E5%8F%98%E9%87%8F%E5%92%8Cset%E8%AF%AD%E5%8F%A5/"/>
      <url>/2020/05/19/Mysql%E7%94%A8%E6%88%B7%E5%8F%98%E9%87%8F%E5%92%8Cset%E8%AF%AD%E5%8F%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>本章介绍mysql用户变量和set语句</p></blockquote><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="1-用户变量介绍"><a href="#1-用户变量介绍" class="headerlink" title="1 用户变量介绍"></a>1 用户变量介绍</h3><p>用户变量即用户自己定义的变量，我们可以给用户变量分配值，并且可用在任何可以正常使用标量表达式的地方。<br>    引入用户变量之前我们必须使用set语句或select语句来定义它，然后为它赋一个值，否则变量就只有一个空值。<br>    用户变量与连接有关。也就是说，一个客户端定义的变量不能被其它客户端看到或使用。当客户端退出时，该客户端连接的所有变量将自动释放。</p><h3 id="2-用户变量定义"><a href="#2-用户变量定义" class="headerlink" title="2 用户变量定义"></a>2 用户变量定义</h3><p>set语句可用于向系统变量或用户变量赋值，针对用户变量的定义如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET <span class="meta">@var</span>_name = expr [, <span class="meta">@var</span>_name = expr] ...</span><br></pre></td></tr></table></figure><p>也可使用select语句来定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT <span class="meta">@var</span>_name := expr [, <span class="meta">@var</span>_name = expr] ...</span><br></pre></td></tr></table></figure><p>用户变量：以”@”开始，形式为”@var_name”,以区分用户变量及列名。它可以是任何随机的，复合的标量表达式，只要其中没有列指定。<br>一个变量名可以由当前字符集的数字字母字符和“_”、“$”和“.”组成。缺省字符集是ISO-8859-1 Latin1；这可以用mysqld 的–default-character-set 选项更改字符集。<br>对于SET，可以使用=或:=来赋值，对于SELECT只能使用:=来赋值。<br>我们可以使用一条简单的select语句查询定义的用户变量的值</p><h3 id="3-用户变量的使用"><a href="#3-用户变量的使用" class="headerlink" title="3 用户变量的使用"></a>3 用户变量的使用</h3><h4 id="3-1-通过set的实例"><a href="#3-1-通过set的实例" class="headerlink" title="3.1 通过set的实例"></a>3.1 通过set的实例</h4><p>用来把一个值赋给一个变量的标量表达式可以是复合表达式。计算，函数，系统标量以及其他用户变量都是允许的，子查询也是允许的。然后通过select语句可以获取一个用户变量的值，结果是带有一行的一个表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; set <span class="meta">@var</span>1=<span class="number">1</span>, <span class="meta">@var</span>2=<span class="string">'vartest'</span>, <span class="meta">@var</span>3=abs(-<span class="number">2</span>), <span class="meta">@var</span>4=(<span class="function">select <span class="title">count</span><span class="params">(*)</span> from mysql.user)</span>;</span><br><span class="line">mysql&gt; select <span class="meta">@var</span>1, <span class="meta">@var</span>2, <span class="meta">@var</span>3, <span class="meta">@var</span>4;</span><br><span class="line">+-------+---------+-------+-------+</span><br><span class="line">| <span class="meta">@var</span>1 | <span class="meta">@var</span>2   | <span class="meta">@var</span>3 | <span class="meta">@var</span>4 |</span><br><span class="line">+-------+---------+-------+-------+</span><br><span class="line">|     <span class="number">1</span> | vartest |     <span class="number">2</span> |    <span class="number">25</span> |</span><br><span class="line">+-------+---------+-------+-------+</span><br></pre></td></tr></table></figure><p> 在用来为一个用户变量赋值的表达式中，也可以指定其它的用户变量，需要注意的是mysql首先确定所有表达式的值，之后才会把值赋给变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; set <span class="meta">@varA</span> = <span class="number">2</span>; </span><br><span class="line"></span><br><span class="line">mysql&gt; set <span class="meta">@varA</span> = <span class="number">3</span>, <span class="meta">@varB</span> = <span class="meta">@varA</span>;</span><br><span class="line">mysql&gt; select <span class="meta">@varB</span>;</span><br><span class="line">+-------+</span><br><span class="line">| <span class="meta">@varB</span> |</span><br><span class="line">+-------+</span><br><span class="line">|     <span class="number">2</span> |</span><br><span class="line">+-------+</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; set <span class="meta">@varA</span> = <span class="number">3</span>; </span><br><span class="line">mysql&gt; set <span class="meta">@varB</span> = <span class="meta">@varA</span>;</span><br><span class="line">mysql&gt; select <span class="meta">@varB</span>;                                             </span><br><span class="line">+-------+</span><br><span class="line">| <span class="meta">@varB</span> |</span><br><span class="line">+-------+</span><br><span class="line">|     <span class="number">3</span> |</span><br><span class="line">+-------+</span><br></pre></td></tr></table></figure><h4 id="3-2-通过select-的实例"><a href="#3-2-通过select-的实例" class="headerlink" title="3.2 通过select 的实例"></a>3.2 通过select 的实例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select <span class="meta">@var</span>1:=<span class="number">1</span>, <span class="meta">@var</span>2:=<span class="string">'vartest'</span>, <span class="meta">@var</span>3:=abs(-<span class="number">2</span>), <span class="meta">@var</span>4:=(<span class="function">select <span class="title">count</span><span class="params">(*)</span> from mysql.user)</span>;</span><br><span class="line">+----------+------------------+----------------+------------------------------------------+</span><br><span class="line">| <span class="meta">@var</span>1:=<span class="number">1</span> | <span class="meta">@var</span>2:=<span class="string">'vartest'</span> | <span class="meta">@var</span>3:=abs(-<span class="number">2</span>) | <span class="meta">@var</span>4:=(<span class="function">select <span class="title">count</span><span class="params">(*)</span> from mysql.user) |</span></span><br><span class="line"><span class="function">+----------+------------------+----------------+------------------------------------------+</span></span><br><span class="line"><span class="function">|        1 | vartest          |              2 |                                       25 |</span></span><br><span class="line"><span class="function">+----------+------------------+----------------+------------------------------------------+</span></span><br><span class="line"><span class="function">mysql&gt; select @var1, @var2, @var3, @var4</span>;</span><br><span class="line">+-------+---------+-------+-------+</span><br><span class="line">| <span class="meta">@var</span>1 | <span class="meta">@var</span>2   | <span class="meta">@var</span>3 | <span class="meta">@var</span>4 |</span><br><span class="line">+-------+---------+-------+-------+</span><br><span class="line">|     <span class="number">1</span> | vartest |     <span class="number">2</span> |    <span class="number">25</span> |</span><br><span class="line">+-------+---------+-------+-------+</span><br><span class="line">+-------+---------+-------+-------+</span><br><span class="line">|     <span class="number">1</span> | vartest |     <span class="number">2</span> |    <span class="number">25</span> |</span><br><span class="line">+-------+---------+-------+-------+</span><br></pre></td></tr></table></figure><h3 id="用户变量注意事项"><a href="#用户变量注意事项" class="headerlink" title="用户变量注意事项"></a>用户变量注意事项</h3><p>4.1 用户变量用在where或having子句中，他们必须首先用另一条语句来定义,如下面例子，初次查询没有返回结果，先定以后在查询才有输出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select <span class="meta">@H</span>:=<span class="string">'localhost'</span> from mysql.user where host = <span class="meta">@H</span>;</span><br><span class="line"><span class="function">Empty <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br><span class="line"><span class="function">mysql&gt; select @H:</span>=<span class="string">'localhost'</span>;</span><br><span class="line">+-----------------+</span><br><span class="line">| <span class="meta">@H</span>:=<span class="string">'localhost'</span> |</span><br><span class="line">+-----------------+</span><br><span class="line">| localhost       |</span><br><span class="line">+-----------------+</span><br><span class="line"><span class="number">1</span> <span class="function">row in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br><span class="line"><span class="function">mysql&gt; select @H:</span>=<span class="string">'localhost'</span>, user from mysql.user where host = <span class="meta">@H</span>;</span><br><span class="line">+-----------------+-----------------+</span><br><span class="line">| <span class="meta">@H</span>:=<span class="string">'localhost'</span> | user            |</span><br><span class="line">+-----------------+-----------------+</span><br><span class="line">| localhost       |                 |</span><br><span class="line">| localhost       | jesse           |</span><br><span class="line">| localhost       | local           |</span><br><span class="line">| localhost       | root            |</span><br><span class="line">| localhost       | user_tab_update |</span><br><span class="line">+-----------------+-----------------+</span><br></pre></td></tr></table></figure><p> 4.2 用户变量为session级别，当我们关闭客户端或退出登录时用户变量全部消失。如果想用就保存自定义的变量，需要自行创建一个表，将标量insert到表里。<br>  4.3 用户变量名对大小写不敏感。<br>  4.4 未定义的变量初始化是null。</p><h4 id="mysql语句do"><a href="#mysql语句do" class="headerlink" title="mysql语句do"></a>mysql语句do</h4><p> 在do语句中，使用了一个或多个标量表达式，mysql会一条一条的处理它们，但并不显示表达式的结果。例如我们可以调用函数执行后台的某些事情，而不需要看到其结果。</p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql自定义函数</title>
      <link href="/2020/05/18/Mysql%E8%87%AA%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0/"/>
      <url>/2020/05/18/Mysql%E8%87%AA%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>本章介绍Mysql自定义函数</p></blockquote><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>创建函数语法：<br>CREATE FUNCTION fn_name(func_parameter[,…])<br>RETURNS type<br>[characteristic…]<br>routine_body</p><p>eg:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#创建一个函数</span><br><span class="line">DELIMITER $$ -- 定界符</span><br><span class="line">-- 开始创建函数</span><br><span class="line"><span class="function">CREATE FUNCTION <span class="title">user_main_fn</span><span class="params">(v_id INT)</span></span></span><br><span class="line"><span class="function">RETURNS <span class="title">VARCHAR</span><span class="params">(<span class="number">50</span>)</span></span></span><br><span class="line"><span class="function">BEGIN</span></span><br><span class="line"><span class="function">  -- 定义变量</span></span><br><span class="line"><span class="function">  DECLARE v_userName <span class="title">VARCHAR</span><span class="params">(<span class="number">50</span>)</span></span>;</span><br><span class="line">  -- 给定义的变量赋值</span><br><span class="line">  SELECT f_userName INTO v_userName FROM t_user_main </span><br><span class="line">  WHERE f_userId = v_id;</span><br><span class="line">  -- 返回函数处理结果</span><br><span class="line">  RETURN v_userName;</span><br><span class="line">END $$ -- 函数创建定界符</span><br><span class="line">DELIMITER;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#创建第二个函数，使用第一个函数</span><br><span class="line">DELIMITER $$</span><br><span class="line"><span class="function">CREATE FUNCTION <span class="title">user_main_fn2</span><span class="params">(v_id INT)</span></span></span><br><span class="line"><span class="function">RETURNS <span class="title">VARCHAR</span><span class="params">(<span class="number">100</span>)</span></span></span><br><span class="line"><span class="function">BEGIN </span></span><br><span class="line"><span class="function">  #定义变量</span></span><br><span class="line"><span class="function">  DECLARE v_userName <span class="title">VARCHAR</span><span class="params">(<span class="number">50</span>)</span></span>;</span><br><span class="line">  <span class="function">DECLARE  v_userNameNew <span class="title">VARCHAR</span><span class="params">(<span class="number">50</span>)</span></span>;</span><br><span class="line">  #通过into赋值</span><br><span class="line">  SELECT f_userName INTO v_userName FROM t_user_main WHERE f_userId = v_id;</span><br><span class="line">  #使用函数</span><br><span class="line">  <span class="function">SELECT <span class="title">user_main_fn</span><span class="params">(v_id)</span> INTO v_userNameNew FROM DUAL</span>;</span><br><span class="line">  #返回函数处理结果</span><br><span class="line">  <span class="function">RETURN <span class="title">CONCAT</span><span class="params">(v_userName,<span class="string">'***'</span>,v_userNameNew)</span></span>;</span><br><span class="line">END $$</span><br><span class="line">DELIMITER;</span><br></pre></td></tr></table></figure><p>DUAL 虚拟表</p><h3 id="查看函数状态语法："><a href="#查看函数状态语法：" class="headerlink" title="查看函数状态语法："></a>查看函数状态语法：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW FUNCTION STATUS [LIKE <span class="string">'pattern'</span>]</span><br></pre></td></tr></table></figure><h4 id="查看函数的定义语法："><a href="#查看函数的定义语法：" class="headerlink" title="查看函数的定义语法："></a>查看函数的定义语法：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW CREATE FUNCTION fn_name;</span><br></pre></td></tr></table></figure><p>eg:  输出第n高的工资</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">CREATE FUNCTION <span class="title">getNthHighestSalary</span><span class="params">(N INT)</span> RETURNS INT</span></span><br><span class="line"><span class="function">BEGIN</span></span><br><span class="line"><span class="function">  SET N</span>=N-<span class="number">1</span>;</span><br><span class="line">  RETURN (</span><br><span class="line">      # Write your MySQL query statement below.</span><br><span class="line">      SELECT  DISTINCT Salary  FROM Employee ORDER BY Salary DESC  limit N,<span class="number">1</span></span><br><span class="line">  );</span><br><span class="line">END</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>垃圾收集器与内存分配策略</title>
      <link href="/2020/05/18/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/"/>
      <url>/2020/05/18/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>本章介绍垃圾收集器与内存分配策略</p></blockquote><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="1-java中init和clinit方法"><a href="#1-java中init和clinit方法" class="headerlink" title="1 java中init和clinit方法"></a>1 java中init和clinit方法</h3><p>init是对象构造器方法，也就是说在程序执行 new 一个对象调用该对象类的 constructor 方法时才会执行init方法，而clinit是类构造器方法，也就是在jvm进行类<strong>加载—–验证—-解析—–初始化</strong>，中的初始化阶段jvm会调用clinit方法。</p><p><strong>init是instance实例构造器，对非静态变量解析初始化</strong>，而<strong>clinit是class类构造器对静态变量，静态代码块进行初始化</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">static</span> Log log = LogFactory.getLog(); <span class="comment">// &lt;clinit&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> x = <span class="number">1</span>;   <span class="comment">// &lt;init&gt;</span></span><br><span class="line"></span><br><span class="line">   X()&#123;</span><br><span class="line">      <span class="comment">// &lt;init&gt;</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">static</span> &#123;</span><br><span class="line">      <span class="comment">// &lt;clinit&gt;</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="简述可达性分析算法"><a href="#简述可达性分析算法" class="headerlink" title="简述可达性分析算法"></a>简述可达性分析算法</h3><h3 id="finalize关键字"><a href="#finalize关键字" class="headerlink" title="finalize关键字"></a>finalize关键字</h3><p>java提供<a href="http://www.51testing.com/javascrīpt:;"><strong>finalize</strong></a>()方法，垃圾回收器准备释放内存的时候，会先调用finalize()。</p><p>​    (1).对象不一定会被回收。</p><p>​    (2).垃圾回收不是析构函数。</p><p>​    (3).垃圾回收只与内存有关。</p><p>​    (4).垃圾回收和finalize()都是靠不住的，只要JVM还没有快到耗尽内存的地步，它是不会浪费时间进行垃圾回收的。</p><p>有时当撤消一个对象时，需要完成一些操作。例如，如果一个对象正在处理的是非Java 资源，如文件句柄或window 字符字体，这时你要确认在一个对象被撤消以前要保证这些资源被释放。为处理这样的状况，Java 提供了被称为收尾（finalization ）的机制。使用该机制你可以定义一些特殊的操作，这些操作在一个对象将要被垃圾回收程序释放时执行。</p><p>要给一个类增加收尾（finalizer ），你只要定义finalize ( ) 方法即可。Java 回收该类的一个对象时，就会调用这个方法。在finalize ( )方法中，你要指定在一个对象被撤消前必须执行的操作。垃圾回收周期性地运行，检查对象不再被运行状态引用或间接地通过其他对象引用。就在对象被释放之前，Java 运行系统调用该对象的finalize( ) 方法。</p><p>finalize()方法的通用格式如下：</p><p>protected void finalize( )<br>{<br>// finalization code here<br>}</p><h3 id="finalize"><a href="#finalize" class="headerlink" title="finalize"></a>finalize</h3><p>方法名。Java 技术允许使用 finalize() 方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在确定这个对象没有被引用时对这个对象调用的。它是在 Object 类中定义的，因此所有的类都继承了它。子类覆盖 finalize() 方法以整理系统资源或者执行其他清理工作。finalize() 方法是在垃圾收集器删除对象之前对这个对象调用的。 </p><p>Java中所有类都从Object类中继承finalize()方法。</p><p>当垃圾回收器(garbage colector)决定回收某对象时，就会运行该对象的finalize()方法。值得C++程序员注意的是，finalize()方法并不能等同与析构函数。Java中是没有析构函数的。C++的析构函数是在对象消亡时运行的。由于C++没有垃圾回收，对象空间手动回收，所以一旦对象用不到时，程序员就应当把它delete()掉。所以析构函数中经常做一些文件保存之类的收尾工作。但是在Java中很不幸，如果内存总是充足的，那么垃圾回收可能永远不会进行，也就是说filalize()可能永远不被执行，显然指望它做收尾工作是靠不住的。</p><p>那么finalize()究竟是做什么的呢？它最主要的用途是回收特殊渠道申请的内存。Java程序有垃圾回收器，所以一般情况下内存问题不用程序员操心。但有一种JNI(Java Native Interface)调用non-Java程序（C或C++），finalize()的工作就是回收这部分的内存。</p><h3 id="Java中的引用"><a href="#Java中的引用" class="headerlink" title="Java中的引用"></a>Java中的引用</h3><h3 id="简述垃圾回收算法"><a href="#简述垃圾回收算法" class="headerlink" title="简述垃圾回收算法"></a>简述垃圾回收算法</h3><h3 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h3><h3 id="在垃圾回收器回收对象的时候，程序的逻辑是否可以继续执行"><a href="#在垃圾回收器回收对象的时候，程序的逻辑是否可以继续执行" class="headerlink" title="在垃圾回收器回收对象的时候，程序的逻辑是否可以继续执行"></a>在垃圾回收器回收对象的时候，程序的逻辑是否可以继续执行</h3><h3 id="垃圾回收器在什么时候，对哪些对象，做了什么"><a href="#垃圾回收器在什么时候，对哪些对象，做了什么" class="headerlink" title="垃圾回收器在什么时候，对哪些对象，做了什么"></a>垃圾回收器在什么时候，对哪些对象，做了什么</h3><h3 id="简述minor-GC，与full-GC-java垃圾回收分代，以及何时发生minor-gc，以及full-gc"><a href="#简述minor-GC，与full-GC-java垃圾回收分代，以及何时发生minor-gc，以及full-gc" class="headerlink" title="简述minor GC，与full GC,java垃圾回收分代，以及何时发生minor gc，以及full gc"></a>简述minor GC，与full GC,java垃圾回收分代，以及何时发生minor gc，以及full gc</h3>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP协议</title>
      <link href="/2020/05/18/HTTP%E5%8D%8F%E8%AE%AE/"/>
      <url>/2020/05/18/HTTP%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>本章介绍HTTP协议</p></blockquote><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="1-HTTP-协议用于客户端和服务器端之间的通信"><a href="#1-HTTP-协议用于客户端和服务器端之间的通信" class="headerlink" title="1 HTTP 协议用于客户端和服务器端之间的通信"></a>1 HTTP 协议用于客户端和服务器端之间的通信</h3><p>HTTP 协议能够明确区分哪端是客户端，哪端是服务器端  </p><h3 id="2-通过请求和响应的交换达成通信"><a href="#2-通过请求和响应的交换达成通信" class="headerlink" title="2 通过请求和响应的交换达成通信"></a>2 通过请求和响应的交换达成通信</h3><p>HTTP 协议规定，请求从客户端发出，最后服务器端响应该请求并返回  </p><p><img src="https://photos.alitaalice.cn/image/20200518114122.png" alt=""></p><p>起始行开头的GET表示请求访问服务器的类型，称为方法（method）。随后的字符串 /index.htm 指明了请求访问的资源对象，也叫做请求 URI（request-URI）。最后的 HTTP/1.1，即 HTTP 的版本号，用来提示客户端使用的 HTTP 协议功能  .</p><p>请求首部字段及内容实体稍后会作详细说明。接下来，我们继续讲解。接收到请求的服务器，会将请求内容的处理结果以响应的形式返回。  </p><p><img src="https://photos.alitaalice.cn/image/20200518114432.png" alt=""></p><p><img src="https://photos.alitaalice.cn/image/20200518114521.png" alt=""></p><h3 id="3-HTTP-是不保存状态的协议"><a href="#3-HTTP-是不保存状态的协议" class="headerlink" title="3 HTTP 是不保存状态的协议"></a>3 HTTP 是不保存状态的协议</h3><p>HTTP 是一种不保存状态，即无状态（stateless）协议。HTTP 协议自身不对请求和响应之间的通信状态进行保存。也就是说在 HTTP 这个级别，协议对于发送过的请求或响应都不做持久化处理。  </p><p><img src="https://photos.alitaalice.cn/image/20200518114709.png" alt=""></p><h3 id="4-请求URI定位资源"><a href="#4-请求URI定位资源" class="headerlink" title="4 请求URI定位资源"></a>4 请求URI定位资源</h3><p><img src="https://photos.alitaalice.cn/image/20200518115112.png" alt=""></p><h3 id="5-HTTP方法"><a href="#5-HTTP方法" class="headerlink" title="5 HTTP方法"></a>5 HTTP方法</h3><p><img src="https://photos.alitaalice.cn/image/20200518164346.png" alt=""></p><h3 id="6-持久连接"><a href="#6-持久连接" class="headerlink" title="6 持久连接"></a>6 持久连接</h3><p>持久连接的特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态，持久连接旨在建立 1 次 TCP 连接后进行多次请求和响应的交互。</p><h3 id="7-管线化"><a href="#7-管线化" class="headerlink" title="7 管线化"></a>7 管线化</h3><p>持久连接使得多数请求以管线化（pipelining）方式发送成为可能。从前发送请求后需等待并收到响应，才能发送下一个请求。管线化技术出现后，不用等待响应亦可直接发送下一个请求。<br>这样就能够做到同时并行发送多个请求，而不需要一个接一个地等待响应了。  </p><p><img src="https://photos.alitaalice.cn/image/20200518164857.png" alt=""></p><h3 id="8-使用Cookie的状态管理"><a href="#8-使用Cookie的状态管理" class="headerlink" title="8 使用Cookie的状态管理"></a>8 使用Cookie的状态管理</h3><p><img src="https://photos.alitaalice.cn/image/20200518165228.png" alt=""></p><h3 id="各层对应的协议"><a href="#各层对应的协议" class="headerlink" title="各层对应的协议"></a>各层对应的协议</h3><h3 id="OSI七层对各层协议"><a href="#OSI七层对各层协议" class="headerlink" title="OSI七层对各层协议"></a>OSI七层对各层协议</h3>]]></content>
      
      
      <categories>
          
          <category> HTTP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>装饰者模式</title>
      <link href="/2020/05/18/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
      <url>/2020/05/18/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>本章介绍装饰者模式。</p></blockquote><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="装饰者模式定义"><a href="#装饰者模式定义" class="headerlink" title="装饰者模式定义"></a>装饰者模式定义</h3><p><img src="https://photos.alitaalice.cn/image/20200518102539.png" alt=""></p><p>设计原则：</p><p>类应该对扩展开放，对修改关闭。</p><p>我们的目标是允许类容易扩展，在不修改现有代码的情况下，就可搭配新的行为。如果能实现这样的目标，有什么好处呢？这样的设计具有弹性可以应对改变，可以接受新的功能来应对改变的需求。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程安全性</title>
      <link href="/2020/05/17/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7/"/>
      <url>/2020/05/17/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>本章介绍线程安全性</p></blockquote><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="1-并发与并行"><a href="#1-并发与并行" class="headerlink" title="1 并发与并行"></a>1 并发与并行</h3><p>你吃饭吃到一半，电话来了，你一直到吃完了以后才去接，这就说明你不支持并发也不支持并行。<br>你吃饭吃到一半，电话来了，你停了下来接了电话，接完后继续吃饭，这说明你支持并发。<br>你吃饭吃到一半，电话来了，你一边打电话一边吃饭，这说明你支持并行。</p><p>并发的关键是你有处理多个任务的能力，不一定要同时。<br>并行的关键是你有同时处理多个任务的能力。</p><p>所以我认为它们最关键的点就是：是否是『同时』。</p><h3 id="2-原子性"><a href="#2-原子性" class="headerlink" title="2 原子性"></a>2 原子性</h3><p><strong>即一个操作或者多个操作，要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。原子性就像数据库里面的事务一样，他们是一个团队，同生共死。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">0</span>;       <span class="comment">//1</span></span><br><span class="line">j = i ;      <span class="comment">//2</span></span><br><span class="line">i++;         <span class="comment">//3</span></span><br><span class="line">i = j + <span class="number">1</span>;   <span class="comment">//4</span></span><br></pre></td></tr></table></figure><p>上面四个操作，有哪个几个是原子操作，那几个不是？如果不是很理解，可能会认为都是原子性操作，其实只有1才是原子操作，其余均不是。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>在Java中，对基本数据类型的变量和赋值操作都是原子性操作； </span><br><span class="line"><span class="number">2</span>中包含了两个操作：读取i，将i值赋值给j </span><br><span class="line"><span class="number">3</span>中包含了三个操作：读取i值、i + <span class="number">1</span> 、将+<span class="number">1</span>结果赋值给i； </span><br><span class="line"><span class="number">4</span>中同三一样</span><br></pre></td></tr></table></figure><p>在单线程环境下我们可以认为整个步骤都是原子性操作，但是在多线程环境下则不同，Java只保证了基本数据类型的变量和赋值操作才是原子性的（注：在32位的JDK环境下，对64位数据的读取不是原子性操作*，如long、double）。</p><p>要想在多线程环境下保证原子性，则可以通过锁、synchronized来确保。volatile是无法保证复合操作的原子性。</p><h3 id="3可见性"><a href="#3可见性" class="headerlink" title="3可见性"></a>3可见性</h3><p><strong>可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线程1执行的代码</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">i = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程2执行的代码</span></span><br><span class="line">j = i;</span><br></pre></td></tr></table></figure><p>假若执行线程1的是CPU1，执行线程2的是CPU2。由上面的分析可知，当线程1执行 i = 10这句时，会先把i的初始值加载到CPU1的高速缓存中，然后赋值为10，那么在CPU1的高速缓存当中i的值变为10了，却没有立即写入到主存当中。此时线程2执行 j = i，它会先去主存读取i的值并加载到CPU2的缓存当中，注意此时内存当中i的值还是0，那么就会使得j的值为0，而不是10。这就是可见性问题，线程1对变量i修改了之后，线程2没有立即看到线程1修改的值。</p><p>在上面已经分析了，在多线程环境下，一个线程对共享变量的操作对其他线程是不可见的。<br>对于可见性，Java提供了volatile关键字来保证可见性。当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。另外，通过synchronized和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。</p><h3 id="4有序性"><a href="#4有序性" class="headerlink" title="4有序性"></a>4有序性</h3><p><strong>程序执行的顺序按照代码的先后顺序执行</strong></p><p><strong>在Java里面，可以通过volatile关键字来保证一定的“有序性”</strong>。另外可以通过synchronized和Lock来保证有序性，很显然，synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。</p><h4 id="3-竞态条件"><a href="#3-竞态条件" class="headerlink" title="3 竞态条件"></a>3 竞态条件</h4><p>在并发编程中，这种由于不恰当的执行时序而出现不正确的结果是一种非常。重要的情况，它有一个正式的名字：竞态条件  </p><p>最常见的竞态条件类型就是“先检查后执行（Check-Then-Act）”操作，即通过一个可能失效的观测结果来决定下一步的动作  </p>]]></content>
      
      
      <categories>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA内存区域与内存溢出异常</title>
      <link href="/2020/05/15/JAVA%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8/"/>
      <url>/2020/05/15/JAVA%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>本章介绍JAVA内存区域与内存溢出异常</p></blockquote><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>类文件(<code>.class</code>文件扩展名)是包含Java字节码 <code>ByteCode</code>的文件，可以在Java虚拟机上执行，每个类文件包含了一个类，接口或者模块（Java 9）的定义.Java程序（<code>.java</code> 文件）可以通过 Java compiler 生成字节码文件，其他基于JVM的语言也都可以通过自己的编译器生成字节码文件，例如Scala，Groovy等JVM是与平台无关的，类文件可以在多个平台上执行，这使得相应的语言也与平台无关.</p><h2 id="JVM的内存布局"><a href="#JVM的内存布局" class="headerlink" title="JVM的内存布局"></a>JVM的内存布局</h2><p>虚拟机中，Java 内存区域可以划分为 6 个部分，程序计数器、虚拟机栈、本地方法栈（以上三个是线程私有的）、堆和方法区（里面有常量池，方法区与堆是线程共享的 )、直接内存（不受 JVM GC 管理）。除了直接内存，其他都是运行时数据区。</p><p><img src="https://photos.alitaalice.cn/image/20200517164736.png" alt=""></p><h2 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h2><p><img src="https://photos.alitaalice.cn/image/20200517165000.png" alt=""></p><p><img src="https://photos.alitaalice.cn/image/20200517165050.png" alt=""></p><h2 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h2><p><img src="https://photos.alitaalice.cn/image/20200517164220.png" alt=""></p><p><img src="https://photos.alitaalice.cn/image/20200517165147.png" alt=""></p><p><img src="https://photos.alitaalice.cn/image/20200517165221.png" alt=""></p><p><img src="https://photos.alitaalice.cn/image/20200517165249.png" alt=""></p><p><img src="https://photos.alitaalice.cn/image/20200517165303.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用事务处理</title>
      <link href="/2020/05/15/%E4%BD%BF%E7%94%A8%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/"/>
      <url>/2020/05/15/%E4%BD%BF%E7%94%A8%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>本章介绍什么是事务处理以及如何利用COMMIT和ROLLBACK语句来管理事务处理  .</p></blockquote><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>MyISAM和<strong>InnoDB</strong>是两种最常使用的引擎。前者不支持明确的事务处理管理，而后者支持。  </p><p><strong>事务处理（transaction processing）可以用来维护数据库的完整性，它保证成批的MySQL操作要么完全执行，要么完全不执行。</strong>  </p><p><strong>事务处理是一种机制，用来管理必须成批执行的MySQL操作，以保证数据库不包含不完整的操作结果。利用事务处理，可以保证一组操作不会中途停止，它们或者作为整体执行，或者完全不执行（除非明确指示）。如果没有错误发生，整组语句提交给（写到）数据库表。如果发生错误，则进行回退（撤销）以恢复数据库到某个已知且安全的状态 .</strong> </p><p><img src="https://photos.alitaalice.cn/image/20200515163050.png" alt=""></p><h2 id="1控制事务处理"><a href="#1控制事务处理" class="headerlink" title="1控制事务处理"></a>1控制事务处理</h2><p>MySQL-使用下面的语句来标识事务的开始  ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">START TRANSACTION</span><br></pre></td></tr></table></figure><p>MySQL的ROLLBACK命令用来回退（撤销） MySQL语句，请看下面的语句：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM ordertotals;</span><br><span class="line">START TRANSACTION;</span><br><span class="line">DELETE FROM ordertotals;</span><br><span class="line">SELECL * FROM ordertotals;</span><br><span class="line">ROLLBACK;</span><br><span class="line">SELECT * FROM ordertotals;</span><br></pre></td></tr></table></figure><p>ROLLBACK只能在一个事务处理内使用（在执行一条START<br> TRANSACTION命令之后）  .</p><p>事务处理用来<strong>管理INSERT、 UPDATE和DELETE语</strong>句。你不能回退SELECT语句。（这样做也没有什么意义。）你不能<strong>回退CREATE或DROP</strong>操作。事务处理块中可以使用这两条语句，但如果你执行回退，它们不会被撤销。  </p><h2 id="2-使用COMMIT"><a href="#2-使用COMMIT" class="headerlink" title="2 使用COMMIT"></a>2 使用COMMIT</h2><p>一般的MySQL语句都是直接针对数据库表执行和编写的。这就是<br>所谓的隐含提交（implicit commit），即提交（写或保存）操作是自动进行的。  </p><p>在事务处理块中，提交不会隐含地进行。为进行明确的提交，<br>使用COMMIT语句 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">START TRANSACTION;</span><br><span class="line">DELETE FROM orderitems WHERE order_num =<span class="number">20010</span>;</span><br><span class="line">DELETE FROM orders WHERE order_num=<span class="number">20010</span>;</span><br><span class="line">COMMIT;</span><br></pre></td></tr></table></figure><p>隐含事务关闭 当COMMIT或ROLLBACK语句执行后，事务会自动关闭（将来的更改会隐含提交）。  </p><h3 id="3-使用保留点"><a href="#3-使用保留点" class="headerlink" title="3 使用保留点"></a>3 使用保留点</h3><p>为了支持回退部分事务处理，必须能在事务处理块中合适的位置放<br>置占位符。这样，如果需要回退，可以回退到某个占位符。      </p><p>这些占位符称为保留点。为了创建占位符，可如下使用SAVEPOINT<br>语句：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SAVEPOINT delete1;</span><br></pre></td></tr></table></figure><p>每个保留点都取标识它的唯一名字，以便在回退时， MySQL知道要<br>回退到何处。为了回退到本例给出的保留点，可如下进行  :</p><p>–对于关系数据库教务管理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROLLBACK TO delete1;</span><br></pre></td></tr></table></figure><p>留点在事务处理完成（执行一条ROLLBACK或COMMIT）后自动释放。自MySQL 5以来，也可以用RELEASE SAVEPOINT明确地释放保留点。</p><h3 id="4-更改默认的提交行为"><a href="#4-更改默认的提交行为" class="headerlink" title="4 更改默认的提交行为"></a>4 更改默认的提交行为</h3><p>为指示MySQL不自动提交更改，需要使用以下语句 ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET autocommit=<span class="number">0</span>;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql使用触发器</title>
      <link href="/2020/05/15/mysql%E4%BD%BF%E7%94%A8%E8%A7%A6%E5%8F%91%E5%99%A8/"/>
      <url>/2020/05/15/mysql%E4%BD%BF%E7%94%A8%E8%A7%A6%E5%8F%91%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>本章介绍触发器</p></blockquote><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>触发器是MySQL响应以下任意语句而自动执行的一条MySQL语句（或位于BEGIN和END语句之间的一组语句 。</p><ul><li><p>DELETE </p></li><li><p>INSERT </p></li><li><p>UPDATE</p><p>在创建触发器时，需要给出4条信息 :</p><p><img src="https://photos.alitaalice.cn/image/20200515154008.png" alt=""></p></li></ul><p>Eg：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE TRIGGER newproduct AFTER INSERT ON products</span><br><span class="line">FOR EACH ROW SELECT <span class="string">'Product added'</span></span><br></pre></td></tr></table></figure><p>CREATE TRIGGER用来创建名为newproduct的新触发器。触发器<br>可在一个操作发生之前或之后执行，这里给出了AFTER INSERT，<br>所以此触发器将在INSERT语句成功执行后执行。这个触发器还指定FOR EACH ROW，因此代码对每个插入行执行。在这个例子中，文本Product added将对每个插入的行显示一次.</p><p>  每个表最多支持6个触发器（每条INSERT、 UPDATE和DELETE的之前和之后）。单一触发器不能与多个事件或多个表关联，所以，如果你需要一个对INSERT和UPDATE操作执行的触发器，则应该定义两个触发器  .</p><h2 id="删除触发器"><a href="#删除触发器" class="headerlink" title="删除触发器"></a>删除触发器</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP TRIGGER newproduct;</span><br></pre></td></tr></table></figure><p>触发器不能更新或覆盖。为了修改一个触发器，必须先删除它，然后再重新创建。  </p><h2 id="使用-触发器"><a href="#使用-触发器" class="headerlink" title="使用 触发器"></a>使用 触发器</h2><h3 id="1-INSERT-触发器"><a href="#1-INSERT-触发器" class="headerlink" title="1 INSERT 触发器"></a>1 INSERT 触发器</h3><p>INSERT触发器在INSERT语句执行之前或之后执行。  </p><ul><li>在INSERT触发器代码内，可引用一个名为NEW的虚拟表，访问被插入的行；</li><li>在BEFORE INSERT触发器中， NEW中的值也可以被更新（允许更改被插入的值）；</li><li>对于AUTO_INCREMENT列， NEW在INSERT执行之前包含0，在INSERT 执行之后包含新的自动生成值  </li></ul><p>eg：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE TRIGGER neworder AFTER INSERT ON orders</span><br><span class="line">FOR EACH ROW SELECT NEW.order_num;</span><br></pre></td></tr></table></figure><p>此代码创建一个名为neworder的触发器，它按照AFTER INSERT<br>ON orders执行。在插入一个新订单到orders表时， MySQL生<br>成一个新订单号并保存到order_num中。触发器从NEW. order_num取得这个值并返回它。此触发器必须按照AFTER INSERT执行，因为在BEFORE INSERT语句执行之前，新order_num还没有生成。对于orders的每次插入使用这个触发器将总是返回新的订单号。  </p><p>试着插入一下新行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO orders(order_date,cust_id) VALUES(NOW(),10001);</span><br></pre></td></tr></table></figure><p><img src="https://photos.alitaalice.cn/image/20200515155708.png" alt=""></p><h3 id="DELETE-触发器"><a href="#DELETE-触发器" class="headerlink" title="DELETE 触发器"></a>DELETE 触发器</h3><ul><li>在DELETE触发器代码内，你可以引用一个名为OLD的虚拟表，访问被删除的行；</li><li>OLD中的值全都是只读的，不能更新。  </li></ul><p>下面例子用OLD保存将要被删除的行到一个存档表中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TRIGGER deleteorder BEFORE DELETE ON orders</span><br><span class="line">FOR EACH ROW</span><br><span class="line">BEGIN</span><br><span class="line">    <span class="function">INSERT INTO <span class="title">archive_orders</span><span class="params">(order_num, order_date,cust_id)</span> <span class="title">VALUES</span><span class="params">(OLD.order_num,OLD.order_date,OLD.cust_id)</span></span>;</span><br><span class="line">END;</span><br></pre></td></tr></table></figure><p>在任意订单被删除前将执行此触发器。它使用一条INSERT语句将OLD中的值（要被删除的订单）保存到一个名为archive_orders的存档表中（为实际使用这个例子，你需要用与orders相同的列创建一个名为archive_orders的表）  </p><h2 id="UPDATE-触发器"><a href="#UPDATE-触发器" class="headerlink" title="UPDATE 触发器"></a>UPDATE 触发器</h2><ul><li><p>在UPDATE触发器代码中，你可以引用一个名为OLD的虚拟表访问以前（UPDATE语句前）的值，引用一个名为NEW的虚拟表访问新更新的值；</p></li><li><p>在BEFORE UPDATE触发器中， NEW中的值可能也被更新（允许更改将要用于UPDATE语句中的值）；</p></li><li><p>OLD中的值全都是只读的，不能更新  </p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE TRIGGER updatevendor BERORE UPDATE ON vendors</span><br><span class="line">FOR EACH ROW SET NEW.vend_state=Upper(NEW.vend_state);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用游标mysql</title>
      <link href="/2020/05/14/%E4%BD%BF%E7%94%A8%E6%B8%B8%E6%A0%87mysql/"/>
      <url>/2020/05/14/%E4%BD%BF%E7%94%A8%E6%B8%B8%E6%A0%87mysql/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>本章介绍游标</p></blockquote><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p> MySQL检索操作返回一组称为结果集的行。这组返回的行都是与SQL语句相匹配的行（零行或多行）。使用简单的SELECT语<br>句，例如，没有办法得到第一行、下一行或前10行，也不存在每次一行地处理所有行的简单方法（相对于成批地处理它们）  </p><p>游标（cursor） 是一个存储在MySQL服务器上的数据库查询，<br>它不是一条SELECT语句，而是被该语句检索出来的结果集。在存储了游标之后，应用程序可以根据需要滚动或浏览其中的数据.  </p><p>只能用于存储过程 不像多数DBMS， MySQL游标只能用于<br>存储过程（和函数）  </p><h2 id="1-创建游标"><a href="#1-创建游标" class="headerlink" title="1 创建游标"></a>1 创建游标</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE PROCEDURE processorders()</span><br><span class="line">BEGIN </span><br><span class="line">   DECLARE ordernumbers CURSOR</span><br><span class="line">   FOR</span><br><span class="line">   SELECT order_num FROM orders</span><br><span class="line">END;</span><br></pre></td></tr></table></figure><p>DECLARE语句用来定义和命名游标，这里为ordernumbers。 存储过程处理完成后，游标就消失（因为它局限于存储过程）  </p><h2 id="2-打开和关闭游标"><a href="#2-打开和关闭游标" class="headerlink" title="2 打开和关闭游标"></a>2 打开和关闭游标</h2><p>输入：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OPEN ordernumbers;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">关闭游标： CLOSE ordernumbers;</span><br></pre></td></tr></table></figure><p>如果你不明确关闭游标，MySQL将会在到达END语句时自动关闭它。</p><p>前面的例子修改版本：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">CREATE PROCEDURE <span class="title">processorders</span><span class="params">()</span></span></span><br><span class="line"><span class="function">BEGIN</span></span><br><span class="line"><span class="function">     --Declare the cursor</span></span><br><span class="line"><span class="function">     DECLARE ordernumbers CURSOR</span></span><br><span class="line"><span class="function">     FOR</span></span><br><span class="line"><span class="function">     SELECT order_num FROM orders</span>;</span><br><span class="line">     --Open the cursor</span><br><span class="line">     OPEN ordernumbers;</span><br><span class="line">     --Close the cursor</span><br><span class="line">     CLOSE ordernumbers;</span><br><span class="line">     </span><br><span class="line">     END;</span><br></pre></td></tr></table></figure><p>声明打开和关闭一个游标。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">CREATE PROCEDURE <span class="title">processorders</span><span class="params">()</span></span></span><br><span class="line"><span class="function">BEGIN</span></span><br><span class="line"><span class="function">    --Delare local variables</span></span><br><span class="line"><span class="function">    DECLARE done BOOLEAN DEFAULT 0</span>;</span><br><span class="line">    DECLARE o INT;</span><br><span class="line">    --Declare the cursor</span><br><span class="line">    DECLARE ordernumbers CURSOR</span><br><span class="line">    FOR</span><br><span class="line">    SELECT order_num FROM orders;</span><br><span class="line">    --Declare <span class="keyword">continue</span> handler</span><br><span class="line">    DELARE CONTINUE HANDLER FOR SQLSTATE <span class="string">'02000'</span> SET done=<span class="number">1</span>;</span><br><span class="line">    --Open the cursor</span><br><span class="line">    OPEN ordernumbers;</span><br><span class="line">    --LOOP through all rows</span><br><span class="line">    REPEAT</span><br><span class="line">    </span><br><span class="line">    --GET order number</span><br><span class="line">    FETCH ordernumbers INTO o;</span><br><span class="line">    --End of loop</span><br><span class="line">    UNTIL done END REPEAT;</span><br><span class="line">    --Close the cursor</span><br><span class="line">    CLOSE ordernumbers;</span><br><span class="line">    END;</span><br></pre></td></tr></table></figure><p>FETCH是在REPEAT内，因此它反复执行直到done为真（由UNTIL<br>done END REPEAT;规定）。为使它起作用，用一个DEFAULT 0（假，不结束）定义变量done。那么， done怎样才能在结束时被设置为真呢？答案是用以下语句：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DECLARE CONTINUE HANDLER FOR SQLSTATE <span class="string">'02000'</span> SET done=<span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>这条语句定义了一个CONTINUE HANDLER，它是在条件出现时被执行的代码。这里， 它指出当SQLSTATE ‘02000’出现时， SET done=1。SQLSTATE’02000’是一个未找到条件， 当REPEAT由于没有更多的行供循环而不能继续时，出现这个条件。  </p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA源码问题</title>
      <link href="/2020/05/14/JAVA%E6%BA%90%E7%A0%81%E9%97%AE%E9%A2%98/"/>
      <url>/2020/05/14/JAVA%E6%BA%90%E7%A0%81%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>本章介绍JAVA源码问题</p></blockquote><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h2 id="说说常见的集合有哪些吧？"><a href="#说说常见的集合有哪些吧？" class="headerlink" title="说说常见的集合有哪些吧？"></a>说说常见的集合有哪些吧？</h2><p>答：Map 接口和 Collection 接口是所有集合框架的父接口：</p><ol><li>Collection 接口的子接口包括：Set 接口和 List 接口；</li><li>Map 接口的实现类主要有：HashMap、TreeMap、Hashtable、ConcurrentHashMap 以及 Properties 等；</li><li>Set 接口的实现类主要有：HashSet、TreeSet、LinkedHashSet 等；</li><li>List 接口的实现类主要有：ArrayList、LinkedList、Stack 以及 Vector 等。</li></ol><h3 id="当两个对象的hashcode相同时会发生什么，如何获取对象？"><a href="#当两个对象的hashcode相同时会发生什么，如何获取对象？" class="headerlink" title="当两个对象的hashcode相同时会发生什么，如何获取对象？"></a>当两个对象的hashcode相同时会发生什么，如何获取对象？</h3><p>因为hashcode相同，所以它们的bucket位置相同，‘碰撞’会发生。</p><p>两个对象的hashCode相同所以它们的bucket位置相同，找到bucket位置之后，会调用keys.equals()方法去找到链表中正确的节点 <strong><code>(key != null &amp;&amp; key.equals(k)</code></strong>。</p><p>因为HashMap使用链表存储对象，这个Entry(包含有键值对的Map.Entry对象)会存储在链表中。这个时候要理解根据hashcode来划分的数组，如果数组的坐标相同，则进入链表这个数据结构中了，一般的添加都在最前面，也就是和数组下标直接相连的地方，链表长度到达8的时候，jdk1.8上升为红黑树。</p><h3 id="HashMap的大小超过了负载因子-load-factor-定义的容量，怎么办"><a href="#HashMap的大小超过了负载因子-load-factor-定义的容量，怎么办" class="headerlink" title="HashMap的大小超过了负载因子(load factor)定义的容量，怎么办"></a>HashMap的大小超过了负载因子(load factor)定义的容量，怎么办</h3><p>会调用<strong><code>resize()</code></strong>进行数组扩容。</p><h2 id="HashMap中的tableSizeFor方法"><a href="#HashMap中的tableSizeFor方法" class="headerlink" title="HashMap中的tableSizeFor方法"></a>HashMap中的tableSizeFor方法</h2><p>在使用指定数组的初始容量时上面说过，数组容量必须是2的次方。所以就需要通过算法将我们给定的数值转换成2的次方。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个方法可以将任意一个整数转换成2的次方。</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="HashMap是线程安全的吗，为什么"><a href="#HashMap是线程安全的吗，为什么" class="headerlink" title="HashMap是线程安全的吗，为什么"></a>HashMap是线程安全的吗，为什么</h2><p>HashMap底层是一个Entry数组，当发生hash冲突的时候，hashmap是采用链表的方式来解决的，在对应的数组位置存放链表的头结点。对链表而言，新加入的节点会从头结点加入。</p><p>1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">        table[bucketIndex] = <span class="keyword">new</span> Entry&lt;K,V&gt;(hash, key, value, e);</span><br><span class="line">        <span class="keyword">if</span> (size++ &gt;= threshold)</span><br><span class="line">            resize(<span class="number">2</span> * table.length);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在hashmap做put操作的时候会调用到以上的方法。现在假如A线程和B线程同时对同一个数组位置调用addEntry，两个线程会同时得到现在的头结点，然后A写入新的头结点之后，B也写入新的头结点，那B的写入操作就会覆盖A的写入操作造成A的写入操作丢失</p><p>2</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">removeEntryForKey</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> hash = (key == <span class="keyword">null</span>) ? <span class="number">0</span> : hash(key.hashCode());</span><br><span class="line">        <span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line">        Entry&lt;K,V&gt; prev = table[i];</span><br><span class="line">        Entry&lt;K,V&gt; e = prev;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">            Object k;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                modCount++;</span><br><span class="line">                size--;</span><br><span class="line">                <span class="keyword">if</span> (prev == e)</span><br><span class="line">                    table[i] = next;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    prev.next = next;</span><br><span class="line">                e.recordRemoval(<span class="keyword">this</span>);</span><br><span class="line">                <span class="keyword">return</span> e;</span><br><span class="line">            &#125;</span><br><span class="line">            prev = e;</span><br><span class="line">            e = next;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>删除键值对的代码如上：</p><p>当多个线程同时操作同一个数组位置的时候，也都会先取得现在状态下该位置存储的头结点，然后各自去进行计算操作，之后再把结果写会到该数组位置去，其实写回的时候可能其他的线程已经就把这个位置给修改过了，就会覆盖其他线程的修改</p><p>3、addEntry中当加入新的键值对后键值对总数量超过门限值的时候会调用一个resize操作，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;</span><br><span class="line">        Entry[] oldTable = table;</span><br><span class="line">        <span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line">        <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];</span><br><span class="line">        transfer(newTable);</span><br><span class="line">        table = newTable;</span><br><span class="line">        threshold = (<span class="keyword">int</span>)(newCapacity * loadFactor);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这个操作会新生成一个新的容量的数组，然后对原数组的所有键值对重新进行计算和写入新的数组，之后指向新生成的数组。</p><p>当多个线程同时检测到总数量超过门限值的时候就会同时调用resize操作，各自生成新的数组并rehash后赋给该map底层的数组table，结果最终只有最后一个线程生成的新数组被赋给table变量，其他线程的均会丢失。而且当某些线程已经完成赋值而其他线程刚开始的时候，就会用已经被赋值的table作为原始数组，这样也会有问题。</p><h2 id="哪些是线程安全的容器"><a href="#哪些是线程安全的容器" class="headerlink" title="哪些是线程安全的容器"></a>哪些是线程安全的容器</h2><p>同步容器类：</p><p>使用了synchronized<br>1.Vector<br>2.HashTable</p><p>并发容器：<br>3.ConcurrentHashMap:分段<br>4.CopyOnWriteArrayList：写时复制<br>5.CopyOnWriteArraySet：写时复制</p><h3 id="Hashtable和HashMap的区别"><a href="#Hashtable和HashMap的区别" class="headerlink" title="Hashtable和HashMap的区别"></a>Hashtable和HashMap的区别</h3><h3 id="HashMap多线程处理之快速失败机制"><a href="#HashMap多线程处理之快速失败机制" class="headerlink" title="HashMap多线程处理之快速失败机制"></a>HashMap多线程处理之快速失败机制</h3><h3 id="jdk7和jdk8的HashMap实现的区别"><a href="#jdk7和jdk8的HashMap实现的区别" class="headerlink" title="jdk7和jdk8的HashMap实现的区别"></a>jdk7和jdk8的HashMap实现的区别</h3><h3 id="HashMap与LinkedHashMap和TreeMap的区别"><a href="#HashMap与LinkedHashMap和TreeMap的区别" class="headerlink" title="HashMap与LinkedHashMap和TreeMap的区别"></a>HashMap与LinkedHashMap和TreeMap的区别</h3>]]></content>
      
      
      <categories>
          
          <category> JAVA源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉查找树</title>
      <link href="/2020/05/14/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/"/>
      <url>/2020/05/14/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>本章介绍</p></blockquote><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>定义：一棵二叉查找树 （BST）是一棵二叉树，其中每个结点都含有一个 Comparable 的键（以及相关联的值）且每个结点的键都大于其左子树中的任意结点的键而小于右子树的任意结点的键。  </p><p><img src="https://photos.alitaalice.cn/image/20200514134241.png" alt=""></p><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p>一般来说，在符号表中查找一个键可能得到两种结果。如果含有该键的结点存在于表中，我们的查找就命<br>中 了，然后返回相应的值。否则查找未命中 （并返回 null ）。根据数据表示的递归结构我们马上就能得到，在二叉查找树中查找一个键的递归算法：如果树是空的，则查找未命中；如果被查找的键和根结点的键相等，查找命中，否则我们就（递归地）在适当的子树中继续查找。如果被查找的键较小就选择左子树，较大则选择右子树。算法 3.3（续 1）中递归的 get() 方法完全实现了这段算法。它的第一个参 数是一个结点（子树的根结点），第二个参数是被查找的键。  </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>归并排序</title>
      <link href="/2020/05/14/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
      <url>/2020/05/14/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>本章介绍归并排序</p></blockquote><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>在本节中我们所讨论的算法都基于归并 这个简单的操作，即将两个有序的数组归并成一个更大的有序数组。很快人们就根据这个操作发明了一种简单的递归排序算法：<strong>归并排序</strong> 。  </p><p><img src="https://photos.alitaalice.cn/image/20200514103423.png" alt=""></p><p>​                                         归并排序示意图  </p><h2 id="原地归并"><a href="#原地归并" class="headerlink" title="原地归并"></a>原地归并</h2>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DataStructure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>观察者模式</title>
      <link href="/2020/05/14/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
      <url>/2020/05/14/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>本章介绍观察者模式</p></blockquote><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p><img src="https://photos.alitaalice.cn/image/20200527204326.png" alt="">)<img src="C:%5CUsers%5C16508%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200527204301788.png" alt="image-20200527204301788"></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>策略模式</title>
      <link href="/2020/05/14/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
      <url>/2020/05/14/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>本章介绍策略模式。</p></blockquote><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h2 id="策略模式："><a href="#策略模式：" class="headerlink" title="策略模式："></a>策略模式：</h2><p><img src="https://photos.alitaalice.cn/image/20200514101320.png" alt=""></p><p><img src="https://photos.alitaalice.cn/image/20200527205338.png" alt=""></p><p><img src="https://photos.alitaalice.cn/image/20200527205407.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 理论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络基础TCP/IP</title>
      <link href="/2020/05/13/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80TCP-IP/"/>
      <url>/2020/05/13/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80TCP-IP/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>本章介绍网络基础TCP/IP</p></blockquote><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h2 id="1-TCP-IP的定义"><a href="#1-TCP-IP的定义" class="headerlink" title="1 TCP/IP的定义"></a>1 TCP/IP的定义</h2><p>定义：计算机与网络设备要相互通信，双方就必须基于相同的方法。比如，如何探测到通信目标、由哪一边先发起通信、使用哪种语言进行通信、怎样结束通信等规则都需要事先确定。不同的硬件、操作系统之间的通信，所有的这一切都需要一种规则。而我们就把这种规则称为协议（protocol）。  </p><p><img src="https://photos.alitaalice.cn/image/20200513211754.png" alt=""></p><p>图：TCP/IP 是互联网相关的各类协议族的总称  </p><h2 id="2-TCP-IP的分层管理"><a href="#2-TCP-IP的分层管理" class="headerlink" title="2 TCP/IP的分层管理"></a>2 TCP/IP的分层管理</h2><p>TCP/IP 协议族里重要的一点就是分层。TCP/IP 协议族按层次分别分为以下 4 层：应用层、传输层、网络层和数据链路层。  </p><p>把 TCP/IP 层次化是有好处的。比如，如果互联网只由一个协议统筹，某个地方需要改变设计时，就必须把所有部分整体替换掉。而分层之后只需把变动的层替换掉即可。把各层之间的接口部分规划好之后，每个层次内部的设计就能够自由改动了。  </p><h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><p><strong>应用层决定了向用户提供应用服务时通信的活动。</strong><br>TCP/IP 协议族内预存了各类通用的应用服务。比如，FTP（File Transfer Protocol，文件传输协议）和DNS（Domain Name System，域名系统）服务就是其中两类。<br>HTTP 协议也处于该层。  </p><h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><p>传输层对上层应用层，提供处于网络连接中的两台计算机之间的数据传输。<strong>在传输层有两个性质不同的协议：TCP（Transmission Control Protocol，传输控制协议）和 UDP（User Data Protocol，用户数据报协议）</strong>  </p><h2 id="网络层（又名网络互连层）"><a href="#网络层（又名网络互连层）" class="headerlink" title="网络层（又名网络互连层）"></a>网络层（又名网络互连层）</h2><p>网络层用来处理在网络上流动的数据包。数据包是网络传输的最小数据单位。<strong>该层规定了通过怎样的路径（所谓的传输路线）到达对方计算机，并把数据包传送给对方。</strong><br>与对方计算机之间通过多台计算机或网络设备进行传输时，网络层所起的作用就是在众多的选项内选择一条传输路线。  </p><h2 id="链路层（又名数据链路层，网络接口层）"><a href="#链路层（又名数据链路层，网络接口层）" class="headerlink" title="链路层（又名数据链路层，网络接口层）"></a>链路层（又名数据链路层，网络接口层）</h2><p>用来处理连接网络的硬件部分。包括控制操作系统、硬件的设备驱动、NIC（Network Interface Card，网络适配器，即网卡），及光纤等物理可见部分（还包括连接器等一切传输媒介）。硬件上的范畴均在链<br>路层的作用范围之内。  </p><h2 id="3-流程"><a href="#3-流程" class="headerlink" title="3 流程"></a>3 流程</h2><p><img src="https://photos.alitaalice.cn/image/20200513213825.png" alt=""></p><p>利用 TCP/IP 协议族进行网络通信时，会通过分层顺序与对方进行通信。发送端从应用层往下走，接收端则往应用层往上走。<br>我们用 HTTP 举例来说明，首先作为发送端的客户端在应用层（HTTP 协议）发出一个想看某个 Web 页面的 HTTP 请求。</p><p>接着，为了传输方便，在传输层（TCP 协议）把从应用层处收到的数据（HTTP 请求报文）进行分割，并在各个报文上打上标记序号及端口号后转发给网络层。</p><p>在网络层（IP 协议），增加作为通信目的地的 MAC 地址后转发给链路层。这样一来，发往网络的通信请求就准备齐全了。<br>接收端的服务器在链路层接收到数据，按序往上层发送，一直到应用层。当传输到应用层，才能算真正接收到由客户端发送过来的 HTTP 请求。  </p><p><img src="https://photos.alitaalice.cn/image/20200513214119.png" alt=""></p><p>发送端在层与层之间传输数据时，每经过一层时必定会被打上一个该层所属的首部信息。反之，接收端在层与层传输数据时，每经过一层时会把对应的首部消去。<br>这种把数据信息包装起来的做法称为封装（encapsulate）  </p><h2 id="4-IP-TCP-DNS"><a href="#4-IP-TCP-DNS" class="headerlink" title="4 IP.TCP.DNS"></a>4 IP.TCP.DNS</h2><h3 id="4-1-IP"><a href="#4-1-IP" class="headerlink" title="4.1 IP"></a>4.1 IP</h3><p>按层次分，IP（Internet Protocol）网际协议位于网络层。  可能有人会把“IP”和“IP 地址”搞混，“IP”其实是一种协议的名称  </p><p>IP 协议的作用是把各种数据包传送给对方。而要保证确实传送到对方那里，则需要满足各类条件。其中两个重要的条件是 IP 地址和 MAC 地址（Media Access Control Address）  </p><p>IP 地址指明了节点被分配到的地址，MAC 地址是指网卡所属的固定地址。IP 地址可以和 MAC 地址进行配对。IP 地址可变换，但 MAC 地址基本上不会更改。  </p>]]></content>
      
      
      <categories>
          
          <category> 计网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP/IP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于拉链和线性探测法的散列表</title>
      <link href="/2020/05/13/%E5%9F%BA%E4%BA%8E%E6%8B%89%E9%93%BE%E5%92%8C%E7%BA%BF%E6%80%A7%E6%8E%A2%E6%B5%8B%E6%B3%95%E7%9A%84%E6%95%A3%E5%88%97%E8%A1%A8/"/>
      <url>/2020/05/13/%E5%9F%BA%E4%BA%8E%E6%8B%89%E9%93%BE%E5%92%8C%E7%BA%BF%E6%80%A7%E6%8E%A2%E6%B5%8B%E6%B3%95%E7%9A%84%E6%95%A3%E5%88%97%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>本章介绍基于拉链和线性探测法的散列表</p></blockquote><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>使用散列的查找算法分为两步。第一步是用散列函数 将被查找的键转化为数组的一个索引。理想情况下，不同的键都能转化为不同的索引值。当然，这只是理想情况，所以我们需要面对两个或者多个键都会散列到相同的索引值的情况。因此，散列查找的第二步就是一个处理碰撞冲突 的过程，如图 所示。在描述了多种散列函数的计算后，我们会学习两种解决碰撞的方法：拉链法 和 线性探测法 。  </p><p><img src="https://photos.alitaalice.cn/image/20200514100602.png" alt=""></p><h3 id="散列表的核心问题"><a href="#散列表的核心问题" class="headerlink" title="散列表的核心问题"></a>散列表的核心问题</h3><p>散列表是算法在时间和空间上作出权衡的 经典例子。如果没有内存限制，我们可以直接将键作为（可能是一个超大的）数组的索引，那么所有查找操作只需要访问内存一次即可完成。但这种理想情况不会经常出现，因为当键很多时需要的内存太大。另一方面，如果没有时间限制，我们可以使用无序数组并进行顺序查找，这样就只需要很少的内存。而散列表则使用了适度的空间和时间并在这两个极端之间找到了一种平衡。事实上，我们不必重写代码，只需要调整散列算法的参数就可以在空间和时间之间作出取舍。我们会使用概率论的经典结论来帮助我们选择适当的参数。  </p><h3 id="基于拉链法的散列表"><a href="#基于拉链法的散列表" class="headerlink" title="基于拉链法的散列表"></a>基于拉链法的散列表</h3><p>一个散列函数能够将键转化为数组索引。散列算法的第二步是碰撞处理 ，也就是处理两个或多个键的散列值相同的情况。<strong>一种直接的办法是将大小为 M的数组中的每个元素指向一条链表，链表中的每个结点都存储了散列值为该元素的索引的键值对。这种方法被称为拉链法</strong> ，因为发生冲突的元素都被存储在链表中。这个方法的基本思想就是选择足够大的 ，使得所有链表都尽可能短以保证高效的查找。查找分两步：首先根据散列值找到对应的链表，然后沿着链表顺序查找相应的键。  </p><h3 id="散列表的大小"><a href="#散列表的大小" class="headerlink" title="散列表的大小"></a>散列表的大小</h3><p>在实现基于拉链法的散列表时，我们的目标是选择适当的数组大小 M，既不会因为空链表而浪费大量内存，也不会因为链表太长而在查找上浪费太多时间。而拉链法的一个好处就是这并不是关键性的选择。如果存入的键多于预期，查找所需的时间只会比选择更大的数组稍长；如果少于预期，虽然有些空间浪费但查找会非常快。当内存不是很紧张时，可以选择一个足够大的 M，使得查找需要的时间变为常数；当内存紧张时，选择尽量大的M仍然能够将性能提高 M倍。  </p><h3 id="基于线性探测法的散列表"><a href="#基于线性探测法的散列表" class="headerlink" title="基于线性探测法的散列表"></a>基于线性探测法的散列表</h3><p>实现散列表的另一种方式就是用大小为 M的数组保存N 个键值对，其中 M&gt;N。我们需要依靠数组中的空位 解决碰撞冲突。基于这种策略的所有方法被统称为开放地址 散列表。 </p><p> 开放地址散列表中最简单的方法叫做线性探测法 ：当碰撞发生时（当一个键的散列值已经被另一个不同的键占用），我们直接检查散列表中的下一个位置（将索引值加 1）。这样的线性探测可能会产生三种结果：  </p><ul><li>命中，该位置的键和被查找的键相同；</li><li>未命中，键为空（该位置没有键）；</li><li>继续查找，该位置的键和被查找的键不同。  </li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DataStructure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>散列表详解</title>
      <link href="/2020/05/13/%E6%95%A3%E5%88%97%E8%A1%A8%E8%AF%A6%E8%A7%A3/"/>
      <url>/2020/05/13/%E6%95%A3%E5%88%97%E8%A1%A8%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>本章介绍散列表。</p></blockquote><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h2 id="散列函数"><a href="#散列函数" class="headerlink" title="散列函数"></a>散列函数</h2><p>我们面对的第一个问题就是散列函数的计算，这个过程会将键转化为数组的索引。如果我们有一个能够保存 M个键值对的数组，那么我们就需要一个能够将任意键转化为该数组范围内的索引([0,M-1] 范围内的整数）的散列函数 -</p><p>散列函数和键的类型有关。<strong>严格地说，对于每种类型的键都我们都需要一个与之对应的散列函数 。</strong>如果键是一个数，比如社会保险号，我们就可以直接使用这个数；如果键是一个字符串，比如一个人的名字，<br>我们就需要将这个字符串转化为一个数；<strong>如果键含有多个部分，比如邮件地址，我们需要用某种方法将这些部分结合起来</strong>。对于许多常见类型的键，我们可以利用 Java 提供的默认实现。我们会简略讨论多种数<br>据类型的散列函数。你应该看看它们是如何实现的，因为你也需要为自定义的类型实现散列函数。  </p><h3 id="正整数"><a href="#正整数" class="headerlink" title="正整数"></a>正整数</h3><p>将整数散列最常用方法是<strong>除留余数法</strong> 。我们选择大小为素数 的数组，对于任意正整数 ，计算除以M 的余数。这个函数的计算非常容易（在 Java 中为 k% M ）并能够有效地将键散布在 0 到M-1的范围内。  </p><p><img src="https://photos.alitaalice.cn/image/20200513162105.png" alt=""></p><h3 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h3><p>如果键是 0 到 1 之间的实数，我们可以将它乘以 M并四舍五入得到一个 0 至 M-1之间的索引值。<br>尽管这个方法很容易理解，但它是有缺陷的，因为这种情况下键的高位起的作用更大，最低位对散列的结果没有影响。修正这个问题的办法是将键表示为二进制数然后再使用除留余数法（Java 就是这么做的）  </p><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h2 id="组合键"><a href="#组合键" class="headerlink" title="组合键"></a>组合键</h2><h2 id="JAVA的约定"><a href="#JAVA的约定" class="headerlink" title="JAVA的约定"></a>JAVA的约定</h2><p>每种数据类型都需要相应的散列函数，于是 Java 令所有数据类型都继承了一个能够返回一个 32 比特整数的 hashCode() 方法。每一种数据类型的 hashCode() 方法都必须和 equals() 方法一致 。也就是说，如果 a.equals(b) 返回 true ，那么 a.hashCode() 的返回值必然和 b.hashCode()的返回值相同。相反，如果两个对象的 hashCode() 方法的返回值不同，那么我们就知道这两个对象是不同的。但如果两个对象的 hashCode() 方法的返回值相同，这两个对象也有可能不同，我们还需要用equals() 方法进行判断。请注意，这说明如果你要为自定义的数据类型定义散列函数，你需要同时重写 hashCode() 和 equals() 两个方法。默认散列函数会返回对象的内存地址，但这只适用于很少的情况。Java 为很多常用的数据类型重写了 hashCode() 方法（包括 String 、Integer 、Double、File 和 URL ）。  </p><h3 id="将hashCode-的返回值转化为一个数组索引"><a href="#将hashCode-的返回值转化为一个数组索引" class="headerlink" title="将hashCode()的返回值转化为一个数组索引"></a>将hashCode()的返回值转化为一个数组索引</h3><p>因为我们需要的是数组的索引而不是一个 32 位的整数，我们在实现中会将默认的 hashCode() 方法和除留余数法结合起来产生一个 0 到M-1 的整数，方法如下：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Key x)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> (x.hashCode() &amp; <span class="number">0x7fffffff</span>) % M; &#125;</span><br></pre></td></tr></table></figure><p>这段代码会将符号位屏蔽（将一个 32 位整数变为一个 31 位非负整数），然后用除留余数法计算它除以M 的余数。在使用这样的代码时我们一般会将数组的大小 M 取为素数 以充分利用原散列值的所有位。  </p><h3 id="自定义的hashCode-方法"><a href="#自定义的hashCode-方法" class="headerlink" title="自定义的hashCode()方法"></a>自定义的hashCode()方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Transaction</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String who;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Date when;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">double</span> amount;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> hash = <span class="number">17</span>;</span><br><span class="line">hash = <span class="number">31</span> * hash + who.hashCode();</span><br><span class="line">hash = <span class="number">31</span> * hash + when.hashCode();</span><br><span class="line">hash = <span class="number">31</span> * hash+ ((Double) amount).hashCode();</span><br><span class="line"><span class="keyword">return</span> hash;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义类型中 hashCode() 方法的实现  </p><p>对于原始类型的对象，可以将其转化为对应的数据类型然后再调用 hashCode() 方法。和以前一样，系数的具体值（这里是 31）并不是很重要。  </p><h3 id="软缓存"><a href="#软缓存" class="headerlink" title="软缓存"></a>软缓存</h3><p>如果散列值的计算很耗时，那么我们或许可以将每个键的散列值缓存起来 ，即在每个键中使用一个hash 变量来保存它的 hashCode() 的返回值（请见练习 3.4.25）。第一次调用 hashCode() 方法时，我们需要计算对象的散列值，但之后对 hashCode() 方法的调用会直接返回 hash 变量的值。<br>Java 的 String 对象的 hashCode() 方法就使用了这种方法来减少计算量。  </p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DataStructure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP状态码</title>
      <link href="/2020/05/13/HTTP%E7%8A%B6%E6%80%81%E7%A0%81/"/>
      <url>/2020/05/13/HTTP%E7%8A%B6%E6%80%81%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>本章介绍返回结果的HTTP状态码。</p></blockquote><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h1 id="1-状态码告知从服务器端返回的请求结果"><a href="#1-状态码告知从服务器端返回的请求结果" class="headerlink" title="1 状态码告知从服务器端返回的请求结果"></a>1 状态码告知从服务器端返回的请求结果</h1><p>状态码的职责是当客户端向服务器端发送请求时，描述返回的请求结果。借助状态码，用户可以知道服务器端是正常处理了请求，还是出现了错误  </p><p><img src="https://photos.alitaalice.cn/image/20200513120418.png" alt=""></p><p>状态码如 200 OK，以 3 位数字和原因短语组成。<br>数字中的第一位指定了响应类别，后两位无分类。响应类别有以下 5 种  </p><p><img src="https://photos.alitaalice.cn/image/20200513120523.png" alt=""></p><h2 id="2XX-成功"><a href="#2XX-成功" class="headerlink" title="2XX 成功"></a>2XX 成功</h2><h3 id="2-1-200-OK"><a href="#2-1-200-OK" class="headerlink" title="2.1 200 OK"></a>2.1 200 OK</h3><p><img src="https://photos.alitaalice.cn/image/20200513120936.png" alt=""></p><p>表示从客户端发来的请求在服务器端被正常处理了。<br>在响应报文内，随状态码一起返回的信息会因方法的不同而发生改变。比如，使用 GET 方法时，对应请求资源的实体会作为响应返回；而使用 HEAD 方法时，对应请求资源的实体首部不随报文主体作为响应返回（即在响应中只返回首部，不会返回实体的主体部分）  </p><h3 id="2-2-204-NOT-Content"><a href="#2-2-204-NOT-Content" class="headerlink" title="2.2 204 NOT Content"></a>2.2 204 NOT Content</h3><p><img src="https://photos.alitaalice.cn/image/20200513121124.png" alt=""></p><p>该状态码代表服务器接收的请求已成功处理，但在返回的响应报文中不含实体的主体部分。另外，也不允许返回任何实体的主体。比如，当从浏览器发出请求处理后，返回 204 响应，那么浏览器显示的页面不发生更新。<br>一般在只需要从客户端往服务器发送信息，而对客户端不需要发送新信息内容的情况下使用。  </p><h3 id="2-3-206-Partial-Content"><a href="#2-3-206-Partial-Content" class="headerlink" title="2.3 206 Partial Content"></a>2.3 206 Partial Content</h3><p><img src="https://photos.alitaalice.cn/image/20200513121229.png" alt=""></p><p>该状态码表示客户端进行了范围请求，而服务器成功执行了这部分的 GET 请求。响应报文中包含由Content-Range 指定范围的实体内容。  </p><h2 id="3-3XX-重定向"><a href="#3-3XX-重定向" class="headerlink" title="3 3XX 重定向"></a>3 3XX 重定向</h2><p>3XX 响应结果表明浏览器需要执行某些特殊的处理以正确处理请求。  </p><h3 id="3-1-301-Moved-Permanently"><a href="#3-1-301-Moved-Permanently" class="headerlink" title="3.1 301 Moved Permanently"></a>3.1 301 Moved Permanently</h3><p><img src="https://photos.alitaalice.cn/image/20200513121404.png" alt=""></p><p>永久性重定向。该状态码表示请求的资源已被分配了新的 URI，以后应使用资源现在所指的 URI。也就是说，如果已经把资源对应的 URI 保存为书签了，这时应该按 Location 首部字段提示的 URI 重新保存。像下方给出的请求 URI，当指定资源路径的最后忘记添加斜杠“/”，就会产生 301 状态码。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;example.com&#x2F;sample</span><br></pre></td></tr></table></figure><h3 id="3-2-302-Found"><a href="#3-2-302-Found" class="headerlink" title="3.2 302 Found"></a>3.2 302 Found</h3><p><img src="https://photos.alitaalice.cn/image/20200513121815.png" alt=""></p><h3 id="3-3-303-See-Other"><a href="#3-3-303-See-Other" class="headerlink" title="3.3  303 See Other"></a>3.3  303 See Other</h3><p><img src="https://photos.alitaalice.cn/image/20200513122022.png" alt=""></p><p>该状态码表示由于请求对应的资源存在着另一个 URI，应使用 GET 方法定向获取请求的资源。<br>303 状态码和 302 Found 状态码有着相同的功能，但 303 状态码明确表示客户端应当采用 GET 方法获取资源，这点与 302 状态码有区别。<br>比如，当使用 POST 方法访问 CGI 程序，其执行后的处理结果是希望客户端能以 GET 方法重定向到另一个 URI 上去时，返回 303 状态码。虽然 302 Found 状态码也可以实现相同的功能，但这里使用 303 状态码是最理想的。  </p><h3 id="3-4-304-Not-Modified"><a href="#3-4-304-Not-Modified" class="headerlink" title="3.4 304 Not Modified"></a>3.4 304 Not Modified</h3><p><img src="C:%5CUsers%5C16508%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200513122317593.png" alt="image-20200513122317593"></p><p>该状态码表示客户端发送附带条件的请求 2 时，服务器端允许请求访问资源，但未满足条件的情况。304状态码返回时，不包含任何响应的主体部分。304 虽然被划分在 3XX 类别中，但是和重定向没有关系。  </p><h3 id="3-5-307-Temporary-Redirect"><a href="#3-5-307-Temporary-Redirect" class="headerlink" title="3.5 307 Temporary Redirect"></a>3.5 307 Temporary Redirect</h3><p>临时重定向。该状态码与 302 Found 有着相同的含义。尽管 302 标准禁止 POST 变换成 GET，但实际使用时大家并不遵守。<br>307 会遵照浏览器标准，不会从 POST 变成 GET。但是，对于处理响应时的行为，每种浏览器有可能出现不同的情况。</p><h2 id="4-4XX客户端错误"><a href="#4-4XX客户端错误" class="headerlink" title="4 4XX客户端错误"></a>4 4XX客户端错误</h2><h3 id="4-1-400-Bad-Request"><a href="#4-1-400-Bad-Request" class="headerlink" title="4.1 400 Bad Request"></a>4.1 400 Bad Request</h3><p><img src="https://photos.alitaalice.cn/image/20200513122701.png" alt=""></p><p>该状态码表示请求报文中存在语法错误。当错误发生时，需修改请求的内容后再次发送请求。另外，浏览器会像 200 OK 一样对待该状态码。  </p><h3 id="4-2-401-Unauthorized"><a href="#4-2-401-Unauthorized" class="headerlink" title="4.2 401 Unauthorized"></a>4.2 401 Unauthorized</h3><p>-+<img src="https://photos.alitaalice.cn/image/20200513122941.png" alt=""></p><p>该状态码表示发送的请求需要有通过 HTTP 认证（BASIC 认证、DIGEST 认证）的认证信息。另外若之前已进行过 1 次请求，则表示用户认证失败。  </p><h3 id="4-3-403-Forbidden"><a href="#4-3-403-Forbidden" class="headerlink" title="4.3 403 Forbidden"></a>4.3 403 Forbidden</h3><p><img src="https://photos.alitaalice.cn/image/20200513123055.png" alt=""></p><p>该状态码表明对请求资源的访问被服务器拒绝了。服务器端没有必要给出拒绝的详细理由，但如果想作说明的话，可以在实体的主体部分对原因进行描述，这样就能让用户看到了。<br>未获得文件系统的访问授权，访问权限出现某些问题（从未授权的发送源 IP 地址试图访问）等列举的情况都可能是发生 403 的原因。  </p><h3 id="4-4-404-Not-Found"><a href="#4-4-404-Not-Found" class="headerlink" title="4.4 404 Not Found"></a>4.4 404 Not Found</h3><p><img src="https://photos.alitaalice.cn/image/20200513123152.png" alt=""></p><p>该状态码表明服务器上无法找到请求的资源。除此之外，也可以在服务器端拒绝请求且不想说明理由时使用。  </p><h2 id="5-5XX-服务器错误"><a href="#5-5XX-服务器错误" class="headerlink" title="5 5XX 服务器错误"></a>5 5XX 服务器错误</h2><p>5XX 的响应结果表明服务器本身发生错误。  </p><h3 id="5-1-500-Internal-Server-Error"><a href="#5-1-500-Internal-Server-Error" class="headerlink" title="5.1 500 Internal Server Error"></a>5.1 500 Internal Server Error</h3><p>该状态码表明服务器端在执行请求时发生了错误。也有可能是 Web 应用存在的 bug 或某些临时的故障。  <img src="C:%5CUsers%5C16508%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200513123521561.png" alt="image-20200513123521561"></p><h3 id="5-2-503-Service-Unavailable"><a href="#5-2-503-Service-Unavailable" class="headerlink" title="5.2 503 Service Unavailable"></a>5.2 503 Service Unavailable</h3><p><img src="https://photos.alitaalice.cn/image/20200513123558.png" alt=""></p><p>该状态码表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。如果事先得知解除以上状况需要的时间，最好写入 RetryAfter 首部字段再返回给客户端。  </p>]]></content>
      
      
      <categories>
          
          <category> 计网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMap默认加载因子为什么选择0.75</title>
      <link href="/2020/05/13/HashMap%E9%BB%98%E8%AE%A4%E5%8A%A0%E8%BD%BD%E5%9B%A0%E5%AD%90%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A90.75/"/>
      <url>/2020/05/13/HashMap%E9%BB%98%E8%AE%A4%E5%8A%A0%E8%BD%BD%E5%9B%A0%E5%AD%90%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A90.75/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>本章介绍HashMap加载因子和初始容量</p></blockquote><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>转载自<a href="https://www.cnblogs.com/aspirant/p/11470928.html">https://www.cnblogs.com/aspirant/p/11470928.html</a></p>]]></content>
      
      
      <categories>
          
          <category> JAVA源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用存储过程</title>
      <link href="/2020/05/12/%E4%BD%BF%E7%94%A8%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B-1/"/>
      <url>/2020/05/12/%E4%BD%BF%E7%94%A8%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B-1/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>本章介绍什么是存储过程，为什么要使用存储过程以及如何使用存储过程，并且介绍创建和使用存储过程的基本语法。  </p></blockquote><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>存储过程简单来说，就是为以后的使用而保存的一条或多条MySQL语句的集合。可将其视为批文件，虽然它们的作用不仅限于批处理  。</p><h2 id="为什么要使用存储过程"><a href="#为什么要使用存储过程" class="headerlink" title="为什么要使用存储过程"></a>为什么要使用存储过程</h2><p>理由：</p><ul><li>通过把处理封装在容易使用的单元中，简化复杂的操作（正如前面例子所述）。</li><li>由于不要求反复建立一系列处理步骤，这保证了数据的完整性。如果所有开发人员和应用程序都使用同一（试验和测试）存储过程，则所使用的代码都是相同的。这一点的延伸就是防止错误。需要执行的步骤越多，出错的可能性就越大。防止错误保证了数据的一致性。</li><li>简化对变动的管理。如果表名、列名或业务逻辑（或别的内容）有变化，只需要更改存储过程的代码。使用它的人员甚至不需要知道这些变化。</li></ul><p>这一点的延伸就是安全性。通过存储过程限制对基础数据的访问减少了数据讹误（无意识的或别的原因所导致的数据讹误）的机会。</p><ul><li>提高性能。因为使用存储过程比使用单独的SQL语句要快。</li><li>存在一些只能用在单个请求中的MySQL元素和特性，存储过程可以使用它们来编写功能更强更灵活的代码（在下一章的例子中可以看到。）  </li></ul><p>换句话说，使用存储过程有3个主要的好处，即简单、安全、高性能。显然，它们都很重要。不过，在将SQL代码转换为存储过程前，也必须知道它的一些缺陷。  </p><ul><li><p>一般来说，存储过程的编写比基本SQL语句复杂，编写存储过程需要更高的技能，更丰富的经验。  </p></li><li><p>你可能没有创建存储过程的安全访问权限。许多数据库管理员限制存储过程的创建权限，允许用户使用存储过程，但不允许他们创建存储过程。  </p></li></ul><h2 id="eg：一个返回产品平均价格的存储过程"><a href="#eg：一个返回产品平均价格的存储过程" class="headerlink" title="eg：一个返回产品平均价格的存储过程"></a>eg：一个返回产品平均价格的存储过程</h2><p><img src="https://photos.alitaalice.cn/image/20200513001100.png" alt=""></p><p>此存储过程名为productpricing，用CREATE PROCEDURE productpricing()语句定义。如果存储过程接受参数，它们将在()中列举出来。此存储过程没有参数，但后跟的()仍然需要。 BEGIN和END语句用来限定存储过程体，过<br>程体本身仅是一个简单的SELECT语句。如何使用这个存储过程呢？</p><p><img src="https://photos.alitaalice.cn/image/20200513001134.png" alt=""></p><p><img src="https://photos.alitaalice.cn/image/20200513001157.png" alt=""></p><p><img src="https://photos.alitaalice.cn/image/20200513001232.png" alt=""></p><h4 id="如何使用这个存储过程-？"><a href="#如何使用这个存储过程-？" class="headerlink" title="如何使用这个存储过程  ？"></a>如何使用这个存储过程  ？</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">CALL <span class="title">productpricing</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p><img src="https://photos.alitaalice.cn/image/20200513001250.png" alt=""></p><h4 id="如何删除这个存储过程？"><a href="#如何删除这个存储过程？" class="headerlink" title="如何删除这个存储过程？"></a>如何删除这个存储过程？</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP PROCEDURE productpricing;</span><br></pre></td></tr></table></figure><p>仅当存在时删除 如果指定的过程不存在，则DROP PROCEDURE将产生一个错误。当过程存在想删除它时（如果过程不存在也不产生错误）可使用DROP PROCEDURE IF EXISTS。  </p><h4 id="使用参数"><a href="#使用参数" class="headerlink" title="使用参数"></a>使用参数</h4><p>productpricing只是一个简单的存储过程，它简单地显示SELECT语句的结果。一般，存储过程并不显示结果，而是把结果返回给你指定的变量。    </p><p>变量（variable） 内存中一个特定的位置，用来临时存储数据。  以下productpricing的修改版本（如果不先删除此存储过程，则不能再次创建它）：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">CREATE PROCEDURE <span class="title">productpricing</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">              OUT p1 DECIMAL(<span class="number">8</span>,<span class="number">2</span>)</span>,</span></span><br><span class="line"><span class="function">              OUT ph <span class="title">DECIMAL</span><span class="params">(<span class="number">8</span>,<span class="number">2</span>)</span>,</span></span><br><span class="line"><span class="function">              OUT pa <span class="title">DECIMAL</span><span class="params">(<span class="number">8</span>,<span class="number">2</span>)</span></span></span><br><span class="line"><span class="function">              )</span></span><br><span class="line"><span class="function">        BEGIN</span></span><br><span class="line"><span class="function">            SELECT <span class="title">Min</span><span class="params">(prod_price)</span></span></span><br><span class="line"><span class="function">            INTO p1</span></span><br><span class="line"><span class="function">            FROM products</span>;</span><br><span class="line">            <span class="function">SELECT <span class="title">Max</span><span class="params">(prod_price)</span></span></span><br><span class="line"><span class="function">            INTO ph</span></span><br><span class="line"><span class="function">            FROM products</span>;</span><br><span class="line">            <span class="function">SELECT <span class="title">Avg</span><span class="params">(prod_price)</span></span></span><br><span class="line"><span class="function">            INTO pa</span></span><br><span class="line"><span class="function">            FROM products</span>;</span><br><span class="line">            END;</span><br></pre></td></tr></table></figure><p>此存储过程接受3个参数： pl存储产品最低价格， ph存储产品最高价格， pa存储产品平均价格。每个参数必须具有指定的类型，这里使用十进制值。关键字OUT指出相应的参数用来从存储过程传出一个值（返回给调用者）。 MySQL支持IN（传递给存储过程）、 OUT（从存储过程传出，如这里所用）和INOUT（对存储过程传入和传出）类型的参数。存储过程的代码位于BEGIN和END语句内，如前所见，它们是一系列SELECT语句，用来检索值，然后保存到相应的变量（通过指定INTO关键字）。</p><p>​    为调用此修改过的存储过程，必须指定3个变量名  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">CALL <span class="title">productpricing</span><span class="params">(@pricelow,</span></span></span><br><span class="line"><span class="function"><span class="params">                    @pricehigh,</span></span></span><br><span class="line"><span class="function"><span class="params">                    @priceaverage)</span></span>;</span><br></pre></td></tr></table></figure><p>由于此存储过程要求3个参数，因此必须正好传递3个参数，不多也不少。所以，这条CALL语句给出3个参数。它们是存储过程将保存结果的3个变量的名字。<br><strong>变量名</strong> 所有MySQL变量都必须以@开始。  </p><p><img src="https://photos.alitaalice.cn/image/20200513094242.png" alt=""></p><p><img src="https://photos.alitaalice.cn/image/20200513094323.png" alt=""></p><p>另外一个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CREATE PROCEDURE ordertotal(</span><br><span class="line">IN onumeber INT,</span><br><span class="line">OUT ototal DECIMAL(8,2))</span><br><span class="line">BEGIN</span><br><span class="line">    SELECT Sum(item_price*quantity)</span><br><span class="line">    FROM orderitems</span><br><span class="line">    WHERE order_num&#x3D;onumber</span><br><span class="line">    INTO ototal;</span><br><span class="line">END;</span><br></pre></td></tr></table></figure><p>为调用新存储过程，可以使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CALL ordertotal(20005,@total);</span><br></pre></td></tr></table></figure><p><strong>必须给ordertotal传递两个参数；第一个参数为订单号，第二个参数为包含计算出来的合计的变量名。</strong>  </p><p>为了显示合计：</p><p>SELECT @total;</p><p><img src="https://photos.alitaalice.cn/image/20200513094845.png" alt=""></p><h2 id="建立智能存储过程"><a href="#建立智能存储过程" class="headerlink" title="建立智能存储过程"></a>建立智能存储过程</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">-- Name: ordertotal</span><br><span class="line">-- Parameters: onumber =order number</span><br><span class="line">--             taxable= <span class="number">0</span> <span class="keyword">if</span> not taxable,<span class="number">1</span> <span class="keyword">if</span> taxable</span><br><span class="line">--             ototal =order total variable</span><br><span class="line"></span><br><span class="line"><span class="function">CREATE PROCEDURE <span class="title">ordertotal</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        IN onumber INT,</span></span></span><br><span class="line"><span class="function"><span class="params">        IN taxable BOOLEAN,</span></span></span><br><span class="line"><span class="function"><span class="params">        OUT ototal DECIMAL(<span class="number">8</span>,<span class="number">2</span>)</span></span></span><br><span class="line"><span class="function">)COMMENT 'Obtain order total,optionally adding tax'</span></span><br><span class="line"><span class="function">BEGIN</span></span><br><span class="line"><span class="function">     --Declare variable <span class="keyword">for</span> total</span></span><br><span class="line"><span class="function">     DECLARE total <span class="title">DECIMAL</span><span class="params">(<span class="number">8</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line">     --Declare tax percentage</span><br><span class="line">     DECLARE taxrate INT DEFAULT <span class="number">6</span>;</span><br><span class="line">     </span><br><span class="line">     --Get the order total</span><br><span class="line">     <span class="function">SELECT <span class="title">Sum</span><span class="params">(item_price*quantity)</span></span></span><br><span class="line"><span class="function">     FROM orderitems</span></span><br><span class="line"><span class="function">     WHERE order_num </span>=onumber</span><br><span class="line">     INTO total;</span><br><span class="line">     </span><br><span class="line">     --is <span class="keyword">this</span> taxable?</span><br><span class="line">     IF taxable THEN</span><br><span class="line">        --Yes,so add taxrate to the total</span><br><span class="line">        SELECT total+(total/<span class="number">100</span>*taxrate) INTO total;</span><br><span class="line">     END IF;</span><br><span class="line">     --And <span class="keyword">finally</span>,save to out variable</span><br><span class="line">     SELECT total INTO ototal;</span><br><span class="line">END;</span><br></pre></td></tr></table></figure><p>为了试验它</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CALL ordertotal(20005,0,@total);</span><br><span class="line">SELECT @total;</span><br></pre></td></tr></table></figure><p>为显示用来创建一个存储过程的CREATE语句，使用SHOW CREATE<br>PROCEDURE语句：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW CREATE PROCEDURE ordertotal;</span><br></pre></td></tr></table></figure><p>为了获得包括何时、由谁创建等详细信息的存储过程列表， 使用SHOW<br>PROCEDURE STATUS。  </p><p>SHOW PROCEDURE STATUS列出所有存储过程。为限制其输出，可使用LIKE指定一个过滤模式，例如：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW PROCEDURE STATUS LIKE <span class="string">'ordertotal'</span>;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初级排序算法</title>
      <link href="/2020/05/12/%E5%88%9D%E7%BA%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
      <url>/2020/05/12/%E5%88%9D%E7%BA%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>本章介绍排序算法</p></blockquote><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>我们关注的主要对象是重新排列数组元素 的算法，其中每个元素都有一个主键 。排序算法的目标就是将所有元素的主键按照某种方式排列（通常是按照大小或是字母顺序）。排序后索引较大的主键大于等于索引较小的主键 . </p><h2 id="一-初级排序算法"><a href="#一-初级排序算法" class="headerlink" title="一.初级排序算法"></a>一.初级排序算法</h2><p>排序算法类的模板</p><p>排序算法类模版”中的 Example 类展示了我们的习惯约定：我们会将排序代码放在类的 sort() 方法中，该类还将包含辅助函数 less() 和 exch() （可能还有其他辅助函数）以及一个示例用例main() 。Example 类还包含了一些早期调试使用的代码：测试用例 main() 将标准输入得到的字符串排序，并用私有方法 show() 打印字符数组的内容。我们还会在本章中遇到各种用于比较不同算法并研究它们的性能的测试用例。为了区别不同的排序算法，我们为相应的类取了不同的名字，用例可以根据名字调用不同的实现，例如 Insertion.sort() 、Merge.sort() 、Quick.sort() 等。<br>大多数情况下，我们的排序代码只会通过两个方法操作数据：less() 方法对元素进行比较，exch()方法将元素交换位置。exch() 方法的实现很简单，通过 Comparable 接口实现 less() 方法也不困难。将数据操作限制在这两个方法中使得代码的可读性和可移植性更好，更容易验证代码的正确性、分析性能以及排序算法之间的比较。在学习具体的排序算法实现之前，我们先讨论几个对于所有排序算法都很<br>重要的问题。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">/* 请见算法2.1、算法2.2、算法2.3、算法2.4、算法2.5或算法2.7*/</span> &#125;<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">less</span><span class="params">(Comparable v, Comparable w)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> v.compareTo(w) &lt; <span class="number">0</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exch</span><span class="params">(Comparable[] a, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123; Comparable t = a[i]; a[i] = a[j]; a[j] = t; &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(Comparable[] a)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">// 在单行中打印数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++)</span><br><span class="line">StdOut.print(a[i] + <span class="string">" "</span>);</span><br><span class="line">StdOut.println();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSorted</span><span class="params">(Comparable[] a)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">// 测试数组元素是否有序</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; a.length; i++)</span><br><span class="line"><span class="keyword">if</span> (less(a[i], a[i-<span class="number">1</span>])) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">// 从标准输入读取字符串，将它们排序并输出</span></span><br><span class="line">String[] a = In.readStrings();</span><br><span class="line">sort(a);</span><br><span class="line"><span class="function"><span class="keyword">assert</span> <span class="title">isSorted</span><span class="params">(a)</span></span>;</span><br><span class="line">show(a);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-java中compareTo-用法详解"><a href="#1-java中compareTo-用法详解" class="headerlink" title="1.java中compareTo()用法详解"></a>1.java中compareTo()用法详解</h2><p>一、字符串比较用compareTo()时:</p><p>1，长度相同,从第一位开始比较，如果相同返回0，如果不同则马上返回这两个字符的ascii值的差值。</p><p>2，长度不同,直接返回长度差值。</p><p>二、Integer比较用compareTo()时：</p><p>1，对比数字时相同，返回0。</p><p>2，对比数字不同时，返回-1。</p><p><strong>对于 v&lt;w 、v=w 和 v&gt;w 三种情况，Java 的习惯是在 v.compareTo(w) 被调用时分别返回一个负整数、零和一个正整数（一般是 -1、0 和 1）</strong></p><p>我们接下来用 v&gt;w 来表示<br>v.compareTo(w)&gt;0  </p><h2 id="2-实现-Comparable-接口"><a href="#2-实现-Comparable-接口" class="headerlink" title="2.实现 Comparable 接口"></a>2.实现 Comparable 接口</h2><p><strong>我们的排序算法模板适用于任何实现了 Comparable 接口的数据类型。遵守 Java 惯例的好处是很多你希望排序的数据都实现了 Comparable 接口。例如，Java 中封装数字的类型 Integer 和 Double，以及 String 和其他许多高级数据类型（如 File 和 URL ）都实现了 Comparable 接口。因此你可以直接用这些类型的数组作为参数调用我们的排序方法。</strong>  </p><p>在创建自己的数据类型时，我们只要实现 Comparable 接口就能够保证用例代码可以将其排序。要做到这一点，只需要实现一个 compareTo() 方法来定义目标类型对象的自然次序  .</p><p><img src="https://photos.alitaalice.cn/image/20200513001323.png" alt=""></p><h2 id="二-选择排序"><a href="#二-选择排序" class="headerlink" title="二.选择排序"></a>二.选择排序</h2><p><strong>定义</strong>：一种最简单的排序算法是这样的：首先，找到数组中最小的那个元素，其次，将它和数组的第一个元素交换位置（如果第一个元素就是最小元素那么它就和自己交换）。再次，在剩下的元素中找到最小的元素，将它与数组的第二个元素交换位置。如此往复，直到将整个数组排序。这种方法叫做选择排序 ，因为它在不断地选择剩余元素之中的最小者。  </p><p><strong>选择排序代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Selection</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">// 将a[]按升序排列</span></span><br><span class="line"><span class="keyword">int</span> N = a.length; <span class="comment">// 数组长度</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">&#123; <span class="comment">// 将a[i]和a[i+1..N]中最小的元素交换</span></span><br><span class="line"><span class="keyword">int</span> min = i; <span class="comment">// 最小元素的索引</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; N; j++)</span><br><span class="line"><span class="keyword">if</span> (less(a[j], a[min])) min = j;</span><br><span class="line">exch(a, i, min);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// less()、exch()、isSorted()和main()方法见“排序算法类模板”</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>for循环i时，先找到最小a[0]的元素，再找到第二小的元素a[1]…一直进行下去</p><p>该算法将第 i 小的元素放到 a[i] 之中。数组的第 i 个位置的左边是 i 个最小的元素且它们不会再被访问。  </p><p><img src="https://photos.alitaalice.cn/image/20200513001448.png" alt=""></p><h1 id="三-插入排序"><a href="#三-插入排序" class="headerlink" title="三.插入排序"></a>三.插入排序</h1><p>在计算机的实现中，为了给要插入的元素腾出空间，我们需要将其余所有元素在插入之前都向右移动一位。这种算法叫做<strong>插入排序</strong>   </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Insertion</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">// 将a[]按升序排列</span></span><br><span class="line"><span class="keyword">int</span> N = a.length;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i++)</span><br><span class="line">&#123; <span class="comment">// 将 a[i] 插入到 a[i-1]、a[i-2]、a[i-3]...之中</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt; <span class="number">0</span> &amp;&amp; less(a[j], a[j-<span class="number">1</span>]); j--)</span><br><span class="line">exch(a, j, j-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// less()、exch()、isSorted()和main()方法见“排序算法类模板”</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://photos.alitaalice.cn/image/20200513001419.png" alt=""></p><p>插入排序原理很简单，讲一组数据分成两组，我分别将其称为有序组与待插入组。每次从待插入组中取出一个元素，与有序组的元素进行比较，并找到合适的位置，将该元素插到有序组当中。就这样，每次插入一个元素，有序组增加，待插入组减少。直到待插入组元素个数为0。当然，插入过程中涉及到了元素的移动。为了排序方便，我们一般将数据第一个元素视为有序组，其他均为待插入组。</p><p><img src="https://photos.alitaalice.cn/image/20200513001521.png" alt="">下面是几种典型的部分有序的数组：</p><ul><li><p>数组中每个元素距离它的最终位置都不远；</p></li><li><p>一个有序的大数组接一个小数组；</p></li><li><p>数组中只有几个元素的位置不正确。</p><p>插入排序对这样的数组很有效，而选择排序则不然。事实上，当倒置的数量很少时，插入排序很可能比本章中的其他任何算法都要快。  </p></li></ul><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Shell</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">// 将a[]按升序排列</span></span><br><span class="line"><span class="keyword">int</span> N = a.length;</span><br><span class="line"><span class="keyword">int</span> h = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (h &lt; N/<span class="number">3</span>) h = <span class="number">3</span>*h + <span class="number">1</span>; <span class="comment">// 1, 4, 13, 40, 121, 364, 1093, ...</span></span><br><span class="line"><span class="keyword">while</span> (h &gt;= <span class="number">1</span>)</span><br><span class="line">&#123; <span class="comment">// 将数组变为h有序</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h; i &lt; N; i++)</span><br><span class="line">&#123; <span class="comment">// 将a[i]插入到a[i-h], a[i-2*h], a[i-3*h]... 之中</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt;= h &amp;&amp; less(a[j], a[j-h]); j -= h)</span><br><span class="line">exch(a, j, j-h);</span><br><span class="line">&#125;</span><br><span class="line">h = h/<span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// less()、exch()、isSorted()和main()方法见“排序算法类模板”</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://photos.alitaalice.cn/image/20200513154601.png" alt=""></p><p>算法 shell 的实现使用了序列 ，从N/3 开始递减至 1。我们把这个序列称为递增序列 。  实现希尔排序的一种方法是对于每个 h，用插入排序将 h 个子数组独立地排序。但因为子数组是相互独立的，一个更简单的方法是在 h- 子数组中将每个元素交换到比它大的元素之前去（将比它大的元素向右移动一格）。只需要在插入排序的代码中将移动元素的距离由 1 改为 h 即可。这样，希尔排序的实现就转化为了一个类似于插入排序但使用不同增量的过程。  </p><p><img src="https://photos.alitaalice.cn/image/20200513154809.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DataStructure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA泛型</title>
      <link href="/2020/05/12/JAVA%E6%B3%9B%E5%9E%8B/"/>
      <url>/2020/05/12/JAVA%E6%B3%9B%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>本章介绍 <a href="http://lib.csdn.net/base/java">Java</a>中的泛型</p></blockquote><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>\1. <a href="http://lib.csdn.net/base/java">Java</a>中的泛型是什么 ? 使用泛型的好处是什么?</p><p>这是在各种Java泛型<a href="http://yjbys.com/mianshi/">面试</a>中，一开场你就会被问到的问题中的一个，主要集中在初级和中级面试中。那些拥有Java1.4或更早版本的开发背景的人 都知道，在集合中存储对象并在使用前进行类型转换是多么的不方便。泛型防止了那种情况的发生。它提供了编译期的类型安全，确保你只能把正确类型的对象放入 集合中，避免了在运行时出现ClassCastException。</p><p>\2. Java的泛型是如何工作的 ? 什么是类型擦除 ?</p><p>这是一道更好的泛型面试题。泛型是通过类型擦除来实现的，编译器在编译时擦除了所有类型相关的信息，所以在运行时不存在任何类型相关的信息。例如 List<String>在运行时仅用一个List来表示。这样做的目的，是确保能和<a href="http://lib.csdn.net/base/java">Java </a>5之前的版本开发二进制类库进行兼容。你无法在运行时访问到类型参数，因为编译器已经把泛型类型转换成了原始类型。根据你对这个泛型问题的回答情况，你会 得到一些后续提问，比如为什么泛型是由类型擦除来实现的或者给你展示一些会导致编译器出错的错误泛型代码。请阅读我的Java中泛型是如何工作的来了解更 多信息。</p><p>\3. 什么是泛型中的限定通配符和非限定通配符 ?</p><p>这是另一个非常流行的Java泛型面试题。限定通配符对类型进行了限制。有两种限定通配符，一种是<? extends T>它通过确保类型必须是T的子类来设定类型的上界，另一种是<? super T>它通过确保类型必须是T的父类来设定类型的下界。泛型类型必须用限定内的类型来进行初始化，否则会导致编译错误。另一方面<?>表 示了非限定通配符，因为&lt;?&gt;可以用任意类型来替代。更多信息请参阅我的文章泛型中限定通配符和非限定通配符之间的区别。</p><p>\4. List&lt;? extends T&gt;和List &lt;? super T&gt;之间有什么区别 ?</p><p>这和上一个面试题有联系，有时面试官会用这个问题来评估你对泛型的理解，而不是直接问你什么是限定通配符和非限定通配符。这两个List的声明都是 限定通配符的例子，List&lt;? extends T&gt;可以接受任何继承自T的类型的List，而List&lt;? super T&gt;可以接受任何T的父类构成的List。例如List&lt;? extends Number&gt;可以接受List<Integer>或List<Float>。在本段出现的连接中可以找到更多信息。</p><p>\5. 如何编写一个泛型方法，让它能接受泛型参数并返回泛型类型?</p><p>编写泛型方法并不困难，你需要用泛型类型来替代原始类型，比如使用T, E or K,V等被广泛认可的类型占位符。泛型方法的例子请参阅Java集合类框架。最简单的情况下，一个泛型方法可能会像这样:</p><p>public V put(K key, V value) {</p><p>return cache.put(key, value);</p><p>}</p><p>\6. Java中如何使用泛型编写带有参数的类?</p><p>这是上一道面试题的延伸。面试官可能会要求你用泛型编写一个类型安全的类，而不是编写一个泛型方法。关键仍然是使用泛型类型来代替原始类型，而且要使用JDK中采用的标准占位符。</p><p>\7. 编写一段泛型程序来实现LRU缓存?</p><p>对于喜欢Java编程的人来说这相当于是一次练习。给你个提示，LinkedHashMap可以用来实现固定大小的LRU缓存，当LRU缓存已经满 了的时候，它会把最老的键值对移出缓存。LinkedHashMap提供了一个称为removeEldestEntry()的方法，该方法会被put() 和putAll()调用来删除最老的键值对。当然，如果你已经编写了一个可运行的JUnit<a href="http://lib.csdn.net/base/softwaretest">测试</a>，你也可以随意编写你自己的实现代码。</p><p>\8. 你可以把List<String>传递给一个接受List<Object>参数的方法吗？</p><p>对任何一个不太熟悉泛型的人来说，这个Java泛型题目看起来令人疑惑，因为乍看起来String是一种Object，所以 List<String>应当可以用在需要List<Object>的地方，但是事实并非如此。真这样做的话会导致编译错误。如 果你再深一步考虑，你会发现Java这样做是有意义的，因为List<Object>可以存储任何类型的对象包括String, Integer等等，而List<String>却只能用来存储Strings。</p><p>List<Object> objectList;</p><p>List<String> stringList;</p><p>objectList = stringList; //compilation error incompatible types</p><p>\9. Array中可以用泛型吗?</p><p>这可能是Java泛型面试题中最简单的一个了，当然前提是你要知道Array事实上并不支持泛型，这也是为什么Joshua Bloch在Effective Java一书中建议使用List来代替Array，因为List可以提供编译期的类型安全保证，而Array却不能。</p><p>\10. 如何阻止Java中的类型未检查的警告?</p><p>如果你把泛型和原始类型混合起来使用，例如下列代码，<a href="http://lib.csdn.net/base/java">java </a>5的javac编译器会产生类型未检查的警告，例如</p><p>List<String> rawList = new ArrayList()</p><p>注意: Hello.java使用了未检查或称为不安全的操作;</p><p>这种警告可以使用@SuppressWarnings(“unchecked”)注解来屏蔽。</p><p>Java泛型面试题补充更新:</p><p>我手头又拿到了几个Java泛型面试题跟大家分享下，这几道题集中在泛型类型和原始类型的区别上，以及我们是否可以用Object来代替限定通配符的使用等等：</p><p>Java中List<Object>和原始类型List之间的区别?</p><p>原始类型和带参数类型<Object>之间的主要区别是，在编译时编译器不会对原始类型进行类型安全检查，却会对带参数的类型进行检 查，通过使用Object作为类型，可以告知编译器该方法可以接受任何类型的对象，比如String或Integer。这道题的考察点在于对泛型中原始类 型的正确理解。它们之间的第二点区别是，你可以把任何带参数的类型传递给原始类型List，但却不能把List<String>传递给接受 List<Object>的方法，因为会产生编译错误。更多详细信息请参阅Java中的泛型是如何工作的。</p><p>Java中List&lt;?&gt;和List<Object>之间的区别是什么?</p><p>这道题跟上一道题看起来很像，实质上却完全不同。List<?> 是一个未知类型的List，而List<Object> 其实是任意类型的List。你可以把List<String>, List<Integer>赋值给List<?>，却不能把List<String>赋值给 List<Object>。   </p><p>List&lt;?&gt; listOfAnyType;</p><p>List<Object> listOfObject = new ArrayList<Object>();</p><p>List<String> listOfString = new ArrayList<String>();</p><p>List<Integer> listOfInteger = new ArrayList<Integer>();</p><p>listOfAnyType = listOfString; //legal</p><p>listOfAnyType = listOfInteger; //legal</p><p>listOfObjectType = (List<Object>) listOfString; //compiler error – in-convertible types</p><p>想了解更多关于通配符的信息请查看Java中的泛型通配符示例</p><p>List<String>和原始类型List之间的区别.</p><p>该题类似于“原始类型和带参数类型之间有什么区别”。带参数类型是类型安全的，而且其类型安全是由编译器保证的，但原始类型List却不是类型安全 的。你不能把String之外的任何其它类型的Object存入String类型的List中，而你可以把任何类型的对象存入原始List中。使用泛型的 带参数类型你不需要进行类型转换，但是对于原始类型，你则需要进行显式的类型转换。</p><p>List listOfRawTypes = new ArrayList();</p><p>listOfRawTypes.add(“abc”);</p><p>listOfRawTypes.add(123); //编译器允许这样 – 运行时却会出现异常</p><p>String item = (String) listOfRawTypes.get(0); //需要显式的类型转换</p><p>item = (String) listOfRawTypes.get(1); //抛ClassCastException，因为Integer不能被转换为String</p><p>List<String> listOfString = new ArrayList();</p><p>listOfString.add(“abcd”);</p><p>listOfString.add(1234); //编译错误，比在运行时抛异常要好</p><p>item = listOfString.get(0); //不需要显式的类型转换 – 编译器自动转换</p><p>这些都是Java泛型面试中 频繁出现的问题及其答案。所有这些面试题都不困难，其实它们都是基于泛型的基础知识。任何对泛型有不错了解的Java程序员都肯定熟知这些泛型题目。如果 你有任何好的面试题，不管是在什么面试中碰到的，或者如果你想知道任何Java泛型面试题的答案。</p>]]></content>
      
      
      <categories>
          
          <category> JAVASE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVASE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA面试</title>
      <link href="/2020/05/11/JAVA%E9%9D%A2%E8%AF%95/"/>
      <url>/2020/05/11/JAVA%E9%9D%A2%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>本章介绍</p></blockquote><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p><img src="E:%5Cdev%5CMYBLOG%5Cblog%5Csource_posts%5CJAVA%E9%9D%A2%E8%AF%95%5C2020-05-11_205422.png" alt=""></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JAVA编译和运行的过程</title>
      <link href="/2020/05/11/JAVA%E7%BC%96%E8%AF%91%E5%92%8C%E8%BF%90%E8%A1%8C%E7%9A%84%E8%BF%87%E7%A8%8B/"/>
      <url>/2020/05/11/JAVA%E7%BC%96%E8%AF%91%E5%92%8C%E8%BF%90%E8%A1%8C%E7%9A%84%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>本章介绍JAVA编译和运行的过程</p></blockquote><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><ul><li><p>JAVA程序源码 </p></li><li><p>——-&gt; JAVA字节码（经过编译器编译)</p></li><li><p>——-&gt;JVM （对字节码进行解释和运行）</p><p>编译只进行一次，但是解释在每次运行程序时都会运行，编译的字节码采用一种针对JVM优化过度机器码的形式进行保存</p></li><li><p>——&gt;机器码（虚拟机将字节码解释为机器码，在计算机上运行）</p><p><img src="Screenshot.png" alt=""></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVASE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA注解</title>
      <link href="/2020/05/11/JAVA%E6%B3%A8%E8%A7%A3/"/>
      <url>/2020/05/11/JAVA%E6%B3%A8%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>本章介绍 JAVA注解</p></blockquote><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h2 id="1-注解的概述"><a href="#1-注解的概述" class="headerlink" title="1.注解的概述"></a>1.注解的概述</h2><p>注解的语法： @注解名称</p><p>注解的作用:  替代xml配置文件</p><p>我们以前总是要写一些配置文件，如web.xml 里面要写<servlet> 和<sevlet-mapping></p><p>tomcat用来读取配置文件</p><p>而在servlet3.0中可以使用注解来代替配置文件，@WebServlet 用来代替该配置文件</p><h2 id="2-JAVA中的注解"><a href="#2-JAVA中的注解" class="headerlink" title="2. JAVA中的注解"></a>2. JAVA中的注解</h2><ul><li>@Override</li><li>@Deprecated: 作用在方法上，标记该方法为作废方法 （已经过时的方法）</li><li>@SuppressWarning :作用在方法上，压制警告@SuppressWarnings(“all”)压制所有警告</li></ul><h2 id="3-注解的使用"><a href="#3-注解的使用" class="headerlink" title="3. 注解的使用"></a>3. 注解的使用</h2><ul><li>定义注解类：框架的工作</li><li>使用注解类：我们的工作</li><li>读取注解（反射）：框架的工作</li></ul><h2 id="4-自定义注解类"><a href="#4-自定义注解类" class="headerlink" title="4.自定义注解类"></a>4.自定义注解类</h2><p><strong>@interface</strong></p><p>eg:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnn&#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="5-使用注解的目标"><a href="#5-使用注解的目标" class="headerlink" title="5.使用注解的目标"></a>5.使用注解的目标</h2><p>注解可以使用在类（接口或者枚举），属性，方法，构造器，包，参数，局部变量</p><p>eg:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MyAnn</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="meta">@MyAnn</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> a;</span><br><span class="line"><span class="meta">@MyAnn</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyClass</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;&#125;</span><br><span class="line"><span class="meta">@MyAnn</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;&#125;</span><br><span class="line"><span class="meta">@MyAnn</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun2</span><span class="params">(@MyAnn String s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="meta">@MyAnn</span></span><br><span class="line">    <span class="keyword">int</span> n=<span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-注解的属性"><a href="#6-注解的属性" class="headerlink" title="6.注解的属性"></a>6.注解的属性</h2><p>定义注解时，也可以给出属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnn</span><br><span class="line">&#123;</span><br><span class="line"><span class="function">String <span class="title">value</span><span class="params">()</span></span>;  <span class="keyword">default</span> <span class="string">"hello world"</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">value1</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中value就是属性，你可能会说value是一个方法，没错，它是一个方法，但是我们非要称之为属性，是因为把它当作属性更好理解:</p><p>eg:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MyAnn</span>(value1=<span class="number">100</span>,value=<span class="string">"hello"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></span><br><span class="line"><span class="class"></span>&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>注解的属性后面要有一对圆括号，而且圆括号内不能给出东西。就像是无参的方法一样；<br>注解的属性类型只能是：基本类型、String、Enum、Class、注解类型、以上类型的一维数组类型；<br>注解的属性可以有默认值，例如：int a() default 100;<br>数组的属性默认值：int[] arr() default {1,2,3}，这里不能使用new int[]{1,2,3}<br>使用注解时，在给数组属性赋值时的格式：@MyAnn(arr={1,2,3})；</li></ul><h2 id="7-元注解"><a href="#7-元注解" class="headerlink" title="7.元注解"></a>7.元注解</h2><p><strong>元注解：用于描述注解的注解</strong></p><p>@Target ：描述注解作用的位置</p><ul><li>ElementType取值：</li><li>TYPE：作用在类上</li><li>METHOD ：作用在方法上</li><li>FIELD ：作用在成员变量上</li></ul><p>eg：</p><p>Target 注解的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Target &#123;  </span><br><span class="line">    ElementType[] value();  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> ElementType &#123;  </span><br><span class="line">  TYPE,FIELD,METHOD,PARAMETED,CONSTRUCTOR,LOCAL_VARIABLE,ANNOCATION_TYPE,PACKAGE  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在定义注解时，可以使用@Target 注解来限制注解的作用目标</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE,ElementType.METHOD&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnn</span><br><span class="line">&#123;&#125;  <span class="comment">/* 该注解定义在类和方法上 */</span></span><br><span class="line"><span class="meta">@MyAnn</span>()  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;  </span><br><span class="line">    <span class="meta">@MyAnn</span>()  <span class="comment">//报错  </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a;  </span><br><span class="line">      </span><br><span class="line">    <span class="meta">@MyAnn</span>()  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123;&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-注解的保留策略"><a href="#8-注解的保留策略" class="headerlink" title="8.注解的保留策略"></a>8.注解的保留策略</h2><ul><li><p>注解的保留策略是指</p><ul><li>注解保留在源代码（SOURCE)上</li><li>注解保留在class文件上（CLASS）</li><li>注解保留在类运行时（RUNTIME），可以被类加载器加载到内存中</li></ul></li><li><p>如果希望注解被反射，那么注解就是保留到运行时，而不是源代码或者类文件上</p></li><li><p>指定注解的保留策略需要使用元注解@Retention ，它有一个value属性，类型为RetentionPolicy</p><p>RetentionPolicy是枚举类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Retention &#123;  </span><br><span class="line">    <span class="function">RetentionPolicy <span class="title">value</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> RetentionPolicy &#123;  </span><br><span class="line">    SOURCE, CLASS, RUNTIME  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>eg：指定注解保留到运行时</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetionOPlicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE,ElementType.METHOD&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnn</span><br><span class="line">&#123;</span><br><span class="line"><span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> "hello"</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">value1</span><span class="params">()</span> <span class="keyword">default</span> 100</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="9-注解处理器"><a href="#9-注解处理器" class="headerlink" title="9.注解处理器"></a>9.注解处理器</h2>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVASE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDK中常用的包有哪些？</title>
      <link href="/2020/05/11/JDK%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E5%8C%85%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F/"/>
      <url>/2020/05/11/JDK%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E5%8C%85%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>本章介绍JDK中常用的包</p></blockquote><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>JDK中常用的包有哪些？</p><ul><li>JAVA.lang  java语言的核心类，如String,Math,Interger,System,和Thread</li><li>java.io 提供多种输入/输出功能的类</li><li>java.net 包括执行与网络相关的操作的类</li><li>java.util 包括一些实用的工具类，如定义系统的特性，与日期日历相关的方法</li><li>java.awt 抽象窗口工具集，用来构建和管理应用程序的GUI</li><li>java.applet 包含applet运行所需的类</li><li>java.swing 用来建立图形用户界面</li></ul>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVASE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA和C++的区别</title>
      <link href="/2020/05/11/JAVA%E5%92%8CC++%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2020/05/11/JAVA%E5%92%8CC++%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>本章介绍JAVA和C++的区别</p></blockquote><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h2 id="JAVA和C-的区别"><a href="#JAVA和C-的区别" class="headerlink" title="JAVA和C++的区别"></a>JAVA和C++的区别</h2><ul><li>都是面向对象的语言，并且都支持封装，继承和多态</li><li>指针：JAVA不提供指针来直接访问内存，程序更加安全。</li><li>继承：JAVA中的类是单继承的，但是C++允许多继承，JAVA中允许一个类实现多个接口来实现C++中的多冲继承。</li><li>内存：JAVA有自动内存管理机制，不需要程序员手动释放无用内存。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVASE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java值传递和引用传递基础分析</title>
      <link href="/2020/05/11/Java%E5%80%BC%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92%E5%9F%BA%E7%A1%80%E5%88%86%E6%9E%90/"/>
      <url>/2020/05/11/Java%E5%80%BC%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92%E5%9F%BA%E7%A1%80%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>本章介绍JAVA的值传递和引用传递</p></blockquote><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h2 id="java内的基础类型数据传递都是值传递-java中实例对象的传递是引用传递。"><a href="#java内的基础类型数据传递都是值传递-java中实例对象的传递是引用传递。" class="headerlink" title="java内的基础类型数据传递都是值传递. java中实例对象的传递是引用传递。"></a>java内的基础类型数据传递都是值传递. java中实例对象的传递是引用传递。</h2><p><strong>值传递是对基本型变量而言的,传递的是该变量的一个副本,改变副本不影响原变量。引用传递一般是对于对象型变量而言的,传递的是该对象地址的一个副本, 并不是原对象本身 。</strong></p><p>首先，不要纠结于 Pass By Value 和 Pass By Reference 的字面上的意义，否则很容易陷入所谓的“一切传引用其实本质上是传值”这种并不能解决问题无意义论战中。<br>更何况，要想知道Java到底是传值还是传引用，起码你要先知道传值和传引用的准确含义吧？可是如果你已经知道了这两个名字的准确含义，那么你自己就能判断Java到底是传值还是传引用。</p><h2 id="一：搞清楚-基本类型-和-引用类型的不同之处"><a href="#一：搞清楚-基本类型-和-引用类型的不同之处" class="headerlink" title="一：搞清楚 基本类型 和 引用类型的不同之处"></a>一：搞清楚 基本类型 和 引用类型的不同之处</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line">String str = <span class="string">"hello"</span>;</span><br></pre></td></tr></table></figure><p><img src="2020-05-12_112353.png" alt=""></p><p>如图所示，num是基本类型，值就直接保存在变量中。而str是引用类型，变量中保存的只是实际对象的地址。一般称这种变量为”引用”，引用指向实际对象，实际对象中保存着内容。</p><p>二：搞清楚赋值运算符（=）的作用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">num &#x3D; 20;</span><br><span class="line">str &#x3D; &quot;java&quot;;</span><br></pre></td></tr></table></figure><p>对于基本类型 num ，赋值运算符会直接改变变量的值，原来的值被覆盖掉。<br>对于引用类型 str，赋值运算符会改变引用中所保存的地址，原来的地址被覆盖掉。但是原来的对象不会被改变（重要）。<br>如上图所示，”hello” 字符串对象没有被改变。（没有被任何引用所指向的对象是垃圾，会被垃圾回收器回收）</p><p><img src="2020-05-12_112409.png" alt=""></p><h2 id="三：调用方法时发生了什么？参数传递基本上就是赋值操作"><a href="#三：调用方法时发生了什么？参数传递基本上就是赋值操作" class="headerlink" title="三：调用方法时发生了什么？参数传递基本上就是赋值操作"></a>三：调用方法时发生了什么？参数传递基本上就是赋值操作</h2><p>第一个例子：基本类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    value = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">foo(num); <span class="comment">// num 没有被改变</span></span><br></pre></td></tr></table></figure><p>第二个例子：没有提供改变自身方法的引用类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(String text)</span> </span>&#123;</span><br><span class="line">    text = <span class="string">"windows"</span>;  <span class="comment">//String没改变是因为赋值新的字符串直接导致新new了一个String</span></span><br><span class="line">&#125;</span><br><span class="line">foo(str); <span class="comment">// str 也没有被改变</span></span><br></pre></td></tr></table></figure><p>第三个例子：提供改变自身方法的引用类型</p><p>builder的引用对象也是StringBuilder</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="string">"iphone"</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(StringBuilder builder)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    builder.append(<span class="string">"4"</span>); <span class="comment">//没有生成新的stringBuilder对象</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">foo(sb); <span class="comment">// sb 被改变了，变成了"iphone4"。</span></span><br></pre></td></tr></table></figure><p>第四个例子：提供了改变自身方法的引用类型，但是不使用，而是使用赋值运算符。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="string">"iphone"</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(StringBuilder builder)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    builder = <span class="keyword">new</span> StringBuilder(<span class="string">"ipad"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(sb); <span class="comment">// sb 没有被改变，还是 "iphone"。</span></span><br></pre></td></tr></table></figure><p>重点理解为什么，第三个例子和第四个例子结果不同？</p><p>下面是第三个例子的图解：</p><p><img src="2020-05-12_112424.png" alt=""></p><p>builder = new StringBuilder(“ipad”); 之后</p><p><img src="2020-05-12_112435.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVASE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>抽象类和接口的区别详解</title>
      <link href="/2020/05/11/%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8C%BA%E5%88%AB%E8%AF%A6%E8%A7%A3/"/>
      <url>/2020/05/11/%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8C%BA%E5%88%AB%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>本章介绍抽象类和接口</p></blockquote><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>它不能被实例化，只能被用作 子类的超类。抽象类是被用来创建继承层级里子类的模板。</p><p>以JDK中的GenericServlet为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericServlet</span> <span class="keyword">implements</span> <span class="title">Servlet</span>, <span class="title">ServletConfig</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// abstract method</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest req, ServletResponse res)</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Its implementation</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// other method related to Servlet</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当HttpServlet类继承GenericServlet时，它提供了<strong>service</strong>方法的实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpServlet</span> <span class="keyword">extends</span> <span class="title">GenericServlet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest req, ServletResponse res)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// implementation</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Implementation</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Implementation</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// some other methods related to HttpServlet</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>接口是抽象方法的集合，如果一个类实现了某个接口，那么它就继承了这个接口的抽象方法，这就像契约的模式，如果实现了这个接口，那么就必须确保使用了这些方法，接口只是一种形式，它本身不能实现任何方法，以Externalizable接口为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Externalizable</span> <span class="keyword">extends</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">writeExternal</span><span class="params">(ObjectOutput out)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">readExternal</span><span class="params">(ObjectInput in)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当你继承这个接口时，你就必须实现上面的俩个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Externalizable</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> employeeId;</span><br><span class="line">    String employeeName;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readExternal</span><span class="params">(ObjectInput in)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        employeeId = in.readInt();</span><br><span class="line">        employeeName = (String) in.readObject();</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeExternal</span><span class="params">(ObjectOutput out)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"> </span><br><span class="line">        out.writeInt(employeeId);</span><br><span class="line">        out.writeObject(employeeName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="什么时候使用抽象类和接口？"><a href="#什么时候使用抽象类和接口？" class="headerlink" title="什么时候使用抽象类和接口？"></a>什么时候使用抽象类和接口？</h2><ul><li>如果你拥有一些方法，并且想让它们中的一些有默认实现，那么使用抽象类吧</li><li>如果你想实现多重继承，那么请使用接口，抽象类不允许多重继承</li><li>如果基本功能在不断的进行改变，那么你就需要使用抽象类。如果不断改变基本功能，并且使用接口，那么就需要改变所有实现了该接口的类。</li></ul><h2 id="JAVA8中的默认方法和静态方法"><a href="#JAVA8中的默认方法和静态方法" class="headerlink" title="JAVA8中的默认方法和静态方法"></a>JAVA8中的默认方法和静态方法</h2><p>Oracle已经开始尝试向接口中引入默认方法和静态方法，依次来减少抽象类和接口之间的差异。</p><p>现在我们可以为接口提供默认实现的方法并且不用强制子类来实现它。default方法。</p><h2 id="抽象类和接口的异同"><a href="#抽象类和接口的异同" class="headerlink" title="抽象类和接口的异同"></a>抽象类和接口的异同</h2><p>接口和抽象类都是继承树的上层，他们的共同点如下：</p><p>1)    都是上层的抽象层。<br>2)    都不能被实例化<br>3)    都能包含抽象的方法，这些抽象的方法用于描述类具备的功能，但是不比提供具体的实现。<br>他们的区别如下：</p><p>1)    在抽象类中可以写非抽象的方法，从而避免在子类中重复书写他们，这样可以提高代码的复用性，这是抽象类的优势；接口中只能有抽象的方法。<br>2)    一个类只能继承一个直接父类，这个父类可以是具体的类也可是抽象类；但是一个类可以实现多个接口。</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVASE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树的遍历</title>
      <link href="/2020/05/11/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/"/>
      <url>/2020/05/11/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>本章介绍二叉树的遍历</p></blockquote><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h2 id="前序遍历算法"><a href="#前序遍历算法" class="headerlink" title="前序遍历算法"></a>前序遍历算法</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrderTraverse</span><span class="params">(BiTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(T==<span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%c"</span>,T-&gt;data);</span><br><span class="line">    PreOrderTraverse(T-&gt;lchild);</span><br><span class="line">    PreOrderTraverse(T-&gt;rchild);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>递归调用PreOrderTaverse()函数</p><h2 id="中序遍历算法"><a href="#中序遍历算法" class="headerlink" title="中序遍历算法"></a>中序遍历算法</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrderTraverse</span><span class="params">(BiTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(T=<span class="literal">NULL</span>)</span><br><span class="line">  <span class="keyword">return</span> ;</span><br><span class="line">  InOrderTraverse(T-&gt;lchild);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%c"</span>,T-&gt;data);</span><br><span class="line">  InOrderTraverse(T-rchild);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>递归调用InOrderTraverse()</p><h2 id="后序遍历算法"><a href="#后序遍历算法" class="headerlink" title="后序遍历算法"></a>后序遍历算法</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrderTraverse</span><span class="params">(BiTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(T==<span class="literal">NULL</span>)</span><br><span class="line">  <span class="keyword">return</span> ;</span><br><span class="line">  PostOrderTraverse(T-&gt;lchild);</span><br><span class="line">  PostOrderTraverse(T-&gt;rchild);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%c"</span>,T-&gt;data);</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring起步</title>
      <link href="/2020/05/10/Spring%E8%B5%B7%E6%AD%A5/"/>
      <url>/2020/05/10/Spring%E8%B5%B7%E6%AD%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>本章介绍什么是Spring</p></blockquote><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h2 id="什么是Spring"><a href="#什么是Spring" class="headerlink" title="什么是Spring"></a>什么是Spring</h2><ul><li><p>Spring 的核心是提供一个容器(container) </p><p>通常称为Spring 应用上下文（Spring application context) 应用前后关系，它们会创建和管理应用组件。</p><p>这些组件也被称为是bean ，会在Spring应用上下文中装配在一起，从而形成一个完整的应用程序。</p><p>这就像砖块，砂浆，木材 ，管道等组合在一起</p></li></ul><ul><li><p>将bean装配在一起是通过一种基于依赖注入（dependency injection DI)</p><p>举例来说：假设在众多的组件中，有俩个是我们需要处理的：库存服务，和商品服务。</p><p>商品服务需要依赖于库存服务。</p><p>如图所示阐述了bean和Spring 应用上下文之间的关系。</p><p><img src="TIM%E5%9B%BE%E7%89%8720200510124205.png" alt=""></p><p>依赖注入到需要它们的bean中，另外使用依赖注入的应用依赖于单独的实体（容器）来创建和维护所有的组件。</p><p> Spring Initializr 是一个基于浏览器的web应用，能够生成Spring 项目结构的骨架。</p></li></ul><h3 id="pom文件"><a href="#pom文件" class="headerlink" title="pom文件"></a>pom文件</h3><h2 id="Springboot的引导类"><a href="#Springboot的引导类" class="headerlink" title="Springboot的引导类"></a>Springboot的引导类</h2><p>@SpringBootApplication  ：是一个组合注解，包括：</p><ul><li>@SpringBootConfiguration</li></ul><p>将该类声明为配置类</p><ul><li>@EnableAutoConfiguration</li></ul><p>启动Spring BOOT 的自动配置 </p><ul><li>@ComponentScan </li></ul><p>启动组件扫描</p><p>@Component @Controller @Service 注解声明其他类，Spring会自动发现它们并将它们注册为Spring应用上下文的组件。</p>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql视图</title>
      <link href="/2020/05/09/mysql%E8%A7%86%E5%9B%BE/"/>
      <url>/2020/05/09/mysql%E8%A7%86%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>本章介绍视图究竟是什么，它们怎么样工作，何时使用它们。</p></blockquote><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>视图是 虚拟的表，与包含数据的表不一样，视图只包含使用时动态检索数据的查询。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT cust_name ,cust_contact FROM customers ,orders ,orderitems WHERE customers.cust_id&#x3D;orders.cust_id  AND orderitems.order_num &#x3D;orders.order_num</span><br><span class="line">AND prod_id &#x3D;&#39;TNT2&#39;;</span><br></pre></td></tr></table></figure><p>假设把整个查询包装成一个名叫productcustomers的虚拟表，则</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT cust_name,cust_contact FROM productcustomers WHERE prod_id&#x3D;&#39;TNT2&#39;;</span><br></pre></td></tr></table></figure><h3 id="为什么使用视图"><a href="#为什么使用视图" class="headerlink" title="为什么使用视图"></a>为什么使用视图</h3><ul><li>重用SQL 语句</li><li>简化复杂的SQL语句，在编写查询后，可以方便地重用它而不必知道它的基本查询细节。</li><li>使用表的组成部分而不是整个表</li><li>保护数据，可以给用户授予表的特定部分的访问权限，而不是整个表的访问权限。</li><li>更改数据格式和表示。</li></ul><h3 id="视图的规则和限制"><a href="#视图的规则和限制" class="headerlink" title="视图的规则和限制"></a>视图的规则和限制</h3><ul><li>视图必须唯一命名</li><li>对于创建的视图数目没有限制</li><li>视图可以嵌套</li><li>视图不能索引，不能有关联的触发器或者默认值</li></ul><h3 id="使用视图"><a href="#使用视图" class="headerlink" title="使用视图"></a>使用视图</h3><ul><li>视图用CREATE VIEW 来创建 </li><li>使用SHOW CREATE VIEW viewname; 来查看创建视图的语句</li><li>用DROP 来删除视图。语法为DROP VIEW viewname;</li><li>更新视图时，可以 先用DROP 再用CREATE  也可以直接使用CREATE OR REPLACE VIEW</li><li>可以先用DROP 再用 CREATE  也可以直接用CREATE OR REPLACE VIEW</li></ul><h3 id="利用视图简化复杂的联结"><a href="#利用视图简化复杂的联结" class="headerlink" title="利用视图简化复杂的联结"></a>利用视图简化复杂的联结</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CREATE VIEW productcustomers AS SELECT cust_name,cust_contact,prod_id</span><br><span class="line">FROM customers,orders,orderitems WHERE customers.cust_id=orders.cust_id</span><br><span class="line">AND orderitems.order_num =orders.order_name;</span><br></pre></td></tr></table></figure><p>那么为了检索订购产品的TNT2客户</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT cust_name,cust_contact FROM productcustomers WHERE prod_id ='TNT2';</span><br></pre></td></tr></table></figure><h3 id="使用视图重新格式化检索出的数据"><a href="#使用视图重新格式化检索出的数据" class="headerlink" title="使用视图重新格式化检索出的数据"></a>使用视图重新格式化检索出的数据</h3><p>下面的SELECT  语句在单个组合计算列中返回供应商名和位置</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SELECT <span class="title">Concat</span><span class="params">(RTrim(vend_name),<span class="string">'('</span>,RTrim(vend_country),<span class="string">')'</span>)</span> AS vend_title</span></span><br><span class="line"><span class="function">FROM vendors</span></span><br><span class="line"><span class="function">ORDER BY vend_name</span>;</span><br><span class="line"><span class="comment">/*out </span></span><br><span class="line"><span class="comment">    vend_title</span></span><br><span class="line"><span class="comment">    ACME  (USA)</span></span><br><span class="line"><span class="comment">    Jet Set (England)</span></span><br><span class="line"><span class="comment">    LT Supplies (USA)</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>现在，假如经常需要这个格式的结果，不必在每次需要时执行联结，创建一个视图</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">CREATE VIEW vendorlocations AS SELECT <span class="title">Concat</span><span class="params">(RTrim(vend_name),<span class="string">'('</span>,RTrim(vend_country),<span class="string">')'</span>)</span> AS vend_title</span></span><br><span class="line"><span class="function">FROM vendors</span></span><br><span class="line"><span class="function">ORDER BY vend_name</span>;</span><br></pre></td></tr></table></figure><p>now </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM vendorlocations;</span><br></pre></td></tr></table></figure><h3 id="使用视图过滤不想要的数据"><a href="#使用视图过滤不想要的数据" class="headerlink" title="使用视图过滤不想要的数据"></a>使用视图过滤不想要的数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE VIEW customeremaillist AS SELECT cust_id,cust_name,cust_email FROM customers WHERE cust_email IS NOT NULL;</span><br></pre></td></tr></table></figure><p>在发送电子邮件到邮件列表时，需要排除没有电子邮件地址的用户</p><p>现在，可以像使用其他表一样使用视图customeremaillist </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM customeremaillist;</span><br></pre></td></tr></table></figure><h3 id="使用视图与计算字段"><a href="#使用视图与计算字段" class="headerlink" title="使用视图与计算字段"></a>使用视图与计算字段</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT prod_id,</span><br><span class="line">       quantity,</span><br><span class="line">       item_price,</span><br><span class="line">       quantity*item_price AS expanded_price</span><br><span class="line">FROM orderitems</span><br><span class="line">WHERE order_num =<span class="number">20005</span>;</span><br></pre></td></tr></table></figure><p>现在转换为视图</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE VIEW orderitemsexpanded AS </span><br><span class="line">SELECT order_num,</span><br><span class="line">       prod_id,</span><br><span class="line">       quantity,</span><br><span class="line">       item_price,</span><br><span class="line">       quantity*item_price AS expanded_price</span><br><span class="line">FROM orderitems;</span><br></pre></td></tr></table></figure><p>检索订单20005的详细内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM orderitemsexpanded WHERE order_num &#x3D;20005;</span><br></pre></td></tr></table></figure><h3 id="更新视图"><a href="#更新视图" class="headerlink" title="更新视图"></a>更新视图</h3><p>视图是可更新的，更新一个视图将更新其基表。如果你对视图增加或者删除行，实际上是对其基表增加或者删除行。</p><p>但是并非所有的视图都是可更新的</p><ul><li>分组 （使用GROUP BY 和 HAVING )</li><li>联结</li><li>子查询</li><li>并</li><li>聚集函数 （Min() ,Count(),Sum() 等）；</li><li>DISTINCT;  （用于返回不重复的值 ，select distinct name,id from A</li><li>导出（计算）列</li></ul>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>创建和操纵表</title>
      <link href="/2020/05/09/%E5%88%9B%E5%BB%BA%E5%92%8C%E6%93%8D%E7%BA%B5%E8%A1%A8/"/>
      <url>/2020/05/09/%E5%88%9B%E5%BB%BA%E5%92%8C%E6%93%8D%E7%BA%B5%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>本章介绍表的创建，更改和删除的基本知识</p></blockquote><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h2 id="1-创建表"><a href="#1-创建表" class="headerlink" title="1.创建表"></a>1.创建表</h2><p>示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE customers</span><br><span class="line">(</span><br><span class="line"> cust_id   <span class="keyword">int</span>  NOT <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line"> cust_name <span class="keyword">char</span>(<span class="number">50</span>) NOT <span class="literal">NULL</span>,</span><br><span class="line"> cust_address <span class="keyword">char</span>(<span class="number">50</span>) NOT <span class="literal">NULL</span>,</span><br><span class="line"> PRIMARY KEY(cust_id)</span><br><span class="line">) ENGINE=InnoDB</span><br></pre></td></tr></table></figure><ul><li>语句格式化  MYsql语句中忽略空格，可以采用缩进格式，这样以便阅读和编辑。</li><li>处理现有的表 在创建新表时，指定的表名必须不存在，否则将出错。如果你仅仅想在一个表不存在时创建它，应该在表名后给出IF NOT EXISTS  如CREATE TABLE customers IF NOT EXISTS</li></ul><h3 id="使用NULL值"><a href="#使用NULL值" class="headerlink" title="使用NULL值"></a>使用NULL值</h3><p>NULL值就是没有值或者缺值。</p><p>NULL为默认值，如果不指定NOT NULL 则认定为是NULL</p><h4 id="理解NULL"><a href="#理解NULL" class="headerlink" title="理解NULL"></a>理解NULL</h4><p>不要把NULL和空串相混淆，NULL值是没有值，它不是空串。</p><p>如果指定  ‘ ’   （俩个单引号，其间没有字符）</p><p>这在<strong>NOT NULL</strong> 列中是允许的</p><p>空串 是一个有效的值，它并不是无值</p><p>NULL值用关键字NULL而不是空串指定。</p><h2 id="2-主键再介绍"><a href="#2-主键再介绍" class="headerlink" title="2.主键再介绍"></a>2.主键再介绍</h2><p>创建多个列组成的主键，应该以逗号分隔的列表给出列名</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">PRIMARY <span class="title">KEY</span><span class="params">(order_num,order_item)</span></span></span><br></pre></td></tr></table></figure><p><strong>主键只能使用不允许NULL值的列，允许NULL值的列不能作为唯一标识</strong></p><h2 id="3-使用AUTO-INCREMENT"><a href="#3-使用AUTO-INCREMENT" class="headerlink" title="3.使用AUTO_INCREMENT"></a>3.使用AUTO_INCREMENT</h2><p>AUTO_INCREMENT告诉Mysql ，本列每当增加一行时自动增量。每次执行一个INSERT操作时，Mysql自动对该列增量，每个列只允许有一个AUTO_INCREMENT列，而且它必须被索引。（如，通过使它成为主键）</p><h2 id="4-使用默认值"><a href="#4-使用默认值" class="headerlink" title="4.使用默认值"></a>4.使用默认值</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE customers</span><br><span class="line">(</span><br><span class="line"> cust_id   int  NOT NULL AUTO_INCREMENT,</span><br><span class="line"> cust_name char(50) NOT NULL,</span><br><span class="line"> cust_address char(50) NOT NULL ,</span><br><span class="line"> quantity int   NOT NULL DEFAULT 1,</span><br><span class="line"> PRIMARY KEY(cust_id)</span><br><span class="line">) ENGINE&#x3D;InnoDB</span><br></pre></td></tr></table></figure><p>DEFAULT 1 指示Mysql再未给出数量的情况下，使用数量1</p><ul><li>不允许函数，Mysql 不允许使用函数作为默认值，它只支持常量</li><li>使用默认值而不是NULL值。</li></ul><h2 id="5-引擎类型"><a href="#5-引擎类型" class="headerlink" title="5.引擎类型"></a>5.引擎类型</h2><p>上述的demo 以ENGINE=InnoDB语句结束。</p><p>Mysql有一个具体管理和处理数据的内部引擎，而且MYSQL 具有多种引擎，它打包多个引擎，并且这些引擎都隐藏再Mysql服务器内，全都能执行CREATE TABLE 和SELECT 等命令。</p><h3 id="引擎种类"><a href="#引擎种类" class="headerlink" title="引擎种类"></a>引擎种类</h3><table><thead><tr><th>InnoDB</th><th>可靠的事务处理引擎，它不支持全文本搜索</th></tr></thead><tbody><tr><td>MEMORY</td><td>在功能等同于MyISAM,但由于数据存储在内存（不是磁盘中），速度很快（特别适用于临时表）</td></tr><tr><td>MyISAM</td><td>性能极高的引擎，它支持全文本搜索，但是不支持事务处理</td></tr></tbody></table><p>如果省略ENGINE=语句，则使用默认引擎（MyISAM）</p><p><strong>注意：</strong></p><ul><li>引擎类型可以混用</li><li>外键不能跨引擎，一个引擎的表不能引用具有使用不同引擎的表的外键。</li></ul><h2 id="6-更新表"><a href="#6-更新表" class="headerlink" title="6.更新表"></a>6.更新表</h2><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ALTER TABLE vendors ADD vend_phone <span class="title">CHAR</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE vendors DROP COLUMN vend_phone;</span><br></pre></td></tr></table></figure><p>ALTER TABLE 的一种常见用途是定义外键。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE orderitems ADD CONSTRAINT fk_orderitems_orders FOREIGN KEY (order_num) REFERENCES orders (order_num);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE orderitems ADD CONSTRAINT fk_orderitems_products FOREIGN KEY (prod_id) REFERENCES products (prod_id);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE orders ADD CONSTRAINT fk_orders_customers FOREIGN KEY (cust_id)REFERENCES customers (cust_id);</span><br></pre></td></tr></table></figure><p>ALTER TABLE要极为小心，应该在改动之前做一个完整的备份</p><h3 id="7-删除表"><a href="#7-删除表" class="headerlink" title="7.删除表"></a>7.删除表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP TABLE customers2;</span><br></pre></td></tr></table></figure><p>无法撤销，永久删除</p><h3 id="8-重命名表"><a href="#8-重命名表" class="headerlink" title="8.重命名表"></a>8.重命名表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RENAME TABLE customers2 TO customers;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RENAME TABLE backup_customers TO customers,</span><br><span class="line">             backup_vendors TO vendors,</span><br><span class="line">             backup_products TO products;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDK和JRE</title>
      <link href="/2020/05/09/JDK%E5%92%8CJRE/"/>
      <url>/2020/05/09/JDK%E5%92%8CJRE/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>本章介绍JDK和JRE的区别，他们的作用分别是什么？</p></blockquote><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h2 id="JDK"><a href="#JDK" class="headerlink" title="JDK"></a>JDK</h2><p>JDK是JAVA Development Kit (JAVA开发套件) ，是JAVA的开发工具包。主要包含了类库和工具。</p><p>JDK中包含了JRE 而且在JDK安装目录/JRE/bin/server 文件夹下包含jvm.dll</p><p><img src="QQ20200509115538.png" alt=""></p><p>这说明JDK提供了一个虚拟机。</p><p>另外JDK的bin目录下有各种JAVA程序需要用到的命令。</p><p>与JRE明显的区别就是JDK文件下才会有javac</p><p><img src="QQ20200509115836.png" alt=""></p><p>因为JRE只是一个运行环境，与开发无关。</p><h2 id="JRE"><a href="#JRE" class="headerlink" title="JRE"></a>JRE</h2><p>JRE是JAVA Runtime Environment的缩写。是JAVA程序的运行环境。既然是运行，那么当然要包含JVM,也就是JAVA虚拟机，还有所有JAVA类库的class文件，都在lib下，并且被打包成了jar </p><p><img src="Screenshot.png" alt=""></p><h2 id="问题：jdk里的jre与外面jre的区别"><a href="#问题：jdk里的jre与外面jre的区别" class="headerlink" title="问题：jdk里的jre与外面jre的区别"></a>问题：jdk里的jre与外面jre的区别</h2><p>分析：如果我们安装了JDK，那么我们的电脑中将会有C:\Program Files (x86)\Java\jdk1.8.0_05文件夹 ，这个文件夹里面有一个jre文件夹。然后我们再安装jre，此时我们的电脑中有C:\Program Files (x86)\Java\jre8文件夹。</p><p>通过对比jre和jre8文件夹中的东西，我们发现基本是一样的，那么这俩文件夹到底有啥区别呢？</p><p>我们暂且称jre为自带jdk-jre，jre8为公共jre。</p><p>jdk-jre与公共jre的主要区别在于jdk-jre多了一个server的vm执行选项。</p><p>sever与client使用不同的vm虚拟机。如果电脑运行一个java程序的时候，会自动调用client vm。但是如果开发java程序时使用的就是server vm（server vm启动时间较长，占用内存较多，但是启动后执行性能更高，适合开发）。</p><p><strong>换句话说：公共jre是给普通电脑用户使用的，假如你安装了一个java程序，这个java程序启动运行的时候就会调用jre（java runtime environment）；如果你是一个java开发者，那么你就需要安装jdk（java development kit），这时你开发调试java程序的时候就会调用jdk里面的jre。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVASE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA中this和super的用法总结</title>
      <link href="/2020/05/09/JAVA%E4%B8%ADthis%E5%92%8Csuper%E7%9A%84%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93/"/>
      <url>/2020/05/09/JAVA%E4%B8%ADthis%E5%92%8Csuper%E7%9A%84%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>本章介绍这几天看到类在继承时会用到<strong>this</strong>和<strong>super</strong>，这里就做了一点总结，与各位共同交流，有错误请各位指正~</p></blockquote><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p><strong>this</strong></p><p>this是自身的一个对象，代表对象本身，可以理解为：指向对象本身的一个指针。</p><h2 id="this的用法在java中大体可以分为3种："><a href="#this的用法在java中大体可以分为3种：" class="headerlink" title="this的用法在java中大体可以分为3种："></a>this的用法在java中大体可以分为3种：</h2><p><strong>1.普通的直接引用</strong></p><p>这种就不用讲了，this相当于是指向当前对象本身。</p><p><strong>2.形参与成员名字重名，用this来区分：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age = <span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"初始化年龄："</span>+age);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">GetAge</span><span class="params">(<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person Harry = <span class="keyword">new</span> Person();</span><br><span class="line">        System.out.println(<span class="string">"Harry's age is "</span>+Harry.GetAge(<span class="number">12</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果：</strong></p><p><strong>初始化年龄：10</strong><br><strong>Harry’s age is 12</strong></p><p>可以看到，这里age是GetAge成员方法的形参，this.age是Person类的成员变量。</p><p><strong>3.引用构造函数</strong></p><p>这个和super放在一起讲，见下面。</p><h2 id="super"><a href="#super" class="headerlink" title="super"></a><strong>super</strong></h2><p>super可以理解为是指向自己超（父）类对象的一个指针，而这个超类指的是离自己最近的一个父类。</p><h3 id="super也有三种用法："><a href="#super也有三种用法：" class="headerlink" title="super也有三种用法："></a>super也有三种用法：</h3><p>1.普通的直接引用</p><p>与this类似，super相当于是指向当前对象的父类，这样就可以用super.xxx来引用父类的成员。</p><p>2.子类中的成员变量或方法与父类中的成员变量或方法同名</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Country</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       name = <span class="string">"China"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">City</span> <span class="keyword">extends</span> <span class="title">Country</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    name = <span class="string">"Shanghai"</span>;</span><br><span class="line">    <span class="keyword">super</span>.value();      <span class="comment">//调用父类的方法</span></span><br><span class="line">    System.out.println(name);</span><br><span class="line">    System.out.println(<span class="keyword">super</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       City c=<span class="keyword">new</span> City();</span><br><span class="line">       c.value();</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果：</strong></p><p><strong>Shanghai</strong><br><strong>China</strong></p><p>可以看到，这里既调用了父类的方法，也调用了父类的变量。若不调用父类方法value()，只调用父类变量name的话，则父类name值为默认值null。</p><p>3.引用构造函数</p><p>super（参数）：调用父类中的某一个构造函数（应该为构造函数中的第一条语句）。</p><p>this（参数）：调用本类中另一种形式的构造函数（应该为构造函数中的第一条语句）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prt</span><span class="params">(String s)</span> </span>&#123; </span><br><span class="line">       System.out.println(s); </span><br><span class="line">    &#125; </span><br><span class="line">   </span><br><span class="line">    Person() &#123; </span><br><span class="line">       prt(<span class="string">"父类·无参数构造方法： "</span>+<span class="string">"A Person."</span>); </span><br><span class="line">    &#125;<span class="comment">//构造方法(1) </span></span><br><span class="line">    </span><br><span class="line">    Person(String name) &#123; </span><br><span class="line">       prt(<span class="string">"父类·含一个参数的构造方法： "</span>+<span class="string">"A person's name is "</span> + name); </span><br><span class="line">    &#125;<span class="comment">//构造方法(2) </span></span><br><span class="line">&#125; </span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Chinese</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123; </span><br><span class="line">    Chinese() &#123; </span><br><span class="line">       <span class="keyword">super</span>(); <span class="comment">// 调用父类构造方法（1） </span></span><br><span class="line">       prt(<span class="string">"子类·调用父类”无参数构造方法“： "</span>+<span class="string">"A chinese coder."</span>); </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    Chinese(String name) &#123; </span><br><span class="line">       <span class="keyword">super</span>(name);<span class="comment">// 调用父类具有相同形参的构造方法（2） </span></span><br><span class="line">       prt(<span class="string">"子类·调用父类”含一个参数的构造方法“： "</span>+<span class="string">"his name is "</span> + name); </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    Chinese(String name, <span class="keyword">int</span> age) &#123; </span><br><span class="line">       <span class="keyword">this</span>(name);<span class="comment">// 调用具有相同形参的构造方法（3） </span></span><br><span class="line">       prt(<span class="string">"子类：调用子类具有相同形参的构造方法：his age is "</span> + age); </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">       Chinese cn = <span class="keyword">new</span> Chinese(); </span><br><span class="line">       cn = <span class="keyword">new</span> Chinese(<span class="string">"codersai"</span>); </span><br><span class="line">       cn = <span class="keyword">new</span> Chinese(<span class="string">"codersai"</span>, <span class="number">18</span>); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果：</strong></p><p><strong>父类·无参数构造方法： A Person.</strong><br><strong>子类·调用父类”无参数构造方法“： A chinese coder.</strong><br><strong>父类·含一个参数的构造方法： A person’s name is codersai</strong><br><strong>子类·调用父类”含一个参数的构造方法“： his name is codersai</strong><br><strong>父类·含一个参数的构造方法： A person’s name is codersai</strong><br><strong>子类·调用父类”含一个参数的构造方法“： his name is codersai</strong><br><strong>子类：调用子类具有相同形参的构造方法：his age is 18</strong></p><p>从本例可以看到，可以用super和this分别调用父类的构造方法和本类中其他形式的构造方法。</p><p>例子中Chinese类第三种构造方法调用的是本类中第二种构造方法，而第二种构造方法是调用父类的，因此也要先调用父类的构造方法，再调用本类中第二种，最后是重写第三种构造方法。</p><p><strong>super和this的异同：</strong></p><ul><li>super（参数）：调用基类中的某一个构造函数（应该为构造函数中的第一条语句） </li><li>this（参数）：调用本类中另一种形成的构造函数（应该为构造函数中的第一条语句）</li><li>super:　它引用当前对象的直接父类中的成员（用来访问直接父类中被隐藏的父类中成员数据或函数，基类与派生类中有相同成员定义时如：super.变量名  super.成员函数据名（实参）</li><li>this：它代表当前对象名（在程序中易产生二义性之处，应使用this来指明当前对象；如果函数的形参与类中的成员数据同名，这时需用this来指明成员变量名）</li><li>调用super()必须写在子类构造方法的第一行，否则编译不通过。每个子类构造方法的第一条语句，都是隐含地调用super()，如果父类没有这种形式的构造函数，那么在编译的时候就会报错。</li><li>super()和this()类似,区别是，super()从子类中调用父类的构造方法，this()在同一类内调用其它方法。</li><li>super()和this()均需放在构造方法内第一行。</li><li>尽管可以用this调用一个构造器，但却不能调用两个。</li><li>this和super不能同时出现在一个构造函数里面，因为this必然会调用其它的构造函数，其它的构造函数必然也会有super语句的存在，所以在同一个构造函数里面有相同的语句，就失去了语句的意义，编译器也不会通过。</li><li>this()和super()都指的是对象，所以，均不可以在static环境中使用。包括：static变量,static方法，static语句块。</li><li>从本质上讲，this是一个指向本对象的指针, 然而super是一个Java关键字。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVASE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Set相关</title>
      <link href="/2020/05/08/Set%E7%9B%B8%E5%85%B3/"/>
      <url>/2020/05/08/Set%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>本章介绍Set</p></blockquote><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p><strong>SET:注重独一无二的性质，该体系集合知道某物是否已经存在于集合中，不会存储重复的元素。</strong></p><p>用于存储无序（存入和取出的顺序不一定相同）元素，值不能重复</p><p>Set集合继承了Collection接口。</p><h2 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h2><p>哈希表里面存放的是哈希值。HashSet存储元素的顺序并不是按照存入时的顺序（和List 显然不同）是按照哈希值来存，所以取也是按照哈希值来取得。</p><p><strong>元素的哈希值是通过元素的hashcode方法来获取的，HashSet首先判断俩个元素的哈希值，如果哈希值一样，那么接着比较equals方法，如果equals结果为true。HashSet就会视作同一个元素。如果equals为false 就不是同一个元素。</strong></p><h3 id="HashSet到底是如何判断俩个元素重复"><a href="#HashSet到底是如何判断俩个元素重复" class="headerlink" title="HashSet到底是如何判断俩个元素重复"></a>HashSet到底是如何判断俩个元素重复</h3><p>通过hashCode方法和equals方法来保证元素的唯一性，add()返回的是boolean类型</p><p>判断两个元素是否相同，先要判断元素的hashCode值是否一致，只有在该值一致的情况下，才会判断equals方法，如果存储在HashSet中的两个对象hashCode方法的值相同equals方法返回的结果是true，那么HashSet认为这两个元素是相同元素，只存储一个（重复元素无法存入）。</p><p>注意：HashSet集合在判断元素是否相同先判断hashCode方法，如果相同才会判断equals。如果不相同，是不会调用equals方法的。</p><h3 id="HashSet-和ArrayList集合都有判断元素是否相同的方法"><a href="#HashSet-和ArrayList集合都有判断元素是否相同的方法" class="headerlink" title="HashSet 和ArrayList集合都有判断元素是否相同的方法"></a>HashSet 和ArrayList集合都有判断元素是否相同的方法</h3><p>boolean contains(Object o)</p><p>HashSet使用hashCode和equals方法，ArrayList使用了equals方法</p><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Set hs=<span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        hs.add(<span class="string">"jack"</span>);</span><br><span class="line">        hs.add(<span class="string">"rose"</span>);</span><br><span class="line">        hs.add(<span class="string">"2020"</span>);</span><br><span class="line">        hs.add(<span class="string">"trip"</span>);</span><br><span class="line">        System.out.println(hs.size());</span><br><span class="line">        <span class="keyword">boolean</span> add=hs.add(<span class="string">"jack"</span>); <span class="comment">/* 如果set尚未包含指定元素，那么 返回true 此时返回false; */</span></span><br><span class="line">        System.out.println(add);</span><br><span class="line">        Iterator it=hs.iterator();</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext())</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(it.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This program demonstrates</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Alita Alice</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: Created in 21:13 2020/5/8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HashSet hs = <span class="keyword">new</span> HashSet();</span><br><span class="line">        hs.add(<span class="keyword">new</span> Person(<span class="string">"jack"</span>, <span class="number">20</span>));</span><br><span class="line">        hs.add(<span class="keyword">new</span> Person(<span class="string">"rose"</span>,<span class="number">20</span>));</span><br><span class="line">        hs.add(<span class="keyword">new</span> Person(<span class="string">"rose"</span>,<span class="number">20</span>));</span><br><span class="line">        Iterator it= hs.iterator();</span><br><span class="line">        <span class="keyword">while</span>(it.hasNext())</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(it.next());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    Person()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name,<span class="keyword">int</span> age)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age=age;</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Person)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Person person = (Person) o;</span><br><span class="line">        <span class="keyword">return</span> getAge() == person.getAge() &amp;&amp;</span><br><span class="line">                getName().equals(person.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(getName(), getAge());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>其中在HashSet中存储自定义的对象，并尝试添加重复元素，需要override hashCode()和equals()方法。</strong></p><h2 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h2><p>现在有一批数据，要求不能重复存储元素，而且要排序。</p><p>ArrayList ，LinkList不能去除重复数据，HashSet可以去除重复，但是无序。</p><p>示例：使用TreeSet集合存储字符串元素，并且遍历。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo5</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TreeSet treeSet=<span class="keyword">new</span> TreeSet();</span><br><span class="line">        treeSet.add(<span class="string">"aaa"</span>);</span><br><span class="line">        treeSet.add(<span class="string">"bbb"</span>);</span><br><span class="line">        treeSet.add(<span class="string">"ccc"</span>);</span><br><span class="line">        treeSet.add(<span class="string">"ddd"</span>);</span><br><span class="line">        System.out.println(treeSet);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 输出</span></span><br><span class="line"><span class="comment">[aaa, bbb, ccc, ddd]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="俩种比较器接口"><a href="#俩种比较器接口" class="headerlink" title="俩种比较器接口"></a>俩种比较器接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Comparable </span><br><span class="line">         compareTo(Object o)  元素自身具备比较性</span><br><span class="line">Comparator</span><br><span class="line">         compare(Object o1,Object o2) 给容器传入比较器</span><br></pre></td></tr></table></figure><h3 id="TreeSet集合排序的俩种方式"><a href="#TreeSet集合排序的俩种方式" class="headerlink" title="TreeSet集合排序的俩种方式"></a>TreeSet集合排序的俩种方式</h3><ul><li><p>让元素自身具备比较性</p><p>元素需要实现Comparable接口，覆盖compareTo(Object o) 方法</p><p>这种方式也被称为元素的自然排序，也可以称为默认排序</p><p>年龄按照首要条件，年龄相同再比姓名</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sun.reflect.generics.tree.Tree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"><span class="keyword">import</span> java.util.TreeSet;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This program demonstrates</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Alita Alice</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: Created in 10:23 2020/5/9</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TreeSet ts=<span class="keyword">new</span> TreeSet();</span><br><span class="line">        ts.add(<span class="keyword">new</span> Person(<span class="string">"aa"</span>, <span class="number">20</span>, <span class="string">"男"</span>));</span><br><span class="line">        ts.add(<span class="keyword">new</span> Person(<span class="string">"bb"</span>, <span class="number">18</span>, <span class="string">"女"</span>));</span><br><span class="line">        ts.add(<span class="keyword">new</span> Person(<span class="string">"cc"</span>, <span class="number">17</span>, <span class="string">"男"</span>));</span><br><span class="line">        ts.add(<span class="keyword">new</span> Person(<span class="string">"dd"</span>, <span class="number">17</span>, <span class="string">"女"</span>));</span><br><span class="line">        ts.add(<span class="keyword">new</span> Person(<span class="string">"dd"</span>, <span class="number">15</span>, <span class="string">"女"</span>));</span><br><span class="line">        ts.add(<span class="keyword">new</span> Person(<span class="string">"dd"</span>, <span class="number">15</span>, <span class="string">"女"</span>));</span><br><span class="line">        System.out.println(ts);</span><br><span class="line">        System.out.println(ts.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Comparable</span></span></span><br><span class="line"><span class="class"> </span>&#123;</span><br><span class="line">     <span class="keyword">private</span> String name;</span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">     <span class="keyword">private</span> String gender;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age, String gender)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">this</span>.name = name;</span><br><span class="line">         <span class="keyword">this</span>.age = age;</span><br><span class="line">         <span class="keyword">this</span>.gender = gender;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> name;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">this</span>.name = name;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> age;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">this</span>.age = age;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> String <span class="title">getGender</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> gender;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setGender</span><span class="params">(String gender)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">this</span>.gender = gender;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="string">"Person&#123;"</span> +</span><br><span class="line">                 <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                 <span class="string">", age="</span> + age +</span><br><span class="line">                 <span class="string">", gender='"</span> + gender + <span class="string">'\''</span> +</span><br><span class="line">                 <span class="string">'&#125;'</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">         <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Person)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">         Person person = (Person) o;</span><br><span class="line">         <span class="keyword">return</span> getAge() == person.getAge() &amp;&amp;</span><br><span class="line">                 getName().equals(person.getName()) &amp;&amp;</span><br><span class="line">                 getGender().equals(person.getGender());</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> Objects.hash(getName(), getAge(), getGender());</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">         Person p = (Person) o;</span><br><span class="line">         System.out.println(<span class="keyword">this</span> + <span class="string">"compareTo:"</span> + p);</span><br><span class="line">         <span class="keyword">if</span> (<span class="keyword">this</span>.age &gt; p.age) &#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> (<span class="keyword">this</span>.age &lt; p.age) &#123;</span><br><span class="line">             <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">this</span>.name.compareTo(p.name);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">/* out</span></span><br><span class="line"><span class="comment">Person&#123;name='aa', age=20, gender='男'&#125;compareTo:Person&#123;name='aa', age=20, gender='男'&#125;</span></span><br><span class="line"><span class="comment">Person&#123;name='bb', age=18, gender='女'&#125;compareTo:Person&#123;name='aa', age=20, gender='男'&#125;</span></span><br><span class="line"><span class="comment">Person&#123;name='cc', age=17, gender='男'&#125;compareTo:Person&#123;name='aa', age=20, gender='男'&#125;</span></span><br><span class="line"><span class="comment">Person&#123;name='cc', age=17, gender='男'&#125;compareTo:Person&#123;name='bb', age=18, gender='女'&#125;</span></span><br><span class="line"><span class="comment">Person&#123;name='dd', age=17, gender='女'&#125;compareTo:Person&#123;name='bb', age=18, gender='女'&#125;</span></span><br><span class="line"><span class="comment">Person&#123;name='dd', age=17, gender='女'&#125;compareTo:Person&#123;name='cc', age=17, gender='男'&#125;</span></span><br><span class="line"><span class="comment">Person&#123;name='dd', age=15, gender='女'&#125;compareTo:Person&#123;name='bb', age=18, gender='女'&#125;</span></span><br><span class="line"><span class="comment">Person&#123;name='dd', age=15, gender='女'&#125;compareTo:Person&#123;name='cc', age=17, gender='男'&#125;</span></span><br><span class="line"><span class="comment">Person&#123;name='dd', age=15, gender='女'&#125;compareTo:Person&#123;name='bb', age=18, gender='女'&#125;</span></span><br><span class="line"><span class="comment">Person&#123;name='dd', age=15, gender='女'&#125;compareTo:Person&#123;name='cc', age=17, gender='男'&#125;</span></span><br><span class="line"><span class="comment">Person&#123;name='dd', age=15, gender='女'&#125;compareTo:Person&#123;name='dd', age=15, gender='女'&#125;</span></span><br><span class="line"><span class="comment">[Person&#123;name='dd', age=15, gender='女'&#125;, Person&#123;name='cc', age=17, gender='男'&#125;, Person&#123;name='dd', age=17, gender='女'&#125;, Person&#123;name='bb', age=18, gender='女'&#125;, Person&#123;name='aa', age=20, gender='男'&#125;]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="二-让容器自身具备比较性，自定义比较器"><a href="#二-让容器自身具备比较性，自定义比较器" class="headerlink" title="二 让容器自身具备比较性，自定义比较器"></a>二 让容器自身具备比较性，自定义比较器</h3><p>需求：当元素自身不具备比较性，或者元素自身具备的比较性不是所需。</p><p><strong>那么这时只能让容器自身具备定义一个类实现Comparetor接口，覆盖compare方法</strong></p><p><strong>并将该接口的子类对象作为参数传递给TreeSet集合的构造函数。</strong></p><p>当Comparable 比较方式及Comparator比较方式同时存在， 以Comparator比较方式为主。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Set;</span><br><span class="line">  <span class="keyword">import</span> java.util.Comparator;</span><br><span class="line">  <span class="keyword">import</span> java.util.Objects;</span><br><span class="line">  <span class="keyword">import</span> java.util.TreeSet;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * This program demonstrates</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@author</span> Alita Alice</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@Date</span>: Created in 10:54 2020/5/9</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo6</span> </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">          TreeSet ts=<span class="keyword">new</span> TreeSet(<span class="keyword">new</span> MyComparator());</span><br><span class="line">          ts.add(<span class="keyword">new</span> Book(<span class="string">"think in java"</span>, <span class="number">100</span>));</span><br><span class="line">          ts.add(<span class="keyword">new</span> Book(<span class="string">"java 核心技术"</span>, <span class="number">75</span>));</span><br><span class="line">          ts.add(<span class="keyword">new</span> Book(<span class="string">"现代操作系统"</span>, <span class="number">50</span>));</span><br><span class="line">          ts.add(<span class="keyword">new</span> Book(<span class="string">"java就业教程"</span>, <span class="number">35</span>));</span><br><span class="line">          ts.add(<span class="keyword">new</span> Book(<span class="string">"think in java"</span>, <span class="number">100</span>));</span><br><span class="line">          ts.add(<span class="keyword">new</span> Book(<span class="string">"ccc in java"</span>, <span class="number">100</span>));</span><br><span class="line">  </span><br><span class="line">          System.out.println(ts);</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">MyComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span></span></span><br><span class="line"><span class="class">  </span>&#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Object o1, Object o2)</span> </span>&#123;</span><br><span class="line">                      Book b1=(Book) o1;</span><br><span class="line">                      Book b2=(Book) o2;</span><br><span class="line">          System.out.println(b1+<span class="string">"comparator"</span>+b2);</span><br><span class="line">          <span class="keyword">if</span>(b1.getPrice()&gt;b2.getPrice())</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span>(b1.getPrice()&lt;b2.getPrice())</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> b1.getName().compareTo(b2.getName());</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Book</span></span></span><br><span class="line"><span class="class">  </span>&#123;</span><br><span class="line">      <span class="keyword">private</span> String name;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">double</span> price;</span><br><span class="line">  </span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="title">Book</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> name;</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="title">Book</span><span class="params">(String name, <span class="keyword">double</span> price)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">this</span>.name = name;</span><br><span class="line">          <span class="keyword">this</span>.price = price;</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">this</span>.name = name;</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> price;</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPrice</span><span class="params">(<span class="keyword">double</span> price)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">this</span>.price = price;</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">          <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Book)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">          Book book = (Book) o;</span><br><span class="line">          <span class="keyword">return</span> Double.compare(book.getPrice(), getPrice()) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                  getName().equals(book.getName());</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> Objects.hash(getName(), getPrice());</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="string">"Book&#123;"</span> +</span><br><span class="line">                  <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                  <span class="string">", price="</span> + price +</span><br><span class="line">                  <span class="string">'&#125;'</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* out</span></span><br><span class="line"><span class="comment">  Book&#123;name='think in java', price=100.0&#125;comparatorBook&#123;name='think in java', price=100.0&#125;</span></span><br><span class="line"><span class="comment">  Book&#123;name='java 核心技术', price=75.0&#125;comparatorBook&#123;name='think in java', price=100.0&#125;</span></span><br><span class="line"><span class="comment">  Book&#123;name='现代操作系统', price=50.0&#125;comparatorBook&#123;name='think in java', price=100.0&#125;</span></span><br><span class="line"><span class="comment">  Book&#123;name='现代操作系统', price=50.0&#125;comparatorBook&#123;name='java 核心技术', price=75.0&#125;</span></span><br><span class="line"><span class="comment">  Book&#123;name='java就业教程', price=35.0&#125;comparatorBook&#123;name='java 核心技术', price=75.0&#125;</span></span><br><span class="line"><span class="comment">  Book&#123;name='java就业教程', price=35.0&#125;comparatorBook&#123;name='现代操作系统', price=50.0&#125;</span></span><br><span class="line"><span class="comment">  Book&#123;name='think in java', price=100.0&#125;comparatorBook&#123;name='java 核心技术', price=75.0&#125;</span></span><br><span class="line"><span class="comment">  Book&#123;name='think in java', price=100.0&#125;comparatorBook&#123;name='think in java', price=100.0&#125;</span></span><br><span class="line"><span class="comment">  Book&#123;name='ccc in java', price=100.0&#125;comparatorBook&#123;name='java 核心技术', price=75.0&#125;</span></span><br><span class="line"><span class="comment">  Book&#123;name='ccc in java', price=100.0&#125;comparatorBook&#123;name='think in java', price=100.0&#125;</span></span><br><span class="line"><span class="comment">  [Book&#123;name='java就业教程', price=35.0&#125;, Book&#123;name='现代操作系统', price=50.0&#125;, Book&#123;name='java 核心技术', price=75.0&#125;, Book&#123;name='ccc in java', price=100.0&#125;, Book&#123;name='think in java', price=100.0&#125;]</span></span><br><span class="line"><span class="comment">  */</span></span><br></pre></td></tr></table></figure><h3 id="4-LinkedHashSet"><a href="#4-LinkedHashSet" class="headerlink" title="4.LinkedHashSet"></a>4.LinkedHashSet</h3></li></ul><p>LinkedHashSet会保存插入的顺序</p><p>看到array，就要想到角标</p><p>看到link ，就要想到first,last</p><p>看到hash,就要想到hashCode，equals</p><p>看到tree，就要想到俩个接口。Comparable,Comparator </p><h3 id="5-set为什么是不允许重复的"><a href="#5-set为什么是不允许重复的" class="headerlink" title="5.set为什么是不允许重复的"></a>5.set为什么是不允许重复的</h3><p>现在我们就从 Set 说起。</p><p>Set 接口为我们提供了一个 add() 方法，以让我们添加元素。所以我们看一下在其实现类 HashSet 中是如何实现的呢？</p><p>我们看 HashSet 中的 add() 方法实现；</p><p>  public boolean add( E o ) {</p><p>​       return <strong><em>\</em>map.put(o, PRESENT)==null;**</strong></p><p>}</p><p>你可能回问怎么回出来 map 了呢？</p><p>Map 又是一个什么变量呢？</p><p>我们来看 map 是在在哪定义的。原来，在 HashSet 中定义了这样的两个变量：</p><p>  private transient HashMap&lt;E,Object&gt; map;</p><p>  private static final Object PRESENT = new Object();</p><p>我们再看一下上面的 add() 方法。</p><p>map.put(o, PRESENT)==null</p><p>实际执行的是 map 的方法，并且我们添加的对象是 map 中的 key,value 是执行的同一个对象PRESENT.</p><p><strong><em>\</em>因为map中的key是不允许重复的，所以set中的元素不能重复。**</strong></p>]]></content>
      
      
      <categories>
          
          <category> JAVA集合 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Map接口</title>
      <link href="/2020/05/08/Map%E6%8E%A5%E5%8F%A3/"/>
      <url>/2020/05/08/Map%E6%8E%A5%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>本章介绍Map接口</p></blockquote><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h2 id="一-Map的定义"><a href="#一-Map的定义" class="headerlink" title="一.Map的定义"></a>一.Map的定义</h2><p>Map是一种依照键（key）存储元素的容器，键（key）很像下标。在List里下标是整数，而在Map中键（key）可以是任意类型的对象。Map中不能有重复的键（key），每个键都有一个对应的值（value)</p><p>一个键（key）和它对应的值（value)构成Map集合中的一个元素。</p><p>Map中的元素是俩个对象，一个对象作为键，一个对象作为值，<strong>键不可以重复，但是值可以重复。</strong></p><h2 id="二-Map常用方法"><a href="#二-Map常用方法" class="headerlink" title="二.Map常用方法"></a>二.Map常用方法</h2><ul><li><p>添加</p><table><thead><tr><th>put(key,Value)</th><th>调用put方法时，如果已经存在一个相同的key， 则返回的是前一个key对应的value，同时该key的新value覆盖旧value；如果是新的一个key，则返回的是null</th></tr></thead><tbody><tr><td>putAll</td><td>从指定映射中将所有映射关系复制到此映射中去。</td></tr></tbody></table></li><li><p><img src="https://photos.alitaalice.cn/image/20200530105616.png" alt=""></p></li><li><p>删除</p><table><thead><tr><th>remove(key)</th><th>删除指定key的键值对，返回被删除的key关联的value，不存在返回null</th></tr></thead><tbody><tr><td>remove(key,value)</td><td>删除指定键值对，成功返回true</td></tr><tr><td>clear()</td><td>删除map中所有的键值对</td></tr></tbody></table></li><li><p>获取</p><table><thead><tr><th>get(key)</th><th>返回指定key所对应的value，不存在则返回null</th></tr></thead><tbody><tr><td>Int size()</td><td>获取长度</td></tr></tbody></table></li><li><p>判断</p><table><thead><tr><th>boolean isEmpty()</th><th>长度为0返回true，否则false</th></tr></thead><tbody><tr><td>boolean containsKey(Object key)</td><td>判断集合中是否包含指定的key</td></tr><tr><td>boolean containsValue(Object value)</td><td>判断集合中是否包含指定的value</td></tr></tbody></table></li></ul><p>示例：</p><p>添加：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This program demonstrates</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Alita Alice</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: Created in 13:48 2020/5/9</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo7</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Integer&gt; map1 = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map1.put(<span class="string">"jack"</span>, <span class="number">20</span>);</span><br><span class="line">        map1.put(<span class="string">"rose"</span>, <span class="number">18</span>);</span><br><span class="line">        map1.put(<span class="string">"lucy"</span>, <span class="number">17</span>);</span><br><span class="line">        map1.put(<span class="string">"java"</span>, <span class="number">25</span>);</span><br><span class="line">        System.out.println(<span class="string">"map11"</span>+map1);</span><br><span class="line"></span><br><span class="line">        Map&lt;String,Integer&gt; map2=<span class="keyword">new</span> HashMap();</span><br><span class="line">        map2.put(<span class="string">"张三丰"</span>, <span class="number">100</span>);</span><br><span class="line">        map2.put(<span class="string">"虚竹"</span>, <span class="number">20</span>);</span><br><span class="line">        System.out.println(<span class="string">"map2"</span>+map2);</span><br><span class="line">        <span class="comment">//从指定映射种将所有的映射关系复制到此映射种</span></span><br><span class="line">        map1.putAll(map2);</span><br><span class="line">        System.out.println(<span class="string">"map1"</span>+map1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* out</span></span><br><span class="line"><span class="comment">map11&#123;java=25, rose=18, lucy=17, jack=20&#125;</span></span><br><span class="line"><span class="comment">map2&#123;张三丰=100, 虚竹=20&#125;</span></span><br><span class="line"><span class="comment">map1&#123;java=25, 张三丰=100, rose=18, lucy=17, jack=20, 虚竹=20&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>删除：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This program demonstrates</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Alita Alice</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: Created in 13:48 2020/5/9</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo7</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Integer&gt; map1 = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map1.put(<span class="string">"jack"</span>, <span class="number">20</span>);</span><br><span class="line">        map1.put(<span class="string">"rose"</span>, <span class="number">18</span>);</span><br><span class="line">        map1.put(<span class="string">"lucy"</span>, <span class="number">17</span>);</span><br><span class="line">        map1.put(<span class="string">"java"</span>, <span class="number">25</span>);</span><br><span class="line">        System.out.println(map1);</span><br><span class="line">        System.out.println(<span class="string">"delete value:"</span>+map1.remove(<span class="string">"java"</span>));</span><br><span class="line">        map1.clear();</span><br><span class="line">        System.out.println(<span class="string">"map1"</span>+map1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* out</span></span><br><span class="line"><span class="comment">&#123;java=25, rose=18, lucy=17, jack=20&#125;</span></span><br><span class="line"><span class="comment">delete value:25</span></span><br><span class="line"><span class="comment">map1&#123;&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>获取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This program demonstrates</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Alita Alice</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: Created in 13:48 2020/5/9</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo7</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Integer&gt; map1 = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map1.put(<span class="string">"jack"</span>, <span class="number">20</span>);</span><br><span class="line">        map1.put(<span class="string">"rose"</span>, <span class="number">18</span>);</span><br><span class="line">        map1.put(<span class="string">"lucy"</span>, <span class="number">17</span>);</span><br><span class="line">        map1.put(<span class="string">"java"</span>, <span class="number">25</span>);</span><br><span class="line">        System.out.println(map1);</span><br><span class="line">        System.out.println(<span class="string">"value:"</span>+map1.get(<span class="string">"jack"</span>));</span><br><span class="line">        System.out.println(<span class="string">"map.size:"</span>+map1.size());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* out</span></span><br><span class="line"><span class="comment">&#123;java=25, rose=18, lucy=17, jack=20&#125;</span></span><br><span class="line"><span class="comment">value:20</span></span><br><span class="line"><span class="comment">map.size:4</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>判断：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This program demonstrates</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Alita Alice</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: Created in 13:48 2020/5/9</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo7</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Integer&gt; map1 = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map1.put(<span class="string">"jack"</span>, <span class="number">20</span>);</span><br><span class="line">        map1.put(<span class="string">"rose"</span>, <span class="number">18</span>);</span><br><span class="line">        map1.put(<span class="string">"lucy"</span>, <span class="number">17</span>);</span><br><span class="line">        map1.put(<span class="string">"java"</span>, <span class="number">25</span>);</span><br><span class="line">        System.out.println(map1);</span><br><span class="line">        System.out.println(<span class="string">"isEmpty"</span>+map1.isEmpty());</span><br><span class="line">        System.out.println(<span class="string">"containskey"</span>+map1.containsKey(<span class="string">"jack"</span>));</span><br><span class="line">        System.out.println(<span class="string">"containsvaluse"</span>+map1.containsValue(<span class="number">100</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* out</span></span><br><span class="line"><span class="comment">&#123;java=25, rose=18, lucy=17, jack=20&#125;</span></span><br><span class="line"><span class="comment">isEmptyfalse</span></span><br><span class="line"><span class="comment">containskeytrue</span></span><br><span class="line"><span class="comment">containsvalusefalse</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="三-遍历Map的方式"><a href="#三-遍历Map的方式" class="headerlink" title="三.遍历Map的方式"></a>三.遍历Map的方式</h3><ul><li><p><strong>使用KeySet</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This program demonstrates</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Alita Alice</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: Created in 13:48 2020/5/9</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo7</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Integer&gt; map1 = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map1.put(<span class="string">"jack"</span>, <span class="number">20</span>);</span><br><span class="line">        map1.put(<span class="string">"rose"</span>, <span class="number">18</span>);</span><br><span class="line">        map1.put(<span class="string">"lucy"</span>, <span class="number">17</span>);</span><br><span class="line">        map1.put(<span class="string">"java"</span>, <span class="number">25</span>);</span><br><span class="line">        System.out.println(map1);</span><br><span class="line">        Set&lt;String&gt; ks=map1.keySet();</span><br><span class="line">        Iterator&lt;String&gt; it=ks.iterator();</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext())</span><br><span class="line">        &#123;</span><br><span class="line">            String key=it.next();</span><br><span class="line">            Integer value = map1.get(key);</span><br><span class="line">            System.out.println(<span class="string">"key="</span>+key+<span class="string">" value="</span>+value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* out</span></span><br><span class="line"><span class="comment">&#123;java=25, rose=18, lucy=17, jack=20&#125;</span></span><br><span class="line"><span class="comment">key=java value=25</span></span><br><span class="line"><span class="comment">key=rose value=18</span></span><br><span class="line"><span class="comment">key=lucy value=17</span></span><br><span class="line"><span class="comment">key=jack value=20</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>将Map转换成Set集合，通过Set的迭代器取出Set集合中的每一个元素（Iterator)就是Map集合中所有的键，再通过get方法获取键对应的值。</p></li><li><p>通过values获取所有的值，不能获取到key对象</p><p>Collection<V> values()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo7</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Integer&gt; map1 = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map1.put(<span class="string">"jack"</span>, <span class="number">20</span>);</span><br><span class="line">        map1.put(<span class="string">"rose"</span>, <span class="number">18</span>);</span><br><span class="line">        map1.put(<span class="string">"lucy"</span>, <span class="number">17</span>);</span><br><span class="line">        map1.put(<span class="string">"java"</span>, <span class="number">25</span>);</span><br><span class="line">        Collection&lt;Integer&gt; vs=map1.values();  <span class="comment">//values方法获取所有的值但是不能获取到KEY对象。</span></span><br><span class="line">        Iterator&lt;Integer&gt; it = vs.iterator();</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext())</span><br><span class="line">        &#123;</span><br><span class="line">            Integer value=it.next();</span><br><span class="line">            System.out.println(<span class="string">"valuse="</span> +value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Map.Entry</p><p>面向对象的思想将Map集合中的键和值映射关系打包成一个对象，就是Map.Entry</p><p>将该对象存入Set集合，Map.Entry是一个对象，那么该对象具备的getKey ，getValue获得键和值。（<strong>通过Map中的entrySet()方法获取存放Map.Entry&lt;K,V&gt;对象的Set集合</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo7</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer,String&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="number">1</span>,<span class="string">"aaaa"</span>);</span><br><span class="line">        map.put(<span class="number">2</span>,<span class="string">"bbb"</span>);</span><br><span class="line">        map.put(<span class="number">3</span>, <span class="string">"cccc"</span>);</span><br><span class="line">        System.out.println(map);</span><br><span class="line"></span><br><span class="line">        Set&lt;Map.Entry&lt;Integer,String&gt;&gt; es=map.entrySet();</span><br><span class="line">        Iterator&lt;Map.Entry&lt;Integer,String&gt;&gt; it=es.iterator();</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext())</span><br><span class="line">        &#123;</span><br><span class="line">            Map.Entry&lt;Integer,String&gt; en =it.next();</span><br><span class="line">            Integer key=en.getKey();</span><br><span class="line">            String value=en.getValue();</span><br><span class="line">            System.out.println(<span class="string">"key="</span>+key+<span class="string">"value="</span>+value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* out</span></span><br><span class="line"><span class="comment">&#123;1=aaaa, 2=bbb, 3=cccc&#125;</span></span><br><span class="line"><span class="comment">key=1value=aaaa</span></span><br><span class="line"><span class="comment">key=2value=bbb</span></span><br><span class="line"><span class="comment">key=3value=cccc</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p>底层是哈希表数据结构，线程是不同步的，<strong>可以存入null键。</strong></p><p>要保证键的唯一性，需要覆盖hashCode方法 和equals方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This program demonstrates</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Alita Alice</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: Created in 22:09 2020/5/10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;Person,String&gt; hm=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        hm.put(<span class="keyword">new</span> Person(<span class="string">"jack"</span>, <span class="number">20</span>), <span class="string">"1001"</span>);</span><br><span class="line">        hm.put(<span class="keyword">new</span> Person(<span class="string">"rose"</span>, <span class="number">18</span>), <span class="string">"1002"</span>);</span><br><span class="line">        hm.put(<span class="keyword">new</span> Person(<span class="string">"lucy"</span>, <span class="number">19</span>), <span class="string">"1003"</span>);</span><br><span class="line">        hm.put(<span class="keyword">new</span> Person(<span class="string">"hmm"</span>, <span class="number">17</span>), <span class="string">"1004"</span>);</span><br><span class="line">        hm.put(<span class="keyword">new</span> Person(<span class="string">"ll"</span>, <span class="number">17</span>), <span class="string">"1005"</span>);</span><br><span class="line">        System.out.println(hm);</span><br><span class="line">        System.out.println(hm.put(<span class="keyword">new</span> Person(<span class="string">"rose"</span>, <span class="number">18</span>), <span class="string">"1006"</span>));</span><br><span class="line">        Set&lt;Map.Entry&lt;Person,String&gt;&gt; entrySet =hm.entrySet();</span><br><span class="line">        Iterator&lt;Map.Entry&lt;Person,String&gt;&gt; it= entrySet.iterator();</span><br><span class="line">        <span class="keyword">while</span>  (it.hasNext())</span><br><span class="line">        &#123;</span><br><span class="line">            Map.Entry&lt;Person,String&gt; next=it.next();</span><br><span class="line">            Person key =next.getKey();</span><br><span class="line">            String value=next.getValue();</span><br><span class="line">            System.out.println(key+ <span class="string">"="</span> +value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span>  String name;</span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">int</span> age;</span><br><span class="line">    Person()</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Person)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Person person = (Person) o;</span><br><span class="line">        <span class="keyword">return</span> getAge() == person.getAge() &amp;&amp;</span><br><span class="line">                getName().equals(person.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(getName(), getAge());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* out </span></span><br><span class="line"><span class="comment">&#123;Person&#123;name='ll', age=17&#125;=1005, Person&#123;name='jack', age=20&#125;=1001, Person&#123;name='hmm', age=17&#125;=1004, Person&#123;name='lucy', age=19&#125;=1003, Person&#123;name='rose', age=18&#125;=1002&#125;</span></span><br><span class="line"><span class="comment">1002</span></span><br><span class="line"><span class="comment">Person&#123;name='ll', age=17&#125;=1005</span></span><br><span class="line"><span class="comment">Person&#123;name='jack', age=20&#125;=1001</span></span><br><span class="line"><span class="comment">Person&#123;name='hmm', age=17&#125;=1004</span></span><br><span class="line"><span class="comment">Person&#123;name='lucy', age=19&#125;=1003</span></span><br><span class="line"><span class="comment">Person&#123;name='rose', age=18&#125;=1006</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h2><p>TreeMap的排序，TreeMap 可以对集合中的键进行排序，如何实现对键的排序？</p><h3 id="方式1：-元素自身具备比较性"><a href="#方式1：-元素自身具备比较性" class="headerlink" title="方式1： 元素自身具备比较性"></a>方式1： 元素自身具备比较性</h3><p>和TreeSet一样原理，需要让存储在键位置的对象实现Comparable接口。重写compareTo方法，也就是让元素自身具备比较性，这种方式叫做元素的自然排序也叫默认排序。</p><h3 id="方式2：容器具备比较性"><a href="#方式2：容器具备比较性" class="headerlink" title="方式2：容器具备比较性"></a>方式2：容器具备比较性</h3><p>当元素自身不具备比较性，或者自身具备的比较性不是所需要的，那么此时可以让<strong>容器自身具备</strong>，需要定义一个类<strong>实现接口Compatator，重写compare方法，并将该接口的子类实例对象作为参数传递给TreeMap集合的构造方法。</strong></p><p>注意：当Comparable比较方式和Comparator比较方式同时存在时，以Comparator的比较方式为主。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This program demonstrates</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Alita Alice</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: Created in 22:09 2020/5/10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       TreeMap&lt;String,Integer&gt; tree=<span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">        tree.put(<span class="string">"张三"</span>,<span class="number">19</span>);</span><br><span class="line">        tree.put(<span class="string">"李四"</span>,<span class="number">20</span>);</span><br><span class="line">        tree.put(<span class="string">"王五"</span>,<span class="number">21</span>);</span><br><span class="line">        tree.put(<span class="string">"赵留"</span>,<span class="number">21</span>);</span><br><span class="line">        System.out.println(tree);</span><br><span class="line">        System.out.println(<span class="string">"张三"</span>.compareTo(<span class="string">"李四"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义元素排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This program demonstrates</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Alita Alice</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: Created in 22:09 2020/5/10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">     TreeMap&lt;Person,String&gt; hm=<span class="keyword">new</span> TreeMap&lt;Person, String&gt;(<span class="keyword">new</span> MyComparator());<span class="comment">//该接口的子类实例对象作为参数传递给TreeMap集合的构造方法。</span></span><br><span class="line">        hm.put(<span class="keyword">new</span> Person(<span class="string">"jack"</span>,<span class="number">20</span>),<span class="string">"1001"</span>);</span><br><span class="line">        hm.put(<span class="keyword">new</span> Person(<span class="string">"rose"</span>, <span class="number">18</span>), <span class="string">"1002"</span>);</span><br><span class="line">        hm.put(<span class="keyword">new</span> Person(<span class="string">"lucy"</span>, <span class="number">19</span>), <span class="string">"1003"</span>);</span><br><span class="line">        hm.put(<span class="keyword">new</span> Person(<span class="string">"hmm"</span>, <span class="number">17</span>), <span class="string">"1004"</span>);</span><br><span class="line">        System.out.println(hm);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Set&lt;Map.Entry&lt;Person,String&gt;&gt; entrySet=hm.entrySet();</span><br><span class="line">        Iterator&lt;Map.Entry&lt;Person,String&gt;&gt; it=entrySet.iterator();</span><br><span class="line">        <span class="keyword">while</span>  (it.hasNext())</span><br><span class="line">        &#123;</span><br><span class="line">            Map.Entry&lt;Person,String&gt; next=it.next();</span><br><span class="line">            Person key=next.getKey();</span><br><span class="line">            String value=next.getValue();</span><br><span class="line">            System.out.println(key+ <span class="string">"="</span> +value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Person</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Person p1,Person p2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p1.getAge()&gt;p2.getAge())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p1.getAge()&lt;p2.getAge())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p1.getName().compareTo(p2.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Person</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">  Person()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Person)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Person person = (Person) o;</span><br><span class="line">        <span class="keyword">return</span> getAge() == person.getAge() &amp;&amp;</span><br><span class="line">                getName().equals(person.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(getName(), getAge());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Person p)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(<span class="keyword">this</span>.age&gt;p.age) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.age&lt;p.age)</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name.compareTo(p.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* out</span></span><br><span class="line"><span class="comment">&#123;Person&#123;name='jack', age=20&#125;=1001, Person&#123;name='lucy', age=19&#125;=1003, Person&#123;name='rose', age=18&#125;=1002, Person&#123;name='hmm', age=17&#125;=1004&#125;</span></span><br><span class="line"><span class="comment">Person&#123;name='jack', age=20&#125;=1001</span></span><br><span class="line"><span class="comment">Person&#123;name='lucy', age=19&#125;=1003</span></span><br><span class="line"><span class="comment">Person&#123;name='rose', age=18&#125;=1002</span></span><br><span class="line"><span class="comment">Person&#123;name='hmm', age=17&#125;=1004</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>注意：Set元素不可重复，Map的键不可重复</p><p>​           如果存入重复元素如何处理?</p><p>Set元素重复元素不能存入add方法，返回false;</p><p>Map的重复键将覆盖旧键，将旧值返回。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内部类</title>
      <link href="/2020/05/08/%E5%86%85%E9%83%A8%E7%B1%BB/"/>
      <url>/2020/05/08/%E5%86%85%E9%83%A8%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>本章介绍JAVA内部类</p></blockquote><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h1 id="JAVA内部类"><a href="#JAVA内部类" class="headerlink" title="JAVA内部类"></a>JAVA内部类</h1><h2 id="为什么需要内部类"><a href="#为什么需要内部类" class="headerlink" title="为什么需要内部类"></a>为什么需要内部类</h2><ul><li>内部类可以对同一个包中的其他类隐藏</li><li>内部类方法可以访问定义这个类的作用域中的数据，包括原有私有的数据。</li></ul><p>内部类的特点：</p><ul><li><p>一个内部类方法可以访问自身的数据字段</p></li><li><p>可以访问创建它的外围类对象的数据字段</p><p>示例：</p></li></ul><h2 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h2>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TalkingClock</span> </span>&#123;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">int</span> interval;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">boolean</span> beep;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="title">TalkingClock</span><span class="params">(<span class="keyword">int</span> interval ,<span class="keyword">boolean</span> beep)</span></span></span><br><span class="line"><span class="function">      </span>&#123;&#125;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">          </span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// an inner class</span></span><br><span class="line">      <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimePrinter</span> <span class="keyword">implements</span> <span class="title">ActionListener</span></span></span><br><span class="line"><span class="class">      </span>&#123;</span><br><span class="line">          <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent event)</span></span></span><br><span class="line"><span class="function">          </span>&#123;</span><br><span class="line">              System.out.println(<span class="string">"at the tone,the time is"</span>+Insant.ofEpochMilli(event.getWhen()));</span><br><span class="line">              <span class="keyword">if</span>(beep) Toolkit.getDefaultToolkit().beep();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  TimePrinter类没有实例字段或者名为beep的对象。</p><p>  实际上为此，<strong>内部类对象总有一个隐式引用，指向创建它的外部类对象。</strong></p><p>​       但是这个引用在内部类的定义中是不可见的。我们将外围类对象的引用称为outer</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent event)</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">          System.out.println(<span class="string">"at the tone,the time is"</span>+Insant.ofEpochMilli(event.getWhen()));</span><br><span class="line">          <span class="keyword">if</span>(outer.beep) Toolkit.getDefaultToolkit().beep();</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><h3 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// an inner class</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TimePrinter</span> <span class="keyword">implements</span> <span class="title">ActionListener</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">       <span class="function"><span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent event)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"at the tone,the time is"</span>+Insant.ofEpochMilli(event.getWhen()));</span><br><span class="line">            <span class="keyword">if</span>(beep) Toolkit.getDefaultToolkit().beep();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> listener =<span class="keyword">new</span> TimePrinter();</span><br><span class="line">    <span class="keyword">var</span> timer=<span class="keyword">new</span> Timer(interval,listener);</span><br><span class="line">    timer.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在示例代码中，只是在start方法中创建这个类型的对象时使用了一次。</p><p>当遇到这类情况时，可以在一个方法中局部的定义这个类。</p><ul><li><p>声明局部类时不能有访问说明符（即public 或者private)</p></li><li><p>局部类的作用域被限定在声明这个局部类的块中</p></li><li><p>局部类的优点: 对外部世界完全隐藏。除了start()方法外，没有任何方法知道TimePrinter类的存在。</p></li><li><p>局部类不仅可以访问外部类的字段，还可以访问局部变量。（必须是事实最终变量）它们一旦赋值就绝对不会改变。</p><h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><p>有时候我为了免去给内部类命名，便倾向于使用匿名内部类，因为它没有名字。匿名内部类的使用需要注意以下几个地方：</p><ul><li>匿名内部类是没有访问修饰符的；</li></ul></li></ul><ul><li>匿名内部类是没有构造方法的 (因为匿名内部类连名字都没有)；</li></ul><ul><li>定义匿名内部类的前提是，内部类必须是继承一个类或者实现接口，格式为 new 父类或者接口(){子类的内容(如函数等)}。也就是说，匿名内部类最终提供给我们的是一个匿名子类的对象，例如：</li></ul>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例 1</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbsDemo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">3</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">function</span><span class="params">()</span><span class="comment">//可调用函数</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> AbsDwmo()<span class="comment">//匿名内部类</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"x==="</span>+x);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">abc</span><span class="params">()</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"haha"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.abc();  <span class="comment">//匿名内部类调用函数,匿名内部类方法只能调用一次</span></span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例 2</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Inner</span> </span>&#123;    <span class="comment">//注释后，编译时提示类Inner找不到 </span></span><br><span class="line">  <span class="function">String <span class="title">getName</span><span class="params">()</span></span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Inner <span class="title">getInner</span><span class="params">(<span class="keyword">final</span> String name, String city)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Inner() &#123; </span><br><span class="line">        <span class="keyword">private</span> String nameStr = name; </span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123; </span><br><span class="line">            <span class="keyword">return</span> nameStr; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">    Outer outer = <span class="keyword">new</span> Outer(); </span><br><span class="line">    Inner inner = outer.getInner(<span class="string">"Inner"</span>, <span class="string">"gz"</span>); </span><br><span class="line">    System.out.println(inner.getName()); </span><br><span class="line"></span><br><span class="line">    System.out.println(inner <span class="keyword">instanceof</span> Inner);  <span class="comment">//匿名内部类实质上是一个匿名子类的对象</span></span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">    Inner</span></span><br><span class="line"><span class="comment">  true</span></span><br><span class="line"><span class="comment">  */</span><span class="comment">//:~ </span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="内部类概述"><a href="#内部类概述" class="headerlink" title="内部类概述"></a>内部类概述</h2><p>　多重继承指的是一个类可以同时从多于一个的父类那里继承行为和特征，然而我们知道Java为了保证数据安全，它只允许单继承。但有时候，我们确实是需要实现多重继承，而且现实生活中也真正地存在这样的情况，比如遗传：我们即继承了父亲的行为和特征也继承了母亲的行为和特征。可幸的是，Java 提供了两种方式让我们曲折地来实现多重继承：接口和内部类。事实上，实现多重继承是内部类的一个极其重要的应用。除此之外，内部类还可以很好的实现隐藏(例如，私有成员内部类)。内部类共有四种类型，即成员内部类、静态内部类、局部内部类和匿名内部类。特别地，</p><p><strong>成员内部类：成员内部类是外围类的一个成员，是 依附于外围类的，所以，只有先创建了外围类对象才能够创建内部类对象。也正是由于这个原因，成员内部类也不能含有 static 的变量和方法；</strong></p><p><strong>静态内部类：静态内部类，就是修饰为 static 的内部类，该内部类对象 不依赖于外部类对象，就是说我们可以直接创建内部类对象，但其只可以直接访问外部类的所有静态成员和静态方法；</strong></p><p><strong>局部内部类：局部内部类和成员内部类一样被编译，只是它的 作用域发生了改变，它只能在该方法和属性中被使用，出了该方法和属性就会失效；</strong></p><p><strong>匿名内部类：定义匿名内部类的前提是，内部类必须要继承一个类或者实现接口，格式为 new 父类或者接口(){定义子类的内容(如函数等)}。也就是说，匿名内部类最终提供给我们的是一个匿名子类的对象。</strong></p>]]></content>
      
      
      <categories>
          
          <category> JAVASE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVASE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实习</title>
      <link href="/2020/05/08/%E5%AE%9E%E4%B9%A0/"/>
      <url>/2020/05/08/%E5%AE%9E%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>本章介绍实习</p></blockquote><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>本日是5.8日  6.15日正式开始面试</p><p>需要学习的内容有：</p><p>1 数据结构</p><p>2 JAVA集合</p><p>3 JAVA并发</p><p>4 JVM</p><p>5 mysql</p><p>6 Spring</p><p>7 计网和操作系统面经内容。</p><p>8 redis了解。</p><ul><li><p>JAVASE 数据结构算法 mysql 这三个是一类</p></li><li><p>设计模式 JVM  这两个是一类  能大概谈谈每种设计模式是什么就可以了</p></li><li><p>剑指offer 这个单独一类 </p></li></ul><p>先定位好去什么样的公司吧，如果想试试大厂，那么后端大数据都无所谓，基础要非常好，</p><p>然后大数据/后端 一两个框架搞熟，如果去那种普通的公司，算法啥的，简单看看就行，多搞点项目经验，对框架好熟悉</p><p>java做初+中的，mysql建议全做，不会的看答案，然后自己写</p><p>做个SSM和Boot的CRUD项目就可以了。<br>            不要花太多精力在上面。<br>几天时间吧。<br>boot估计一天不到。<br>主要是熟悉整个流程。<br>找个手感<br><a href="https://leetcode-cn.com/">https://leetcode-cn.com/</a><br>没事刷刷题<br>java做初+中的，mysql建议全做，不会的看答案，然后自己写</p><ul><li>2018~2019 </li></ul><p>​      拿不出就在网上找，，找个牛批的项目，学习一下，，思考一下技术选型，架构，过程中遇到过什么难题等等，，。没做过不重要，会扯就行。crud太low了。，找个牛批的项目</p><p>不用等到完全准备好才投简历，，因为一般人永远觉得自己还没准备好，，，准备个差不多就投简历，，，就算通过不了，也能及时发现自己的不足，然后补上</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂谈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql联结表</title>
      <link href="/2020/05/08/mysql%E8%81%94%E7%BB%93%E8%A1%A8/"/>
      <url>/2020/05/08/mysql%E8%81%94%E7%BB%93%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>本章介绍联结以及高级联结。</p></blockquote><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h2 id="创建联结"><a href="#创建联结" class="headerlink" title="创建联结"></a>创建联结</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT vent_name,prod_name,prod_price </span><br><span class="line">FROM vendors ,products </span><br><span class="line">WHERE vendors.vend_id=products.vend_id;</span><br><span class="line">ORDER BY vend_name,prod_name ;</span><br></pre></td></tr></table></figure><h2 id="内部联结"><a href="#内部联结" class="headerlink" title="内部联结"></a>内部联结</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT vend_name , prod_name , prod_price FROM vendors INNER JOIN products ON vendors.vend_id =products.vend_id ;</span><br></pre></td></tr></table></figure><p>此时使用的是INNER JOIN 联结条件用的是ON</p><p>联结多个表：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT prod_name,vend_name,prod_price,quantity FROM orderitems,products,vendors WHERE products.vend_id =vendors.vend_id AND orderitems.prod_id =products.prod_id AND order_num =<span class="number">20005</span>;</span><br></pre></td></tr></table></figure><h2 id="创建高级联结"><a href="#创建高级联结" class="headerlink" title="创建高级联结"></a>创建高级联结</h2><h3 id="使用表别名"><a href="#使用表别名" class="headerlink" title="使用表别名"></a>使用表别名</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SELECT <span class="title">Concat</span><span class="params">(RTrim(vend_name)，‘（’，RTrim（vend_country）,’）’)</span> AS vend_title FROM vendors ORDER BY vend_name</span>;</span><br></pre></td></tr></table></figure><h3 id="内部联结："><a href="#内部联结：" class="headerlink" title="内部联结："></a>内部联结：</h3><p>它基于俩个表之间的相等测试</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT vend_name .prod_name,prod_price FROM vendors INNER JOIN products ON vendors.vend_id =produces.vend_id;</span><br></pre></td></tr></table></figure><h3 id="自联结：-引用别名，自己联结自己"><a href="#自联结：-引用别名，自己联结自己" class="headerlink" title="自联结： 引用别名，自己联结自己"></a>自联结： 引用别名，自己联结自己</h3><p>假如你发现某物品（其ID为DTNRT)存在问题，因此想知道生产该物品的供应商生产的其他物品是否也存在这些问题。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT p1.prod_id,p1.prod_name FROM products AS p1,products AS p2</span><br><span class="line">WHERE p1.vend_id =p2.vend_id AND p2.prod_id =’DTNTR’;</span><br></pre></td></tr></table></figure><p>因此products 表在from 子句中出现了俩次。虽然这是合法的，但是对products 的引用具有二义性。因此使用了别名。（用自联结而不用子查询。有时候处理联结要比处理查询要快的多）</p><h3 id="自然联结"><a href="#自然联结" class="headerlink" title="自然联结"></a>自然联结</h3><p><strong>自然联结的意思是排除多次出现，使每个列只返回一次。</strong></p><p><strong>我们建立的每个内部联结都是自然联结。</strong></p><p>示例通过对表使用通配符（SELECT *）对所有其他表的列使用明确的子集来完成的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT c.*,o.ordr_num,o.order_date,oi.prod_id,oi.quantity,OI.item_price FROM customers AS c,orders AS o,orderitems AS oi WHERE c.cust_id =o.cust_id AND oi.order_num =o.order_num</span><br><span class="line">AND prod_id =’FB’;</span><br></pre></td></tr></table></figure><p>通配符只对第一个表使用，所有其他列明确列出，但没有重复的列被检索出来。</p><h3 id="外部联结："><a href="#外部联结：" class="headerlink" title="外部联结："></a>外部联结：</h3><p><strong>许多联结将一个表中的行与另外一个表中的行相关联，但有时候会需要包含没有关联行的那些行，</strong>例如 可能需要使用联结来完成以下的工作：</p><ul><li>对每个客户下了多少订单进行计数，包括那些至今未下订单的客户。</li><li>列出所有产品以及订购数量，包括没有人订购的产品</li><li>计算平均销售规模，包括那些至今未下订单的客户</li></ul><p><strong>联结包含了那些在相关表中没有关联行的行，这种叫做外部联结</strong>     </p><p>内部联结检索所有客户及其订单：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT customers.cust_id,order.orders.order_num FROM customers INNER JOIN orders ON</span><br><span class="line">Customers.cust_id &#x3D;orders.cust_id;</span><br></pre></td></tr></table></figure><p>外部联结：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT customers.cust_id ,orders.order_num FROM customers LEFT OUTER JOIN oders </span><br><span class="line">ON customers.cust_id =orders.cust_id;</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cust_id   order_num</span><br><span class="line"> 10001      20005</span><br><span class="line"> 10001      20009</span><br><span class="line"> 10002       null</span><br><span class="line"> 10003       null</span><br></pre></td></tr></table></figure><p>此时必须要用RIGHT 或LEFT 关键字指定包括其所有行的表，如果是<strong>LEFT</strong>，就<strong>指出包括OUTER JOIN左边表的所有行</strong>。示例是包括（customers)表种所有行。</p><p>其实就是左外部联结和右外部联结</p><h3 id="使用带聚集函数的联结"><a href="#使用带聚集函数的联结" class="headerlink" title="使用带聚集函数的联结"></a>使用带聚集函数的联结</h3><p>使用了COUNT（）函数的联结</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT customers.cust_name, customers.cust_id,COUNT(orders.order_num) AS num_ord FROM customers INNER JOIN orders ON customers.cust_id &#x3D;orders.cust_id GROUP BY customers.cust_id;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT customers,cust_name,cusomers,cust_id,COUNT(orders,order_num)AS num_ord FROM customers LEFT OUTER JOIN orders ON customers.cust_id &#x3D;orders.cust_id  GROUP BY customers.cust_id;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>创建表和操控表</title>
      <link href="/2020/05/08/%E5%88%9B%E5%BB%BA%E8%A1%A8%E5%92%8C%E6%93%8D%E6%8E%A7%E8%A1%A8/"/>
      <url>/2020/05/08/%E5%88%9B%E5%BB%BA%E8%A1%A8%E5%92%8C%E6%93%8D%E6%8E%A7%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>本章介绍表的创建，更改和删除的基本知识。</p></blockquote><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>mysql更新和删除数据</title>
      <link href="/2020/05/07/mysql%E6%9B%B4%E6%96%B0%E5%92%8C%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE/"/>
      <url>/2020/05/07/mysql%E6%9B%B4%E6%96%B0%E5%92%8C%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>本章介绍如何利用UPDATA和DELETE语句进一步操控表数据</p></blockquote><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h2 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h2><ul><li>更新特定行</li><li>更新所有行 <strong>特别注意不要省略WHERE子句 稍不注意就会更新表中的所有行</strong></li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UPDATA customers SET cust_email ='elmer@gmail.com' WHERE cust_id =10005;</span><br></pre></td></tr></table></figure><p>更新多个列： 用逗号分隔</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UPDATE customers SET cust_name='The Fudds',</span><br><span class="line">cust_email='elmer@gmail.com'</span><br><span class="line">WHERE cust_id =<span class="number">10005</span>;</span><br></pre></td></tr></table></figure><h3 id="IGNORE关键字"><a href="#IGNORE关键字" class="headerlink" title="IGNORE关键字"></a>IGNORE关键字</h3><p>如果用UPDATE 语句更新多行，并且在更新这些行中的一行或多行时出现一个现错误，则整个UPDATE操作被取消。</p><p>为即使是发生错误，也继续进行更新可以使用<strong>IGNORE</strong>关键字</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UPDATE IGNORE customers...</span><br></pre></td></tr></table></figure><h2 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h2><ul><li>从表中删除特定的行</li><li>从表中删除所有行  <strong>不要省略WHERE子句</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE FROM customers WHERE cust_id =<span class="number">10006</span>;</span><br></pre></td></tr></table></figure><h3 id="更快的删除"><a href="#更快的删除" class="headerlink" title="更快的删除"></a>更快的删除</h3><p>如果想删除所有行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TRUNCATE TABLE</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql插入数据</title>
      <link href="/2020/05/07/mysql%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE/"/>
      <url>/2020/05/07/mysql%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>本章介绍如何利用SQL的INSERT语句将数据插入到表中</p></blockquote><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h2 id="插入到完整的行"><a href="#插入到完整的行" class="headerlink" title="插入到完整的行"></a>插入到完整的行</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO Customers</span><br><span class="line">VALUES(<span class="literal">NULL</span>,</span><br><span class="line">       'PEP E.LAPEW',</span><br><span class="line">       '100 MAIN STREET',</span><br><span class="line">        'Los Angeles',</span><br><span class="line">         'CA',</span><br><span class="line">        '90046',</span><br><span class="line">         'USA',</span><br><span class="line">          <span class="literal">NULL</span>,</span><br><span class="line">          <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><p>编写INSERT语句的更加安全（不过更加繁琐）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO customers(cust_name,cust_address,cust_city,cust_state,cust_zip,cust_country,cust_contact,cust_email)</span><br><span class="line">VALUSES(&#39;PEP E.LAPEW&#39;,</span><br><span class="line">       &#39;100 MAIN STREET&#39;,</span><br><span class="line">        &#39;Los Angeles&#39;,</span><br><span class="line">         &#39;CA&#39;,</span><br><span class="line">        &#39;90046&#39;,</span><br><span class="line">         &#39;USA&#39;,</span><br><span class="line">          NULL,</span><br><span class="line">          NULL&#39;);</span><br></pre></td></tr></table></figure><h3 id="省略列"><a href="#省略列" class="headerlink" title="省略列"></a>省略列</h3><ul><li>该列定义为允许null值</li><li>在表定义中给出默认值</li></ul><h3 id="提高整体性能"><a href="#提高整体性能" class="headerlink" title="提高整体性能"></a>提高整体性能</h3><p>如果数据检索是最重要的，那你可以通过在INSERT INTO 之间添加关键字</p><p>LOW_PRIORITY 指示Mysql降低INSERT语句的优先级</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT LOW_PRIORITY INTO</span><br></pre></td></tr></table></figure><h2 id="插入多个行"><a href="#插入多个行" class="headerlink" title="插入多个行"></a>插入多个行</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">INSERT INTO <span class="title">customers</span><span class="params">(cust_name,cust_address,cust_city,cust_state,cust_zip,cust_country,cust_contact,cust_email)</span></span></span><br><span class="line">VALUSES('PEP E.LAPEW',</span><br><span class="line">       '100 MAIN STREET',</span><br><span class="line">        'Los Angeles',</span><br><span class="line">         'CA',</span><br><span class="line">        '90046',</span><br><span class="line">         'USA',</span><br><span class="line">          <span class="literal">NULL</span>,</span><br><span class="line">          NULL'),</span><br><span class="line">       ('PEP E.LAPEW',</span><br><span class="line">       '100 MAIN STREET',</span><br><span class="line">        'Los Angeles',</span><br><span class="line">         'CA',</span><br><span class="line">        '90046',</span><br><span class="line">         'USA',</span><br><span class="line">          <span class="literal">NULL</span>,</span><br><span class="line">          NULL');</span><br></pre></td></tr></table></figure><p>其中单条INSERT语句有多组值，每组值用一对圆括号括起来，用逗号分隔。</p><h3 id="插入检索出的数据"><a href="#插入检索出的数据" class="headerlink" title="插入检索出的数据"></a>插入检索出的数据</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">INSERT INTO <span class="title">customers</span><span class="params">(cust_id,cust_name,cust_address,cust_city,cust_state,cust_zip,cust_country,cust_contact,cust_email)</span></span></span><br><span class="line">SELECT cust_id,cust_name,cust_address,cust_city,cust_state,cust_zip,cust_country,cust_contact,cust_email FROM custnew;</span><br></pre></td></tr></table></figure><p>这个例子中INSERT SELECT 从custnew中将所有数据导入到customer中。</p><p><strong>其实MYSQL不关心SELECT返回的列名，它使用的是列的位置，因此SELECT中的第一列用来填充表列中指定的第一列</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql全文本搜索</title>
      <link href="/2020/05/07/mysql%E5%85%A8%E6%96%87%E6%9C%AC%E6%90%9C%E7%B4%A2/"/>
      <url>/2020/05/07/mysql%E5%85%A8%E6%96%87%E6%9C%AC%E6%90%9C%E7%B4%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>Mysql 全文本搜索用法实例及详解。</p></blockquote><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h1 id="启用全文本搜索支持"><a href="#启用全文本搜索支持" class="headerlink" title="启用全文本搜索支持"></a>启用全文本搜索支持</h1><p>CREATE  TABLE 接受FULLTEXT子句</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE productsnotes</span><br><span class="line">(</span><br><span class="line"> note_id <span class="keyword">int</span> NOT <span class="literal">NULL</span> AUTO_INCREMENT,  <span class="comment">/* auto increment 自动递增主键字段 */</span></span><br><span class="line"> prod_id <span class="keyword">char</span>(<span class="number">10</span>)  NOT <span class="literal">NULL</span>,</span><br><span class="line"> note_date datetime NOT <span class="literal">NULL</span>,</span><br><span class="line"> note_text  <span class="built_in">text</span>  <span class="literal">NULL</span>,</span><br><span class="line"> PRIMARY KEY(note_id),</span><br><span class="line"> FULLTEXT(note_text)</span><br><span class="line"> ) ENGINE=MyISAM;</span><br></pre></td></tr></table></figure><p>这条CREATE TABLE 语句定义表productnotes 并列出它所包含的列即可。这些列中有一个名为note_text 的列，为了进行全文本搜素，MySQL根据子句FULLTEXT(note_text)的指示对它进行索引。<br>FULLTEXT索引单个列，如果需要也可以指定多个列。</p><h2 id="在索引之后，使用俩个函数Match-和Against-执行全文本搜素"><a href="#在索引之后，使用俩个函数Match-和Against-执行全文本搜素" class="headerlink" title="在索引之后，使用俩个函数Match() 和Against()执行全文本搜素"></a>在索引之后，使用俩个函数Match() 和Against()执行全文本搜素</h2><p>其中Match()指定被搜索的列，Against()指定要使用的搜索表达式</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT note_text FROM productnotes WHERE Match(not_text) Against('rabbit');</span><br></pre></td></tr></table></figure><p>Match(note_text )指示MySQL针对指定的列进行搜索，Against(‘rabbit’) 指定词rabbit作为搜索文本。</p><p>使用完整的Match()说明，传递给Match()的值必须与FULLTEXT()定义中的相同。除非使用BINARY 方式，否则全文本搜索不区分大小写。</p><ul><li>搜索页可以简单地用LIKE子句完成</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT note_text FROM productnotes WHERE note_text LIKE '%rabbit%';</span><br></pre></td></tr></table></figure><ul><li>但是却与全文本搜索，各有优劣</li></ul><ol><li></li><li>在使用全文本搜索时就会对此结果排序，但是like却不会。</li></ol><h1 id="全文本布尔操作符"><a href="#全文本布尔操作符" class="headerlink" title="全文本布尔操作符"></a>全文本布尔操作符</h1><ul><li>+包含，词必须存在</li></ul><ul><li>-排除，词必须不出现</li><li>大于号 包含，而且增加等级值</li><li>&lt;包含，且减少等级值</li><li>() 把词组成子表达式(允许这些子表达式作为一个组被包含，排除，排列等）</li><li>~取消一个词的排序值</li></ul><ul><li>*词尾的通配符</li><li>“” 定义一个短语</li></ul><h2 id="布尔文本搜索"><a href="#布尔文本搜索" class="headerlink" title="布尔文本搜索"></a>布尔文本搜索</h2><p>布尔方式搜索，添加布尔操作符</p><p>IN BOOLEAN MODE</p><ul><li><p>举几个例子：</p></li><li><pre><code class="c">1 SELECT note_text FROM productnotes WHERE Match(note_text) Against('+rabbit +bait' IN BOOLEAN MODE);<span class="comment">/*这个搜索匹配包含词rabbit和bait的行 */</span>2 SELECT note_text FROM productnotes WHERE Match(note_text) Against('rabbit bait' IN BOOLEAN MODE);<span class="comment">/*没有指定操作符，这个搜索匹配包含rabbit 和bait中的至少一个词的行。*/</span>3 SELECT note_text FROM productnotes WHERE Match(note_text) Against('"rabbit bait"' IN BOOLEAN MODE);4 SELECT note_text FROM productnotes WHERE Match(note_text) Against ('&gt;rabbit &lt;carrot' IN BOOLEAN MODE);</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树</title>
      <link href="/2020/05/07/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2020/05/07/%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>本文。</p></blockquote><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h2 id="二叉树的特点"><a href="#二叉树的特点" class="headerlink" title="二叉树的特点"></a>二叉树的特点</h2><ul><li><p>每个结点最多有俩颗子树。所以二叉树中不存在大于2的结点。</p></li><li><p>左子树和右子树是有顺序的，次序不能随意颠倒。</p></li><li><p>即使树中某结点只有一颗子树，也要区分它是左子树还是右子树</p><h3 id="二叉树的5种形态"><a href="#二叉树的5种形态" class="headerlink" title="二叉树的5种形态"></a>二叉树的5种形态</h3><ul><li>空二叉树</li><li>只有一个根结点</li><li>根节点只有左子树</li><li>根节点只有右子树</li><li>根节点既有左子树又有右子树</li></ul></li></ul><h2 id="特殊二叉树"><a href="#特殊二叉树" class="headerlink" title="特殊二叉树"></a>特殊二叉树</h2><ol><li><p>斜树</p><p>所有结点都只有左子树的二叉树叫做左斜树</p><p>所有结点都只有右子树的二叉树叫做右斜树</p><p>俩者统称为斜树</p></li><li><p>满二叉树</p><p>在一颗二叉树中，如果所有分支结点都存在左子树和右子树，并且所有叶子都在同一层上，这样的二叉树叫做满二叉树</p></li><li><p>完全二叉树</p><p>对一颗具有n个结点的二叉树按照层序编号，如果编号为i（1&lt;=i&lt;=n)的结点与同样深度的满二叉树中编号为i的结点在二叉树中位置完全相同，则这颗二叉树称为完全二叉树。</p></li></ol><h2 id="二叉树的性质"><a href="#二叉树的性质" class="headerlink" title="二叉树的性质"></a>二叉树的性质</h2><h3 id="二叉树性质1"><a href="#二叉树性质1" class="headerlink" title="二叉树性质1"></a>二叉树性质1</h3><p>性质1：在二叉树的第i层上至多有2^(i-1) 个结点。（i&gt;=1)</p><h3 id="二叉树性质2"><a href="#二叉树性质2" class="headerlink" title="二叉树性质2"></a>二叉树性质2</h3><p>性质2：深度为k的二叉树至多有2^(k) -1个结点 （k&gt;=1)   (<strong>结点的总量</strong>)</p><h3 id="二叉树性质3"><a href="#二叉树性质3" class="headerlink" title="二叉树性质3"></a>二叉树性质3</h3><p>性质3：对于任何一颗二叉树T，如果其终端结点数为n0，度为2的结点数为n2，则n0=n2+1</p><h3 id="二叉树性质4"><a href="#二叉树性质4" class="headerlink" title="二叉树性质4"></a>二叉树性质4</h3><p>性质4： 具有n个结点的完全二叉树的深度为[log2 n]+1 ([x]表示不大于x的最大整数)</p><h3 id="二叉树性质5"><a href="#二叉树性质5" class="headerlink" title="二叉树性质5"></a>二叉树性质5</h3><p><strong>性质5： 如果对一颗有n个结点的完全二叉树（其深度为[log2 n]+1)的结点按层序编号，对任一结点i（1&lt;=i&lt;=n)</strong></p><p><strong>有</strong></p><ol><li><strong>如果i=1,则结点i是二叉树的根，无双亲;如果i&gt;1,则其双亲是结点[i/2]</strong></li><li><strong>如果2i&gt;n,则结点i无左孩子（结点i为叶子结点）；否则其左孩子是结点2i</strong></li><li><strong>如果2i+1&gt;n,则结点i无右孩子；否则其右孩子是结点2i+1</strong></li></ol><h2 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h2><h4 id="二叉树的顺序存储结构"><a href="#二叉树的顺序存储结构" class="headerlink" title="二叉树的顺序存储结构"></a>二叉树的顺序存储结构</h4><p>用一维数组存储二叉树的结点，并且结点的位置，也就是数组的下标要能体现结点之间的逻辑关系。</p><p>一般来说顺序存储用于完全二叉树</p><h4 id="二叉链表"><a href="#二叉链表" class="headerlink" title="二叉链表"></a>二叉链表</h4><p>二叉树的每个结点最多有俩个孩子。所以为它设计一个数据域，和俩个指针域是比较自然的想法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lchid -- data --rchild</span><br></pre></td></tr></table></figure><p>lchild 和 rchild 都是指针域</p><p><strong>二叉树的二叉链表结点结构定义</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef struct BiTNode</span><br><span class="line">&#123;</span><br><span class="line">   TElemType data; &#x2F;&#x2F;结点数据</span><br><span class="line">   struct BiTNode *lchild ,*rchild;</span><br><span class="line">&#125; BiTNode, *BiTree;</span><br></pre></td></tr></table></figure><p>图示：</p><h2 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h2><p>二叉树的定义：</p><p><strong>二叉树的遍历是指从根节点出发，按照某种次序依次访问二叉树中的所有结点，使得每个结点被访问且仅被访问一次。</strong></p><h3 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h3><p>规则：若二叉树为空，则空操作返回，否则先访问根结点，然后前序遍历左子树，再前序遍历右子树。</p><p>如图：</p><p><img src="TIM%E5%9B%BE%E7%89%8720200510112558.png" alt=""></p><h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><p>规则： 若树为空，则空操作返回，否则从根节点开始（注意并不是先访问根节点），中序遍历根节点的左子树，然后是访问根节点，最后中序遍历右子树。</p><p><img src="TIM%E5%9B%BE%E7%89%8720200510113141.png" alt=""></p><h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><p>规则： 若树为空，则空操作返回，否则从左到右先叶子后结点的方式遍历访问左右子树，最后是访问根结点。</p><p>图示：</p><p><img src="TIM%E5%9B%BE%E7%89%8720200510113343.png" alt=""></p><h3 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h3><p>规则：若树为空，则空操作返回。</p><p>否则从树的第一层，也就是根节点开始访问，从上而下逐层遍历，在同一层中，按从左到右的顺序对结点逐个访问。</p><p><img src="TIM%E5%9B%BE%E7%89%8720200510113800.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DataStructure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树</title>
      <link href="/2020/05/07/%E6%A0%91/"/>
      <url>/2020/05/07/%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>树的相关概念</p></blockquote><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h2 id="树的相关概念"><a href="#树的相关概念" class="headerlink" title="树的相关概念"></a>树的相关概念</h2><h3 id="度"><a href="#度" class="headerlink" title="度"></a>度</h3><ul><li>结点拥有的子树树称为结点的度</li><li>度为0的结点称为叶结点（Leaf）或者终端结点。</li><li>度不为0的结点称为非终端结点或者分支结点</li><li>树的度是树内各结点度的最大值</li></ul><h3 id="深度（Depth-或高度"><a href="#深度（Depth-或高度" class="headerlink" title="深度（Depth)或高度"></a>深度（Depth)或高度</h3><ul><li>层次：结点的层次从根开始定义起，根为第一层，根的孩子为第二层，以此类推</li><li>树中结点的最大层次被称为树的深度（Depth）或者高度。</li></ul><h3 id="有序树和无序树"><a href="#有序树和无序树" class="headerlink" title="有序树和无序树"></a>有序树和无序树</h3><p>如果将树中结点的各子树看成从左至右是由次序的，不能互换的，那么该树为有序树，否则为无序树。</p><h3 id="森林"><a href="#森林" class="headerlink" title="森林"></a>森林</h3><p>森林是m（m&gt;=0)颗互不相交的树的集合。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DataStructure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习方法</title>
      <link href="/2020/05/07/%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"/>
      <url>/2020/05/07/%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>学习方法</p></blockquote><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><ul><li>慢一点，你理解的越多，需要记的就越少</li><li>勤做练习，自己记笔记</li><li>上床睡觉之前就不要再看别的书了，或者至少不能再看其他有难度的东西</li><li>要喝水，要多喝水</li><li>大声说出来</li><li>听听你的大脑怎么说（注意大脑是不是负荷太重）</li><li>要有点感觉（真正融入到书的故事中）</li></ul>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂谈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链表</title>
      <link href="/2020/05/07/%E9%93%BE%E8%A1%A8/"/>
      <url>/2020/05/07/%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>线性表的链式存储结构详解</p></blockquote><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>单链表存储状态图示：</p><p>Node由存放数据元素的数据域和存放后继结点地址的指针域组成。</p><p>头结点的数据域可以不存储任何信息。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">ElemType data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;Node;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">LinkList</span>;</span></span><br></pre></td></tr></table></figure><p>假设p是指向线性表第i个元素的指针，则该结点ai的数据域 可以用p-&gt;data 来表示</p><p>结点ai的指针域用p-&gt;next来表示。p-&gt;next指向第i-1个元素，即指向ai+1的指针。即p-&gt;data=ai</p><p>那么p-&gt;next-&gt;data=ai+1</p><p><img src="%E9%93%BE%E8%A1%A801.png" alt=""></p><h2 id="单链表的读取"><a href="#单链表的读取" class="headerlink" title="单链表的读取"></a>单链表的读取</h2><p>算法思路：<br>从第一个头结点开始，指针域p-&gt; next一直向下指向第i个元素的指针域。</p><ol><li>声明指针p指向链表的第一个结点 ，初始化从1开始</li><li>当j&lt;i时就遍历链表，p不断向后移动，j++</li><li>当链表末尾p为空时，则说明第i个结点不存在</li><li>若查找成功，那么返回结点p的数据。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">GetElem</span><span class="params">(LinkList L,<span class="keyword">int</span> i,ElemType *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> j;</span><br><span class="line">  LinkList p;</span><br><span class="line">  p=L-&gt;next;</span><br><span class="line">  j=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(p&amp;&amp;j&lt;i)</span><br><span class="line">  &#123;</span><br><span class="line">  p=p-&gt;next;</span><br><span class="line">  j++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(!p || j&gt;i)</span><br><span class="line">  <span class="keyword">return</span> ERROR；</span><br><span class="line">  *e=p-&gt;data;</span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="单链表的插入与删除"><a href="#单链表的插入与删除" class="headerlink" title="单链表的插入与删除"></a>单链表的插入与删除</h2><h3 id="单链表插入"><a href="#单链表插入" class="headerlink" title="单链表插入"></a>单链表插入</h3><p>思路：在俩节点之间再插入一个结点</p><p>图示：</p><p><img src="%E9%93%BE%E8%A1%A802.png" alt=""></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s-&gt;next=p-&gt;next;</span><br><span class="line">p-next=s;   <span class="comment">/*单链表插入标准语句 */</span></span><br></pre></td></tr></table></figure><p>实现插入操作的具体思路：</p><ol><li></li><li></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ListInsert</span><span class="params">(LinkList *L,<span class="keyword">int</span> i,ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(p&amp;&amp;j&lt;i)</span><br><span class="line">    &#123;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">        ++j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!p||j&gt;i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    s=(LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    s-&gt;data=e;</span><br><span class="line">    s-&gt;next=p-&gt;next;</span><br><span class="line">    p-&gt;next=s;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>malloc  函数，生成一个新的结点，其类型与Node一样的，其实质就是在内存中找一小块空地，准备用来存放数据e的s结点。</p><h2 id="单链表的删除："><a href="#单链表的删除：" class="headerlink" title="单链表的删除："></a>单链表的删除：</h2><p>图示：</p><p><img src="%E9%93%BE%E8%A1%A803.png" alt=""></p><p>实际上就是p-&gt;next=p-&gt;next-&gt;next;</p><p>如果用q来表示p-&gt;next即</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">q=p-&gt;next;</span><br><span class="line">p-&gt;next=q-&gt;next;</span><br></pre></td></tr></table></figure><p>思路：</p><p>具体实现代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ListDelete</span><span class="params">(LinkList *L,<span class="keyword">int</span> i,ElemType *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> j;</span><br><span class="line">LinkList p,q;</span><br><span class="line">p=*L;</span><br><span class="line">j=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(p-&gt;next &amp;&amp; j&lt;i)</span><br><span class="line">&#123;</span><br><span class="line">p=p-&gt;next;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!(p-&gt;next)||j&gt;i)</span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line">q=p-&gt;next;</span><br><span class="line">p-&gt;next=q-&gt;next;</span><br><span class="line">*e=q-&gt;data;</span><br><span class="line"><span class="built_in">free</span>(q);<span class="comment">/* 回收一个Node结点 */</span></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DataStructure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ArrayList和LinkedList</title>
      <link href="/2020/05/07/ArrayList%E5%92%8CLinkedList/"/>
      <url>/2020/05/07/ArrayList%E5%92%8CLinkedList/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>List集合包括List接口和List接口所有的实现类</p></blockquote><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h2 id="List接口定义的方法"><a href="#List接口定义的方法" class="headerlink" title="List接口定义的方法"></a>List接口定义的方法</h2><p>除了继承Collection外，List接口还有俩个重要的方法。</p><table><thead><tr><th>get(int index)</th><th>获得指定索引位置的元素</th></tr></thead><tbody><tr><td>set(int index,Object obj)</td><td>将集合中指定索引位置的对象修改为指定的对象</td></tr></tbody></table><h2 id="List接口的实现类"><a href="#List接口的实现类" class="headerlink" title="List接口的实现类"></a>List接口的实现类</h2><ul><li><p>ArrayList</p><p>实现了可变的数组，允许保存所有元素包括null .并且可以根据索引的位置对集合进行快速的随机访问，缺点是向指向的索引位置插入对象或删除对象时的速度较慢</p></li><li><p>LinkedList </p><p>采用链表的结构保存对象。优点是便于向集合中插入和删除对象</p><p>分别用ArrayList 和LinkedList来实例化集合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;E&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">List&lt;E&gt; list=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br></pre></td></tr></table></figure><p>E是合法的JAVA数据类型，也可以是字符串String</p><h2 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h2><p>1.接口实现：都实现了List接口，都是线性列表的实现</p><p>2.线程安全：都是线程不安全的</p><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>1.底层实现:ArrayList内部是数组实现，而LinkedList内部实现是双向链表结构</p><p>2.接口实现：ArrayList实现了RandomAccess可以支持随机元素访问，而LinkedList实现了Deque可以当做队列使用</p><p>3.性能：新增、删除元素时ArrayList需要使用到拷贝原数组，而LinkedList只需移动指针，查找元素 ArrayList支持随机元素访问,而LinkedList只能一个节点的去遍历</p></li></ul><p>下转<a href="https://www.jianshu.com/p/732b5294a985">https://www.jianshu.com/p/732b5294a985</a></p>]]></content>
      
      
      <categories>
          
          <category> JAVA集合 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>List接口</title>
      <link href="/2020/05/07/List%E6%8E%A5%E5%8F%A3/"/>
      <url>/2020/05/07/List%E6%8E%A5%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>List集合包括List接口和List接口所有的实现类</p></blockquote><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h2 id="List接口定义的方法"><a href="#List接口定义的方法" class="headerlink" title="List接口定义的方法"></a>List接口定义的方法</h2><p>除了继承Collection外，List接口还有俩个重要的方法。</p><table><thead><tr><th>get(int index)</th><th>获得指定索引位置的元素</th></tr></thead><tbody><tr><td>set(int index,Object obj)</td><td>将集合中指定索引位置的对象修改为指定的对象</td></tr></tbody></table><h2 id="List接口的实现类"><a href="#List接口的实现类" class="headerlink" title="List接口的实现类"></a>List接口的实现类</h2><ul><li><p>ArrayList</p><p>实现了可变的数组，允许保存所有元素包括null .并且可以根据索引的位置对集合进行快速的随机访问，缺点是向指向的索引位置插入对象或删除对象时的速度较慢</p></li><li><p>LinkedList </p><p>采用链表的结构保存对象。优点是便于向集合中插入和删除对象</p><p>分别用ArrayList 和LinkedList来实例化集合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;E&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">List&lt;E&gt; list=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br></pre></td></tr></table></figure><p>E是合法的JAVA数据类型，也可以是字符串String</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> JAVA集合 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA_String_API</title>
      <link href="/2020/05/06/JAVA-String-API/"/>
      <url>/2020/05/06/JAVA-String-API/</url>
      
        <content type="html"><![CDATA[<p>String API</p><ul><li>append()</li></ul><p>  在由许多小段的字符串构建一个字符串时，则使用StringBuilder类（字符串构造器）</p><p>  首先构造一个空的字符串构造器：<br>  <a id="more"></a></p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder builder =<span class="keyword">new</span> StringBuilder();</span><br></pre></td></tr></table></figure><p>  当需要添加一部分内容时，调用append()方法</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">builder.append(ch);</span><br><span class="line">builder.append(str);</span><br><span class="line">String completedString=builder.toString(); <span class="comment">/*调用toString()方法，得到String对象。*/</span></span><br></pre></td></tr></table></figure><ul><li><p>char charAt(int index)</p><p>返回给定位置的代码单元。</p></li><li><p>int length()</p></li></ul><p>​         返回字符串代码单元的个数</p><ul><li><p>String repeat(int count)</p><p>返回一个字符串，将当前字符重复count次</p></li><li><p>boolean equals() </p><p>用来检测俩个字符串是否相等</p><p>boolean equalsIgnoreCase() </p><p>用来检测俩个字符串是否相等（不区分大小写）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"hello"</span>.equals(greeting);</span><br><span class="line"><span class="string">"HELLO"</span>.equalsIgnoreCase(<span class="string">"hello"</span>); <span class="comment">/* 不区分大小写 */</span></span><br></pre></td></tr></table></figure></li><li><p>注意：</p><p><strong>不要用==运算符检测是否相等。</strong></p><p><strong>这个运算符只能够确定俩个字符串是否存放在同一个位置上。</strong>当然如果字符串存放在同一个位置上，它们必然相等，但是完全有可能把内容相同的多个字符串副本放置在不同的位置上。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String greeting=<span class="string">"Hello"</span>;</span><br><span class="line"><span class="keyword">if</span>(greeting ==<span class="string">"Hello"</span>)</span><br><span class="line">  -- <span class="keyword">true</span></span><br><span class="line"> <span class="keyword">if</span>(greeting.substring(<span class="number">0</span>,<span class="number">3</span>)==<span class="string">"Hel"</span>)</span><br><span class="line">  --<span class="keyword">false</span></span><br></pre></td></tr></table></figure><p>实际上只有字符串字面量共享，而+或者substring操作得到的字符串并不共享。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> JAVASE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVASE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA中的输入与输出</title>
      <link href="/2020/05/06/JAVA%E4%B8%AD%E7%9A%84%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA/"/>
      <url>/2020/05/06/JAVA%E4%B8%AD%E7%9A%84%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="JAVA中的输入"><a href="#JAVA中的输入" class="headerlink" title="JAVA中的输入"></a>JAVA中的输入</h1><h2 id="读取输入"><a href="#读取输入" class="headerlink" title="读取输入"></a>读取输入</h2><p>  要想通过输入台进行输入，首先需要构造一个与“标准输入流”System.in关联的Scanner对象。<br>  <a id="more"></a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Scanner scanner=<span class="keyword">new</span> Scanner(System.in);</span><br></pre></td></tr></table></figure><p>Scanner类中的方法：</p><p>API  JAVA.util.Scanner</p><table><thead><tr><th>String nextLine()</th><th>读取输入的下一行内容  以enter作为结束符  能得到带空格的字符串</th></tr></thead><tbody><tr><td>String next()</td><td>读取输入的下一个单词（以空格作为分隔符）空格视而不见</td></tr><tr><td>int nextInt()</td><td>只读取int值</td></tr><tr><td>double nextDouble()</td><td>只读取double值</td></tr><tr><td>boolean hasNext()</td><td>检测输入中是否还有其他的单词</td></tr><tr><td>boolean hasNextInt()</td><td>检测输入中是否还有表示整数</td></tr><tr><td>boolean hasNextDouble()</td><td>检测输入中是否还有表示浮点数</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> JAVASE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVASE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Collection</title>
      <link href="/2020/05/06/Collection/"/>
      <url>/2020/05/06/Collection/</url>
      
        <content type="html"><![CDATA[<h2 id="Java容器可分为两大类："><a href="#Java容器可分为两大类：" class="headerlink" title="Java容器可分为两大类："></a>Java容器可分为两大类：</h2><ul><li><p>Collection接口 继承JAVA.lang.Object</p><ul><li>List接口<ul><li><strong>ArrayList</strong></li><li>LinkedList<a id="more"></a></li><li>Vector(了解，已过时)</li></ul></li><li>Set接口<ul><li>HashSet<ul><li>LinkedHashSet</li></ul></li><li>TreeSet</li></ul></li></ul></li><li><p>Map接口  继承JAVA.lang.Object</p><ul><li><p><strong>HashMap</strong></p><ul><li>LinkedHashMap</li></ul></li><li><p>TreeMap</p></li><li><p>ConcurrentHashMap</p></li><li><p>Hashtable(了解，，已过时)</p></li></ul></li></ul><h2 id="Collection接口："><a href="#Collection接口：" class="headerlink" title="Collection接口："></a>Collection接口：</h2><ul><li><p>Collection接口的常用方法</p></li><li><p>添加功能</p><ul><li><table><thead><tr><th>boolean add(Object obj)</th><th>添加一个元素</th></tr></thead><tbody><tr><td>boolean  addAll(Collection c)</td><td>添加一个集合的元素</td></tr></tbody></table><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">static</span> Collection c = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"add:"</span>+c.add(<span class="string">"hello"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/* 输出为 add:true */</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><p>​             </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> Collection c1 = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    <span class="keyword">static</span> Collection c2 = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        c1.add(<span class="string">"xxxx"</span>);</span><br><span class="line">        System.out.println(<span class="string">"add:"</span> + c1.add(<span class="string">"hello"</span>));</span><br><span class="line">        System.out.println(<span class="string">"addAll:"</span> + c2.addAll(c1));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/* 输出add:true</span></span><br><span class="line"><span class="comment">addAll:true */</span></span><br></pre></td></tr></table></figure><ul><li><p>删除功能</p><ul><li><table><thead><tr><th>void clear()</th><th>移除所有元素</th></tr></thead><tbody><tr><td>boolean remove(Object o)</td><td>移除一个元素</td></tr><tr><td>boolean removeAll(Object o)</td><td>移除一个集合的所有元素</td></tr></tbody></table></li></ul></li></ul><ul><li><p>判断功能</p><ul><li><table><thead><tr><th>boolean contains(Object o)</th><th>判断集合中是否包含指定的元素</th></tr></thead><tbody><tr><td>boolean containsAll(Object o)</td><td>判断集合中是否包含指定的集合元素（一个集合中的所有元素</td></tr><tr><td>boolean isEmpty()</td><td>判断集合是否为空</td></tr></tbody></table></li></ul></li><li><p><strong>获取功能</strong></p><p>重点：迭代器（Iterator） 下一篇中我们详细解释。</p><p>itetator()   返回在此 Collection 的元素上进行迭代的迭代器。用于遍历集合中的对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Muster</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Collection&lt;String&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">"a"</span>);</span><br><span class="line">        list.add(<span class="string">"b"</span>);</span><br><span class="line">        list.add(<span class="string">"c"</span>);</span><br><span class="line">        Iterator&lt;String&gt; it=list.iterator();</span><br><span class="line">        <span class="keyword">while</span>(it.hasNext())</span><br><span class="line">        &#123;</span><br><span class="line">            String str=(String) it.next();</span><br><span class="line">            System.out.println(str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> JAVA集合 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>char可以存储汉字吗？</title>
      <link href="/2020/05/06/char%E5%8F%AF%E4%BB%A5%E5%AD%98%E5%82%A8%E6%B1%89%E5%AD%97%E5%90%97%EF%BC%9F/"/>
      <url>/2020/05/06/char%E5%8F%AF%E4%BB%A5%E5%AD%98%E5%82%A8%E6%B1%89%E5%AD%97%E5%90%97%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="char存储汉字"><a href="#char存储汉字" class="headerlink" title="char存储汉字"></a>char存储汉字</h2><ul><li><p>char是按照字符存储的，不管是英文还是中文，JAVA中固定占用2个字符，用来存储Unicode字符，范围在0-65535.</p></li><li><p>Unicode编码字符集中包含了汉字，所以char类型变量当然可以存储汉字拉。</p><a id="more"></a><h2 id="char和String的区别"><a href="#char和String的区别" class="headerlink" title="char和String的区别"></a>char和String的区别</h2><ul><li>char表示字符，定义时用单引号，只能存储一个字符。如char c=‘x’ ;</li><li>String表示的是字符串，可以存储一个或多个字符 如String name=”tom”;</li><li></li></ul></li></ul><p>如name.length();</p>]]></content>
      
      
      <categories>
          
          <category> JAVASE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVASE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA的静态方法不能被重写</title>
      <link href="/2020/05/06/JAVA%E7%9A%84%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E4%B8%8D%E8%83%BD%E8%A2%AB%E9%87%8D%E5%86%99/"/>
      <url>/2020/05/06/JAVA%E7%9A%84%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E4%B8%8D%E8%83%BD%E8%A2%AB%E9%87%8D%E5%86%99/</url>
      
        <content type="html"><![CDATA[<h1 id="JAVA的静态方法不能被重写"><a href="#JAVA的静态方法不能被重写" class="headerlink" title="JAVA的静态方法不能被重写"></a>JAVA的静态方法不能被重写</h1><p>堆区：</p><ul><li>存储的全部都是对象，每个对象都包含一个与之对应的class信息。<a id="more"></a></li></ul><p>栈区:</p><p>方法区：</p><ul><li>方法区包含所有的class和static变量  class可以直接调用static</li></ul>]]></content>
      
      
      <categories>
          
          <category> JAVASE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVASE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA多态</title>
      <link href="/2020/05/06/JAVA%E5%A4%9A%E6%80%81/"/>
      <url>/2020/05/06/JAVA%E5%A4%9A%E6%80%81/</url>
      
        <content type="html"><![CDATA[<h1 id="JAVA多态"><a href="#JAVA多态" class="headerlink" title="JAVA多态"></a>JAVA多态</h1><p>JAVA的三大特性为：</p><ul><li><p>封装</p></li><li><p>继承</p></li><li><p>多态</p><p>今天我们就来说一说到底什么是多态，以及多态到底有什么用。</p><a id="more"></a><h2 id="多态的定义"><a href="#多态的定义" class="headerlink" title="多态的定义"></a>多态的定义</h2><p>定义： <strong>事物的不同形态。</strong>多态多应用在向上转型。</p><p>多态的用处：在实际开发中，如果发现某个类的方法可以做出改进，但工程已经交付给用户使用，但是不想影响其他部分对于该方法的调用。那么通过创建子类对象，对于父类方法进行<strong>重写</strong>（Override）。<strong>但是此时父类的其他成员方法和成员属性却不能进行利用</strong>。此时就需要用到<strong>向上转型</strong>，将子类向上转换为父类，此时程序的相应方法做出了改进，程序的其他地方也不会受此影响。</p></li></ul><h2 id="多态的三个前提："><a href="#多态的三个前提：" class="headerlink" title="多态的三个前提："></a>多态的三个前提：</h2><ul><li><p>存在继承关系，子类继承父类</p></li><li><p>子类要重写父类的方法 </p><p>子类重写父类的成员方法。</p></li><li><p>父类数据类型的引用要指向子类对象 （向上转型）</p><p>如 Animal am=new Cat();</p><h2 id="多态的弊端"><a href="#多态的弊端" class="headerlink" title="多态的弊端"></a>多态的弊端</h2><p>向上转型之后，<strong>不能够引用子类特有的成员属性和子类特有的成员方法</strong>。</p></li></ul><p>  <strong>注意：静态方法不能被重写，所以也不存在多态，即使向上转型，子类重写了父类的静态方法，子类调用父类的静态方法，输出依然是父类静态方法中的值。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVASE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>时间复杂度</title>
      <link href="/2020/05/05/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"/>
      <url>/2020/05/05/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="算法时间复杂度"><a href="#算法时间复杂度" class="headerlink" title="算法时间复杂度"></a>算法时间复杂度</h1><h2 id="算法时间复杂度定义"><a href="#算法时间复杂度定义" class="headerlink" title="算法时间复杂度定义"></a>算法时间复杂度定义</h2><ul><li><p>O()来体现算法时间复杂度的记法</p><a id="more"></a><h2 id="推导大O阶的方法"><a href="#推导大O阶的方法" class="headerlink" title="推导大O阶的方法"></a>推导大O阶的方法</h2><ol><li><p>用常数1代替所有加法常数</p></li><li><p>在修改后的运行次数函数中，只保留最高阶项</p></li><li><p>如果最高阶项存在且不是1，则去除这个项相乘的常数</p><p>得到的结果就是大O阶.</p><h3 id="举例说明："><a href="#举例说明：" class="headerlink" title="举例说明："></a>举例说明：</h3><h4 id="常数阶"><a href="#常数阶" class="headerlink" title="常数阶"></a>常数阶</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sum=<span class="number">0</span>,n=<span class="number">100</span>; <span class="comment">//执行1次</span></span><br><span class="line">sum=(<span class="number">1</span>+n)*n/<span class="number">2</span>; <span class="comment">//执行2次</span></span><br><span class="line">sum=(<span class="number">1</span>+n)*n/<span class="number">2</span>; <span class="comment">//</span></span><br><span class="line">sum=(<span class="number">1</span>+n)*n/<span class="number">2</span>; <span class="comment">//</span></span><br><span class="line">sum=(<span class="number">1</span>+n)*n/<span class="number">2</span>; <span class="comment">//</span></span><br><span class="line">...</span><br><span class="line">sum=(<span class="number">1</span>+n)*n/<span class="number">2</span>; <span class="comment">//执行10次</span></span><br></pre></td></tr></table></figure><p>事实上无论n为多少，上面代码就是1次，2次，10次的差别，这种与问题大小无关（与n的大小无关）执行时间恒定的算法。称为O(1)阶，又叫常数阶</p><h4 id="线性阶"><a href="#线性阶" class="headerlink" title="线性阶"></a>线性阶</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 时间复杂度为O(1)的程序     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ul><p>​               循环的时间复杂度为O(n)</p><h4 id="对数阶"><a href="#对数阶" class="headerlink" title="对数阶"></a>对数阶</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int count&#x3D;1;</span><br><span class="line">while (count &lt;n)</span><br><span class="line">&#123;</span><br><span class="line">count &#x3D;count *2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2^x=n  x=log2 n   所以这个循环的时间复杂度为O(log n).</p><h4 id="平方阶"><a href="#平方阶" class="headerlink" title="平方阶"></a>平方阶</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i,j;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">/*时间复杂度为O(1)的程序步骤序列      */</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度为O(m*n)</p><p>又如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i,j;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(j=i;j&lt;n;j++)</span><br><span class="line">&#123;</span><br><span class="line"> <span class="comment">/* 时间复杂度为O(1)的程序*/</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行总次数 n+n-1+(n-2)+…+1=n(n+1)/2   时间复杂度为O(n^2) </p><h4 id="常见的时间复杂度"><a href="#常见的时间复杂度" class="headerlink" title="常见的时间复杂度"></a>常见的时间复杂度</h4><p>常用时间复杂度耗费时间比对：</p><p>O(1)&lt;O(log n)&lt;O(n)&lt;O(nlogn)&lt;O(n^2)&lt;O(n^3)&lt;O(2^n)&lt;O(n!)&lt;O(n^n)</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DataStructure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性表</title>
      <link href="/2020/05/05/%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
      <url>/2020/05/05/%E7%BA%BF%E6%80%A7%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h1><h2 id="线性表的定义："><a href="#线性表的定义：" class="headerlink" title="线性表的定义："></a>线性表的定义：</h2><ul><li>线性表：零个或多个数据元素的有限序列</li><li>线性表元素的个数n 定义为线性表的长度，当n=0时，称为空表<a id="more"></a></li></ul><h2 id="线性表的顺序存储结构"><a href="#线性表的顺序存储结构" class="headerlink" title="线性表的顺序存储结构"></a>线性表的顺序存储结构</h2><ul><li><p>顺序存储定义： 线性表的顺序存储结构，指的是用一段地址连续的存储单元依次存储线性表的数据元素</p><h3 id="顺序存储方式"><a href="#顺序存储方式" class="headerlink" title="顺序存储方式"></a>顺序存储方式</h3><ul><li><p>顺序存储的结构代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 20 </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemType data[MAXSIZE];</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">&#125;SqList;</span><br></pre></td></tr></table></figure><p>MAXSIZE：数组长度</p><p>length： 线性表当前的长度</p><p>另外以数组data进行存储</p></li><li><p>线性表中的地址</p><p>存储器中的每个存储单元都有自己的编号，这个编号称为地址。</p><h3 id="顺序存储结构的插入与删除"><a href="#顺序存储结构的插入与删除" class="headerlink" title="顺序存储结构的插入与删除"></a>顺序存储结构的插入与删除</h3><h4 id="获得元素操作"><a href="#获得元素操作" class="headerlink" title="获得元素操作"></a>获得元素操作</h4><p>我们实现GetElem操作，即把线性表L中的第i个元素值返回。只要i的数值在数组范围内，就是把数组的第i-1下标返回即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR 0 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status; <span class="comment">/*函数的类型 */</span></span><br><span class="line"><span class="function">Status <span class="title">GetElem</span><span class="params">(SqList L,<span class="keyword">int</span> i,ElemType *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L.length==<span class="number">0</span> ||i&lt;<span class="number">1</span> ||i&gt;L.length)</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    *e=L.data[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h4><p>算法思路：</p><ul><li><p>插入位置不合理</p></li><li><p>线性表长度大于数组长度</p></li><li><p>从最后一个元素遍历到第i个元素</p></li><li><p>将要插入的元素填到位置i处</p></li><li><p>表长+1</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ListInsert</span><span class="params">(SqList *L,<span class="keyword">int</span> i,ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> k;</span><br><span class="line"><span class="keyword">if</span>(L-&gt;length==MAXSIZE)</span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line"><span class="keyword">if</span>(i&lt;<span class="number">1</span>||i&gt;L-&gt;length+<span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line"><span class="keyword">if</span>(i&lt;=L-&gt;length)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(k=L-&gt;length<span class="number">-1</span>;k&gt;=i<span class="number">-1</span>;k--)</span><br><span class="line">&#123;</span><br><span class="line">L-&gt;data[k+<span class="number">1</span>]=L-&gt;data[k];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">L-&gt;data[i<span class="number">-1</span>]=e;</span><br><span class="line">L-&gt;length++;</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DataStructure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>指针</title>
      <link href="/2020/05/04/%E6%8C%87%E9%92%88/"/>
      <url>/2020/05/04/%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<h1 id="10-1-指针变量"><a href="#10-1-指针变量" class="headerlink" title="10.1 指针变量"></a>10.1 指针变量</h1><p> 由于通过地址能访问指定的内存存储单元。可以说地址“指向”该内存单元。地址可以形象地称为指针，意思是通过指针能够找到内存单元。<br> <a id="more"></a></p><h2 id="1一个变量的地址称为该变量的指针，如果有一个变量专门用来存放另一个变量的地址，那么它就是指针变量。"><a href="#1一个变量的地址称为该变量的指针，如果有一个变量专门用来存放另一个变量的地址，那么它就是指针变量。" class="headerlink" title="1一个变量的地址称为该变量的指针，如果有一个变量专门用来存放另一个变量的地址，那么它就是指针变量。"></a>1一个变量的地址称为该变量的指针，如果有一个变量专门用来存放另一个变量的地址，那么它就是指针变量。</h2><p>一般形式为：<br>类型说明 * 变量名<br>int * q;<br>C语言中提供了地址运算符“&amp;”来表示变量的地址。其中一般形式为：<br>&amp;变量名;</p><h2 id="2给指针变量赋值一般有俩个方法"><a href="#2给指针变量赋值一般有俩个方法" class="headerlink" title="2给指针变量赋值一般有俩个方法"></a>2给指针变量赋值一般有俩个方法</h2><p>1   </p><pre><code>int a;int *p=&amp;a;</code></pre><p>2       </p><pre><code>int a;int *p;p=&amp;a;</code></pre><h2 id="3-指针变量的引用"><a href="#3-指针变量的引用" class="headerlink" title="3 指针变量的引用"></a>3 指针变量的引用</h2><p>引用指针变量是对变量进行间接访问的一种形式</p><p>对指针变量的引用形式如下：</p><p>*指针变量 其含义是引用指针变量所指向的值</p><h2 id="4-amp-和-的区别"><a href="#4-amp-和-的区别" class="headerlink" title="4 &amp; 和 *的区别"></a>4 &amp; 和 *的区别</h2><p> &amp;运算符是一个返回操作数地址的单目运算符，叫做取地址运算符</p><p> *运算符是返回指定的地址内的变量的值，叫做指针运算符。</p><h2 id="5-指针自增和自减运算"><a href="#5-指针自增和自减运算" class="headerlink" title="5 指针自增和自减运算"></a>5 指针自增和自减运算</h2><p>基本整型变量i在内存中占4个字节，指针P是指向变量i的地址的，p++是指向下一个存放基本整型数的地址。</p><h2 id="6-数组与指针"><a href="#6-数组与指针" class="headerlink" title="6 数组与指针"></a>6 数组与指针</h2><p>在定义一个一维数组时，系统会在内存中为该数组分配一个存储空间，其数组的名称就是数组在内存中的首地址。<br>例如：</p><p>1     </p><pre><code>int *p,a[10];  p=a;</code></pre><p>或</p><p>2   </p><pre><code>int *p,a[10]; p=&amp;a[0];</code></pre><h2 id="7-二维数组与指针"><a href="#7-二维数组与指针" class="headerlink" title="7 二维数组与指针"></a>7 二维数组与指针</h2><p>表示二维数组中元素地址的方法：</p><p>&amp;a[0][0]可以看作数组0行0列的首地址，也可以看作二维数组的首地址。</p><p>&amp;a[m][n]就是第m行n列元素的地址。而a[0]+n表示第0行第n个元素的地址。</p><h2 id="8指针变量作为函数参数"><a href="#8指针变量作为函数参数" class="headerlink" title="8指针变量作为函数参数"></a>8指针变量作为函数参数</h2><p>指针变量也可以作为函数参数</p><p>例<br>在swap（int <em>a,int</em> b)中</p><p>在函数调用的过程中，主调用函数与被调用函数之间有一个数值传递的过程。函数调用中发生的数据传递是单向的，只能把实际参数的值传递给形式参数，在函数调用的过程中，形式参数的值发生改变，但是实际参数的值不会发生变化。</p><p>如果swap(int a,int b) 则不能实现x与y值的互换。</p><p>通过指针传递参数可以减少值传递带来的开销，也可以使函数调用不产生值传递。</p><h2 id="9返回指针值的函数"><a href="#9返回指针值的函数" class="headerlink" title="9返回指针值的函数"></a>9返回指针值的函数</h2><p>返回的值的类型为指针类型，返回指针值的函数简称为指针函数</p><p>定义指针函数的一般形式为 </p><p>类型名 *函数名（参数列表） </p><p>如   int *fun(int x,int y)</p><p>如 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *per(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">int</span> *p;</span><br><span class="line"> p=&amp;Perimeter;</span><br><span class="line"> Perimeter=(a+b)*<span class="number">2</span>;</span><br><span class="line"> <span class="keyword">return</span> p; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql必知必会</title>
      <link href="/2020/05/03/mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"/>
      <url>/2020/05/03/mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/</url>
      
        <content type="html"><![CDATA[<h2 id="1-基础操作"><a href="#1-基础操作" class="headerlink" title="1 基础操作"></a>1 基础操作</h2><p> 登录mysql -u root -p<br> Show databases;<br> Use databasename;<br>Show tables;  //显示行</p><a id="more"></a><p> Show columns from xxx;   //显示列 </p><h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><p>SELECT DISTINCT  published FROM t_blog ;  DISTINCT此关键字指示只返回不同的值。<br> SELECT id FROM t_blog LIMIT 5;<br> SELECT id FROM t_blog LIMIT 3,3; //从第三行开始的后三行<br> SELECT t_blog.id FROM blog.t_blog;   完全限定的列名和表名 和之前的用法一样。<br> SELECT id,type_id,user_id FROM t_blog ORDER BY type_id,id;  先对type_id排序 再对id进行排序。<br> DESC 降序 ASC 升序  默认升序<br> SELECT id FROM t_blog ORDER BY type_id LIMIT 1; 此种方式找到了数值最大的一行。<br> <strong>在使用where 过滤时 ，order by 排序要在where的后面</strong><br> SELECT id FROM t_blog  where id &lt;&gt;10;   &lt;&gt; 不匹配检查<br> 范围值检查<br>  SELECT ID FROM T_BLOG WHERE ID BETWEEN 10 AND 20 :<br> Select id from t_blog where id is null;  空值检查<br> Select id,user_id from t_blog where id &lt;=10 and user_id &lt;=1;<br> Select prod_name,prod_price from products where vend_id=1002 or vend_id =1003 and<br>  Prod_price&gt;=10; SQL处理OR操作符和AND操作符时，优先处理AND操作符。<br> 故先处理 vend_id =1003 and prod_price&gt;=10  或者  vend_id=1002  ；<br>解决方法是<br>Select prod_name,prod_price from products where (vend_id =1002 or vend_id =1003) and prod_price &gt;=10    用( )来明确分组操作符。DBMS 首先过滤圆括号内的OR条件。<br>NOT 在MYSQL中的NOT中 MYSQL支持使用NOT 对IN,BETWEEN 和EXISTS子句取反。这与多数其他DBMS允许使用NOT对各种条件取反有很大区别。<br>######<br>通配符<br>用来匹配值的一部分的特殊字符<br>LIKE 指示MYSQL 后跟的搜索模式利用通配符匹配而不是直接相等匹配比较<br>SELECT prod_name FROM products WHERE prod_name REGEXP ‘[123] Ton’<br>ORDER BY prod_name;<br>正则表达式 [123]Ton 其中[123]定义一组字符<br>它的意思是匹配1或2或3  因此 1ton 和2ton 都匹配且返回了<br>[] 其实是另一种形式的OR语句<br>[1|2|3]Ton 的缩写 为 [123]Ton<br>1|2|3 Ton 的意思是检索出1或2或3 ton<br>[^123] 匹配除这些字符除外的任何东西<br> ^ 是REGEXP的否定符号<br>在匹配范围中<br>0到9  将由[0123456789] 等同于 [0-9]<br>.表示匹配一个字符<br>输入 SELECT vend_name FROM vendors WHERE vend_name REGEXP ‘.’ ORDER BY vend_name<br>.匹配任意字符  这时每一行都被检索出来 为了匹配特殊字符 必须用\ 作为前导<br>如<br>SELECT vend_name FROM vendors WHERE vend_name REGEXP ‘\.’ ORDER BY vend_name<br>这才是期望的输出 \.匹配. 这种处理就是所谓的转义。<br>？ 字符 ？匹配它前面的任何字符的0次或者1次出现。<br> 如 SELECT prod_name FROM products WHERE prod_name REGEXP ‘\([0-9] sticks?\)’<br> ORDER BY prod_name ;<br>Sticks 匹配 stick 和sticks s后的?使s可选<br>另外例如<br>SELECT prod_name FROM products WHERE prod_name REGEXP ‘[[:digit:]]{4}<br>ORDER BY prod_name；<br>[:digit:]匹配任意数字<br>因而它作为数字的一个集合<br>{4} 确切的要求它前面的字符 出现4次<br>匹配特定位置的文本，需要使用表9-4列出的定位符<br>^ 文本的开始<br>$ 文本的结尾<br>[[:&lt;:]] 词的开始<br>[[:&gt;;]] 词的结尾<br>‘^[0-9\.]’ 找出一个数 包括以小数点开始的数开始的所有产品。<br>SELECT prod_name FROM products WHERE prod_name REGEXP ‘^[0-9\.]’<br>ORDER BY prod_name;</p><h2 id="第10章-创建计算字段"><a href="#第10章-创建计算字段" class="headerlink" title="第10章  创建计算字段"></a>第10章  创建计算字段</h2><p>MySQL 使用Concat() 函数来实现<br>SELECT Concat(vend_name,’（‘，vend_country,’）’)<br>FROM vendors ORDER BY vend_name;<br>拼接  将值联结到一起构成单个值<br>比如以上的输出为<br>ACME (USA)<br>删除数据右侧多余的空格来整理数据<br>MySQL 的RTrim()可以去掉值右边的所有的空格<br>SELECT Concat(RTrim(vend_name),’(‘,RTrim(vend_country),’)’)<br>FROM vendors<br>ORDER BY vend_name;<br>LTrim() 去掉串左边的空格<br>Trim()去掉左右俩边的空格<br>SELECT Concat (RTrim(vend_name),’(‘,RTrim(vend_country),’)’)AS vend_title FROM vendors ORDER BY vend_name;<br>一个未命名的列不能用于客户机的应用中，因为客户机没有办法去引用它。<br>所以才出现了别名。AS 关键字来赋予别名 任何客户机应用都可以按名来引用这个列，就像它是一个实际的表列一样。</p><p>执行算数运算<br>SELECT pro_id,quantity,item_price FROM oderitems WHERE order order_num =20005;<br>在算数运算中 检索200005中的所有物品<br>如果要计算汇总物品的价格<br>SELECT prod_id ,quantity,item_price, quantity*item_price  AS expanded_price FROM oderitems WHERE order_num =20005;<br>此时客户机可以使用这个新计算的列，就像其他列一样。<br>MYSQL 支持基本算术运算符</p><h2 id="第十一章-使用数据来处理函数"><a href="#第十一章-使用数据来处理函数" class="headerlink" title="第十一章 使用数据来处理函数"></a>第十一章 使用数据来处理函数</h2><p>SELECT vend_name,Upper(vend_name) AS  vend_name_upcase FROM vendors ORDER BY vend_name;<br>Upper()将文本转换为大写<br>常用的文本处理函数：<br>Left() 返回串左边的字符<br>Length() 返回串的长度<br>Locate()返回串的一个子串<br>Lower()将串转换为小写<br>LTrim() 去掉左边的空格<br>Right()返回串右边的字符<br>RTrim() 去掉串右边的空格<br>Soundex()返回串的Soundex值<br>SubString() 返回子串的字符<br>Upper() 大写<br>Soundex（） 将任何文本串转换为描述其语音表示的字母数字模式的算法<br>如<br>SELECT cust_name ,cust_contact FROM customers WHERE cust_contact =’Y.Lie’;<br>其联系名是为Y.Lee 此时没办法搜索到<br>但是通过<br>SELECT cust_name,cust_contact FROM customers WHERE Soundex(cust_contact)=Soundex(‘Y.lie);<br>此时可以搜索到Y.Lee<br>日期和时间的处理函数<br>Date() 返回日期部分的日期部分<br>Year() 返回日期部分的年份部分<br>Day()<br>Month()</p><p>如：<br>SELECT cust_id,oder_num FROM oders WHERE Date(order_date)=’2005-09-01’;<br>SELECT cust_id,order_num FROM orders WHERE Date(order_date) BETWEEN ‘2005-09-01’AND’2005-03-30’;<br>数值处理函数<br>Abs() 返回数的绝对值</p><p>Cos() 角度的余弦<br>Exp() 返回一个数的指数值<br>Mod() 操作数的余数<br>……</p><h2 id="第12章-汇总数据"><a href="#第12章-汇总数据" class="headerlink" title="第12章 汇总数据"></a>第12章 汇总数据</h2><p>12.1 聚集函数  运行在行组上，计算和返回单个值得函数<br>AVG() 返回某列的平均值<br>COUNT()  返回某列的行数<br>MAX() 返回某列的最大值<br>MIN() 返回某列的最小值<br>SUM() 返回某列值之和<br>SELECT AVG(prod_price) AS avg_price FROM products;<br>AVG() 也可以用来确定列或行当平均值<br>SELECT AVG(prod_price) AS avg_price FROM products WHERE vend_id =1003;<br>COUNT () 函数<br>COUNT(<em>)对表中的行的数目进行技术<br>COUNT(column) 对特定列中具有值的行进行计数<br>例如SELECT COUNT(</em>) AS num_cust FROM customers;<br>利用COUNT(*)对所有行计数<br>SELECT COUNT(cust_email) AS num_cust FROM customers;<br>对于cust_email中所有有值的行进行计数<br>MAX() 指定列中的最大值 MAX()要求指定列名。<br>MIN()<br>SUM() 也可以用来合计计算值 用来得出总的订单金额<br>SELECT SUM(item_price  *quantity) AS total_price FROM oderitems WHERE order_num=20005;<br>SUM(item_price *quantity) 返回订单中所有物品价钱之和</p><h2 id="第13章-分组数据"><a href="#第13章-分组数据" class="headerlink" title="第13章 分组数据"></a>第13章 分组数据</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT vend_id ,COUNT(*) AS num_prods FROM products GROUP BY vend_id;</span><br></pre></td></tr></table></figure><p>Vend_id num_prods<br>1001        3<br>1002        2<br>1003        7<br>1005        2<br>上述语句将vend_id进行分组，GROUP BY 对于分组的整个结果集进行聚集<br>使用ROLLUP 使用WITH ROLLUP 关键字，将得到每个分组以及分组汇总级别的值<br>2如何过滤分组?<br>HAVING<br>如： SELECT cust_id ,COUNT(<em>)AS orders FROM orders GROUP BY cust_id<br>HAVING COUNT(</em>) &gt;=2<br>它过滤COUNT(<em>)&gt;=2 的那些分组<br>输入： SELECT vend_id,COUNT(</em>) AS num_prods FROM products WHERE prod_price &gt;=10<br>GROUP BY vend_id HAVING COUNT(*)&gt;=2;<br>13.4 分组和排序<br>GROUP BY 和ORDER BY<br>GROUP BY  是在ORDER BY 之前，在where 之后</p><h1 id="group-by-和-order-by-的区别-理解过程"><a href="#group-by-和-order-by-的区别-理解过程" class="headerlink" title="group by 和 order by 的区别 + 理解过程"></a>group by 和 order by 的区别 + 理解过程</h1><p><a href="https://blog.csdn.net/sinat_40692412/article/details/81200133">https://blog.csdn.net/sinat_40692412/article/details/81200133</a></p><h2 id="第14章-子查询"><a href="#第14章-子查询" class="headerlink" title="第14章 子查询"></a>第14章 子查询</h2><p>子查询：嵌套在其他查询中的查询<br>1 检索包含物品TNT2 的所有订单的编号<br> SELECT order_num FROM orderitems WHERE prod_id =’TNT2’；<br>2 检索具有前一步骤列出的订单编号的所有客户的ID<br> SELECT cust_id FROM orders WHERE order_num IN (20005,20007);<br>3 现在把第一个查询变为子查询 组合成俩个查询：<br> SELECT cust_id FROM oders WHERE order_num IN (SELECT order_num FROM orderitems WHERE prod_id =’TNT2’);<br>在SELECT 语句中，子查询总是从内向外查询处理。<br>检索这些客户的ID的客户信息，检索俩列的SQL语句为：<br>SELECT cust_name, cust_contact FROM customers WHERE cust_id IN (10001,10004);<br>则可以转换为：<br>SELECT cust_name ,cust_contact FROM customers WHERE cust_id IN (SELECT cust_id FROM orders WHERE order_num IN (SELECT order_num FROM orderitems WHERE prod_Id =’TNT2’))；<br>计算结果子查询：<br>SELECT cust_name,cust_state,(SELECT COUNT(*) FROM oders WHERE orders.cust_id=customers.cust_id)AS orders FROM customers ORDER BY cust_name;</p><h2 id="第15-章-联结表-join-表"><a href="#第15-章-联结表-join-表" class="headerlink" title="第15 章  联结表  join 表"></a>第15 章  联结表  join 表</h2><p>外键位某个表中的一列 它包含另一个表的主键值定义了俩个表之间的关系。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT vent_name,prod_name,prod_price </span><br><span class="line">FROM vendors ,products </span><br><span class="line">WHERE vendors.vend_id&#x3D;products.vend_id;</span><br><span class="line">ORDER BY vend_name,prod_name ;</span><br></pre></td></tr></table></figure><p>此种方法通过WHERE子句来限定了列名 ，如果要给出 vend_id 那么mysql_id 并不知道是哪个<br>存在一种状况是<br>笛卡尔积：<br>在不指定where子句时</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT vend_name ,prod_name,prod_price </span><br><span class="line">FROM vendors,products ORDER BY vend_name,prod_name;</span><br></pre></td></tr></table></figure><h3 id="15-2-2-内部联结"><a href="#15-2-2-内部联结" class="headerlink" title="15.2.2 内部联结"></a>15.2.2 内部联结</h3><p>目前为止所使用的联结称为 等值联结  它基于俩个表之间的相等测试 这种联结也叫内部联结。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT vend_name , prod_name , prod_price FROM vendors INNER JOIN products ON vendors.vend_id &#x3D;products.vend_id ;</span><br></pre></td></tr></table></figure><p>此时使用的是INNER JOIN  联结条件用的是ON</p><h3 id="联结多个表："><a href="#联结多个表：" class="headerlink" title="联结多个表："></a>联结多个表：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT prod_name,vend_name,prod_price,quantity FROM orderitems,products,vendors WHERE products.vend_id &#x3D;vendors.vend_id AND orderitems.prod_id &#x3D;products.prod_id AND order_num &#x3D;20005;</span><br></pre></td></tr></table></figure><h2 id="第16章-创建高级联结"><a href="#第16章-创建高级联结" class="headerlink" title="第16章 创建高级联结"></a>第16章 创建高级联结</h2><h3 id="使用表别名"><a href="#使用表别名" class="headerlink" title="使用表别名"></a>使用表别名</h3><p>SELECT Concat(RTrim(vend_name)，‘（’，RTrim（vend_country）,’）’) AS vend_title FROM vendors ORDER BY vend_name;</p><h3 id="内部联结："><a href="#内部联结：" class="headerlink" title="内部联结："></a>内部联结：</h3><p>它基于俩个表之间的相等测试<br>SELECT vend_name .prod_name,prod_price FROM vendors INNER JOIN products ON vendors.vend_id =produces.vend_id;</p><h3 id="自联结：-引用别名，自己联结自己"><a href="#自联结：-引用别名，自己联结自己" class="headerlink" title="自联结： 引用别名，自己联结自己"></a>自联结： 引用别名，自己联结自己</h3><p>SELECT p1.prod_id,p1.prod_name FROM products AS p1,products AS p2<br>WHERE p1.vend_id =p2.vend_id AND p2.prod_id =’DTNTR’;<br>此查询种需要的俩个表实际上是相同的表。<br>因此products 表在from 子句中出现了俩次。虽然这是合法的，但是对products 的引用具有二义性。因此使用了别名。（用自联结而不用子查询。有时候处理联结要比处理查询要快的多）</p><h3 id="自然联结："><a href="#自然联结：" class="headerlink" title="自然联结："></a>自然联结：</h3><p>其中你只能选择那些唯一的列。<br>通过对表使用通配符（SELECT <em>）对所有其他表的列使用明确的子集来完成的。</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT c.*,o.ordr_num,o.order_date,oi.prod_id,oi.quantity,OI.item_price FROM customers AS c,orders AS o,orderitems AS oi WHERE c.cust_id &#x3D;o.cust_id AND oi.order_num &#x3D;o.order_num</span><br><span class="line">AND prod_id &#x3D;’FB’;</span><br></pre></td></tr></table></figure><p>通配符只对第一个表使用，所有其他列明确列出，所以没有重复的列被检索出来。</p><h3 id="外部联结："><a href="#外部联结：" class="headerlink" title="外部联结："></a>外部联结：</h3><p>许多联结将一个表中的行与另外一个表中的行相关联，但有时候会需要包含没有关联行的那些行，例如  可能需要使用联结来完成以下的工作：<br>1对每个客户下了多少订单进行计数，包括那些至今未下订单的客户。<br>2列出所有产品以及订购数量，包括没有人订购的产品<br>3计算平均销售规模，包括那些至今未下订单的客户<br>联结包含了那些在相关表中没有关联行的行，这种叫做外部联结<br>内部联结检索所有客户及其订单：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT customers.cust_id,order.orders.order_num FROM customers INNER JOIN orders ON</span><br><span class="line">Customers.cust_id &#x3D;orders.cust_id;</span><br></pre></td></tr></table></figure><h3 id="外部联结：-1"><a href="#外部联结：-1" class="headerlink" title="外部联结："></a>外部联结：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT customers.cust_id ,orders.order_num FROM customers LEFT OUTER JOIN oders </span><br><span class="line">ON customers.cust_id &#x3D;orders.cust_id;</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cust_id   order_num</span><br><span class="line"> 10001      20005</span><br><span class="line"> 10001      20009</span><br><span class="line"> 10002       null</span><br><span class="line">10003       null</span><br></pre></td></tr></table></figure><p>此时必须要用RIGHT 或LEFT 关键字指定包括其所有行的表<br>其实就是左外部联结和右外部联结</p><p>此时必须要用RIGHT 或LEFT 关键字指定包括其所有行的表<br>其实就是左外部联结和右外部联结</p><h3 id="16-3-使用带聚集函数的联结"><a href="#16-3-使用带聚集函数的联结" class="headerlink" title="16.3 使用带聚集函数的联结"></a>16.3 使用带聚集函数的联结</h3><p>使用了COUNT（）函数的联结<br>SELECT customers.cust_name, customers.cust_id,COUNT(orders.order_num) AS num_ord FROM customers INNER JOIN orders ON customers.cust_id =orders.cust_id GROUP BY customers.cust_id;<br>SELECT 语句使用INNER JOIN 将customers和orders 表互相关联。 GROUP BY 子句按客户分组数据。<br>聚集函数也可以方便地与其他联结一起使用，<br>如 SELECT customers,cust_name,cusomers,cust_id,COUNT(orders,order_num)AS num_ord FROM customers LEFT OUTER JOIN orders ON customers.cust_id =orders.cust_id  GROUP BY customers.cust_id;</p><h2 id="17-章-组合查询"><a href="#17-章-组合查询" class="headerlink" title="17 章 组合查询"></a>17 章 组合查询</h2><p>利用UNION 操作符将多条SELECT 语句组合成一个结果集<br>执行多个查询，多个SELECT 语句 并将结果作为单个查询结果集返回。<br>这种称为并（union）或复合查询<br>使用UNION<br>输入<br>SELECT vend_id ,prod_id ,prod_price FROM products WHERE prod_price &lt;=5<br>UNION<br>SELECT vend_id,prod_id,prod_price FROM products WHERE vend_id IN(1001,1002);<br>也可以使用多个where<br>SELECT vend_id ,prod_id,prod_price FROM products WHERE prod_price &lt;=5 OR vend_id IN<br>(1001,1002);<br>从多个表中检索数据的情形，使用UNION 可能会处理更简单。<br>17.2.2 UNION 规则<br> 1   UNION 的每个查询必须包含相同的列，表达式，或聚集函数</p><p> 2   UNION 的默认行为，如果想返回所有匹配行 可以使用UNION ALL 而不是UNION<br> 17.2.4 对组合查询结果排序<br>SELECT vend_id ,prod_id,prod_price FROM products WHERE prod_price &lt;=5<br>UNION<br>SELECT vend_id,prod_id,prod_price FROM products WHERE vend_id IN (1001,1002)<br>ORDER BY vend_id ,prod_price ;</p><h2 id="18章-全文本搜素"><a href="#18章-全文本搜素" class="headerlink" title="18章 全文本搜素"></a>18章 全文本搜素</h2><p>18.1 理解全文本搜素</p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
